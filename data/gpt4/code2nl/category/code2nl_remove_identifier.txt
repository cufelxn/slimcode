public final ExampleData getSelectedExampleData ( ) { Set < String >  = getSelectedRows ( ) ; if (  == null ||  . isEmpty ( ) ) { return null ; } for ( String  :  ) { List < Integer >  =  . rowIndexStringToList (  ) ; return getTreeModel ( ) . getExampleData (  ) ; } return null ; }<CODESPLIT>Get the example which is selected in the tree .
public void dimAt ( float alpha ) { if ( !  ) { return ; } if (  == null ) {  = makeDimView ( ) ; } if ( !  . isShown ( ) ) {  . setVisibility (  ) ;  . setBackgroundColor (  ) ; }  . setAlpha (  ) ; }<CODESPLIT>Set the dim - behind layer a specific opacity .
public Path extract ( ) { if ( isFound ( ) ) throw new IllegalStateException ( "Extract can only be called once" ) ;  . start ( ) ; SPTEntry  =  ; setEndNode (  . adjNode ) ; boolean  =  . Edge . isValid (  . edge ) ; int  ; while (  ) {  =  . Edge . isValid (  . parent . edge ) ;  =  ?  . parent . edge :  . NO_EDGE ; processEdge (  . edge ,  . adjNode ,  ) ;  =  . parent ; } setFromNode (  . adjNode ) ; reverseOrder ( ) ;  . stop ( ) ; return setFound ( true ) ; }<CODESPLIT>Extracts the Path from the shortest - path - tree determined by sptEntry .
public static int writeInt ( byte [ ] target , int offset , int value ) {  [  ] = ( byte ) (  >>> 24 ) ;  [  + 1 ] = ( byte ) (  >>> 16 ) ;  [  + 2 ] = ( byte ) (  >>> 8 ) ;  [  + 3 ] = ( byte )  ; return  . BYTES ; }<CODESPLIT>Writes the given 32 - bit Integer to the given byte array at the given offset .
private void visitGetElem ( Node n ) {  . expectIndexMatch (  , getJSType (  . getFirstChild ( ) ) , getJSType (  . getLastChild ( ) ) ) ; ensureTyped (  ) ; }<CODESPLIT>Visits a GETELEM node .
private static Class < ? > getTypedClass ( java . lang . reflect . Type type ) { if (  instanceof Class ) { return ( ( Class )  ) ; } else if (  instanceof ParameterizedType ) { java . lang . reflect . Type  = ( ( ParameterizedType )  ) . getRawType ( ) ; return getTypedClass (  ) ; } else if (  instanceof TypeVariable ) { java . lang . reflect . Type  = ( ( TypeVariable )  ) . getBounds ( ) [ 0 ] ; return getTypedClass (  ) ; } throw new IllegalArgumentException ( "Error while finding generic class for :" +  ) ; }<CODESPLIT>Gets the typed class .
public URI toUri ( JimfsPath path ) {  . state ( ) . checkOpen ( ) ; return  . toUri (  ,  . toAbsolutePath ( ) ) ; }<CODESPLIT>Gets the URI of the given path in this file system .
public ActivityInterface getActivityInterface ( ) { if (  == null ) {  = new ActivityInterface (  ,  ,  ) ; } return  ; }<CODESPLIT>Get the ActivityInterface .
private void initBeforeList ( ) { final List < ProcessAdvice >  = new ArrayList < > ( ) ; final Method  = getInvokeHolder ( ) ; final Class < ? >  =  . getDeclaringClass ( ) ; if ( null !=  &&  . isAnnotationPresent ( Before . class ) ) { final Class < ? extends ProcessAdvice > [ ]  =  . getAnnotation ( Before . class ) . value ( ) ; for ( int  = 0 ;  <  . length ;  ++ ) { final Class < ? extends ProcessAdvice >  =  [  ] ; final ProcessAdvice  =  . getInstance ( ) . getReference (  ) ;  . add (  ) ; } } if (  . isAnnotationPresent ( Before . class ) ) { final Class < ? extends ProcessAdvice > [ ]  =  . getAnnotation ( Before . class ) . value ( ) ; for ( int  = 0 ;  <  . length ;  ++ ) { final Class < ? extends ProcessAdvice >  =  [  ] ; final ProcessAdvice  =  . getInstance ( ) . getReference (  ) ;  . add (  ) ; } } this . beforeRequestProcessAdvices =  ; }<CODESPLIT>Initializes before process advices .
private void init ( ) {  = new JsonFactory ( ) ;  . configure (  . Feature . ALLOW_COMMENTS , true ) ;  . configure (  . Feature . ALLOW_SINGLE_QUOTES , true ) ;  . configure (  . Feature . ALLOW_NON_NUMERIC_NUMBERS , true ) ; }<CODESPLIT>Creates the JsonFactory .
static void flushStackLocalLeaks ( Looper looper ) { Handler  = new Handler (  ) { public void handleMessage ( Message msg ) { sendMessageDelayed ( obtainMessage ( ) ,  ) ; } } ;  . sendMessageDelayed (  . obtainMessage ( ) ,  ) ; }<CODESPLIT>Prior to Android 5 HandlerThread always keeps a stack local reference to the last message that was sent to it . This method makes sure that stack local reference never stays there for too long by sending new messages to it every second .
public void addReset ( String label ) { if (  == null ) buttonsAtBottom ( ) ; Element  = new Input (  . Reset , "Reset" ,  ) ; if (  ) addField ( null ,  ) ; else  . add (  ) ; }<CODESPLIT>Add a reset button .
public static int getMaximumVolume ( Context context ) { return ( ( AudioManager )  . getSystemService (  . AUDIO_SERVICE ) ) . getStreamMaxVolume (  . STREAM_MUSIC ) ; }<CODESPLIT>Returns maximum volume the media volume can have
@ SuppressWarnings ( "checkstyle:npathcomplexity" ) public void removeSREs ( ISREInstall ... sres ) { final ISREInstall  = getDefaultSRE ( ) ; final String  =  == null ? null :  . getId ( ) ; int  = - 1 ; if (  != null ) { for ( int  = 0 ;  == - 1 &&  < this . sreTable . getItemCount ( ) ; ++  ) { if (  . equals ( ( ( ISREInstall ) this . sreTable . getItem (  ) . getData ( ) ) . getId ( ) ) ) {  =  ; } } } final String  =  . nullToEmpty (  ) ; boolean  = false ; for ( final ISREInstall  :  ) { if ( this . sreArray . remove (  ) &&  . getId ( ) . equals (  ) ) {  = true ; } } refreshSREListUI ( ) ; if (  ) { if ( this . sreTable . getItemCount ( ) == 0 ) { setSelection ( null ) ; } else { if (  < 0 ) {  = 0 ; } else if (  >= this . sreTable . getItemCount ( ) ) {  = this . sreTable . getItemCount ( ) - 1 ; } setSelection ( new StructuredSelection ( this . sreTable . getItem (  ) . getData ( ) ) ) ; } } this . sresList . refresh ( true ) ; if (  ) { fireDefaultSREChanged ( ) ; } updateUI ( ) ; }<CODESPLIT>Removes the given SREs from the table .
public static WikiUser getUser ( String wikiId , String siteurl ) { WikiUser  = null ; try { Properties  = getProperties (  ) ;  = new WikiUser ( ) ;  . setUsername (  . getProperty ( "user" ) ) ;  . setEmail (  . getProperty ( "email" ) ) ; Crypt  = new Crypt (  . getProperty ( "cypher" ) ,  . getProperty ( "salt" ) ) ;  . setPassword (  . decrypt (  . getProperty ( "secret" ) ) ) ; } catch ( FileNotFoundException e ) { String  = help (  ,  ) ;  . log (  . SEVERE ,  ) ; } catch ( IOException e ) {  . log (  . SEVERE ,  . getMessage ( ) ) ; } catch ( GeneralSecurityException e ) {  . log (  . SEVERE ,  . getMessage ( ) ) ; } return  ; }<CODESPLIT>get the Wiki user for the given wikiid
public T next ( ) { int  = 0 ; do { T  =  . next ( ) ; if ( !  . contains (  ) ) {  . add (  ) ; return  ; }  ++ ; } while (  <=  ) ; throw new IllegalStateException ( on ( " " ) . join ( "Exhausted" ,  , "retries trying to generate unique value" ) ) ; }<CODESPLIT>Returns unique &lt ; T&gt ; generated by delegate Generator&lt ; T&gt ;
private boolean isAllowedInsideList ( Node node ) { return (  . getNodeType ( ) !=  . ELEMENT_NODE ||  . getNodeName ( ) . equalsIgnoreCase (  ) ) && (  . getNodeType ( ) !=  . TEXT_NODE ||  . getNodeValue ( ) . trim ( ) . length ( ) == 0 ) ; }<CODESPLIT>Checks if a given node is allowed or not as a child of a &lt ; ul&gt ; or &lt ; ol&gt ; element .
public static ResidueNumber [ ] matchSequenceToStructure ( ProteinSequence seq , Structure struct ) { Map < Integer , Group >  = new HashMap < Integer , Group > ( ) ; ProteinSequence  = getProteinSequenceForStructure (  ,  ) ; SubstitutionMatrix < AminoAcidCompound >  = new SimpleSubstitutionMatrix < AminoAcidCompound > (  . getAminoAcidCompoundSet ( ) , ( short ) 1 , ( short ) - 1 ) ;  = new SimpleSubstitutionMatrix < AminoAcidCompound > (  . getAminoAcidCompoundSet ( ) , new InputStreamReader ( SimpleSubstitutionMatrix . class . getResourceAsStream ( "/matrices/blosum100.txt" ) ) , "blosum100" ) ; SequencePair < ProteinSequence , AminoAcidCompound >  =  . getPairwiseAlignment (  ,  ,  . GLOBAL , new SimpleGapPenalty ( ) ,  ) ; AlignedSequence < ProteinSequence , AminoAcidCompound >  =  . getQuery ( ) ; AlignedSequence < ProteinSequence , AminoAcidCompound >  =  . getTarget ( ) ; assert (  . getLength ( ) ==  . getLength ( ) ) ; ResidueNumber [ ]  = new ResidueNumber [  . getLength ( ) ] ; for ( int  =  . getStart ( ) . getPosition ( ) ;  <=  . getEnd ( ) . getPosition ( ) ;  ++ ) { if (  . isGap (  ) ) { int  =  . getSequenceIndexAt (  ) - 1 ; assert (  > 0 ) ; Group  =  . get (  ) ;  . warn ( "Chain {} residue {} in the Structure {} has no corresponding amino acid in the sequence." ,  . getChainId ( ) ,  . getResidueNumber ( ) . toString ( ) ,  . getChain ( ) . getStructure ( ) . getPDBCode ( ) ) ; continue ; } if ( !  . isGap (  ) ) { int  =  . getSequenceIndexAt (  ) - 1 ; int  =  . getSequenceIndexAt (  ) - 1 ; Group  =  . get (  ) ; assert ( 0 <=  &&  <  . length ) ;  [  ] =  . getResidueNumber ( ) ; } } return  ; }<CODESPLIT>Given a sequence and the corresponding Structure get the ResidueNumber for each residue in the sequence .
@ SuppressWarnings ( { "unchecked" } ) public static IMeta mergeMeta ( IMetaData < ? , ? > metaData1 , IMetaData < ? , ? > metaData2 ) { Map < String , Object >  = ( ( Map < String , Object > )  ) ; Set < Entry < String , Object > >  =  . entrySet ( ) ; Map < String , Object >  = ( ( Map < String , Object > )  ) ; Set < Entry < String , Object > >  =  . entrySet ( ) ; Map < String , Object >  = new HashMap < String , Object > ( ) ; for ( Entry < String , Object >  :  ) { String  =  . getKey ( ) ; if (  . containsKey (  ) ) { Object  =  . get (  ) ; Object  =  . get (  ) ; if (  instanceof Double ) { if (  . valueOf (  . toString ( ) ) . doubleValue ( ) <  . valueOf (  . toString ( ) ) . doubleValue ( ) ) {  . put (  ,  ) ; } } else if (  instanceof Integer ) { if (  . valueOf (  . toString ( ) ) . intValue ( ) <  . valueOf (  . toString ( ) ) . intValue ( ) ) {  . put (  ,  ) ; } } else if (  instanceof Long ) { if (  . valueOf (  . toString ( ) ) . longValue ( ) <  . valueOf (  . toString ( ) ) . longValue ( ) ) {  . put (  ,  ) ; } } if (  instanceof Boolean ) { if ( !  . valueOf (  . toString ( ) ) &&  . valueOf (  . toString ( ) ) ) {  . put (  ,  ) ; } } } }  . removeAll (  . entrySet ( ) ) ;  . addAll (  . entrySet ( ) ) ;  . addAll (  ) ; return  ; }<CODESPLIT>Merges the two Meta objects
public List < T > subList ( int arg0 , int arg1 ) { while (  . size ( ) <  && nextResultsAvailable ( ) ) { moveNextResults ( ) ; } return  . unmodifiableList (  . subList (  ,  ) ) ; }<CODESPLIT>Returns a sub - list in the range specified loading more results as necessary .
private Message prepare ( String channel , Message message , Recipient [ ] recipients ) {  . setMetadata ( "cwf.pub.node" ,  ) ;  . setMetadata ( "cwf.pub.channel" ,  ) ;  . setMetadata ( "cwf.pub.event" ,  . randomUUID ( ) . toString ( ) ) ;  . setMetadata ( "cwf.pub.when" ,  . currentTimeMillis ( ) ) ;  . setMetadata ( "cwf.pub.recipients" ,  ) ; return  ; }<CODESPLIT>Adds publication - specific metadata to the message .
private < T > GraphRequest < T > graph ( String object , JavaType type , Param ... params ) { this . checkForBatchExecution ( ) ; GraphRequest < T >  = new GraphRequest < T > (  ,  , this . mapper , this . < T > createMappingChain (  ) ) ; this . graphRequests . add (  ) ; return  ; }<CODESPLIT>The actual implementation of this after we ve converted to proper Jackson JavaType
public void writeLength ( long length ) { if (  < 251 ) {  [  ++ ] = ( byte )  ; } else if (  < 65536 ) {  [  ++ ] = ( byte ) 0xfc ;  [  ++ ] = ( byte )  ;  [  ++ ] = ( byte ) (  >>> 8 ) ; } else if (  < 16777216 ) {  [  ++ ] = ( byte ) 0xfd ;  [  ++ ] = ( byte )  ;  [  ++ ] = ( byte ) (  >>> 8 ) ;  [  ++ ] = ( byte ) (  >>> 16 ) ; } else {  [  ++ ] = ( byte ) 0xfe ;  [  ++ ] = ( byte )  ;  [  ++ ] = ( byte ) (  >>> 8 ) ;  [  ++ ] = ( byte ) (  >>> 16 ) ;  [  ++ ] = ( byte ) (  >>> 24 ) ;  [  ++ ] = ( byte ) (  >>> 32 ) ;  [  ++ ] = ( byte ) (  >>> 40 ) ;  [  ++ ] = ( byte ) (  >>> 48 ) ;  [  ++ ] = ( byte ) (  >>> 54 ) ; } }<CODESPLIT>Write length .
public static < TSource , TResult > List < TResult > map ( Collection < TSource > items , Mapper < TSource , TResult > mapper ) { if ( isEmpty (  ) ) { return new ArrayList < > ( ) ; } List < TResult >  = new ArrayList < > (  . size ( ) ) ; for ( TSource  :  ) { TResult  =  . map (  ) ;  . add (  ) ; } return  ; }<CODESPLIT>Projects each element of a collection into a new collection .
private static void serializeReal ( final Number real , final ContentHandler handler ) throws SAXException { serializeElement ( "real" ,  . valueOf (  . doubleValue ( ) ) ,  ) ; }<CODESPLIT>Serialize a Number as a real element .
public JMenuBar setupStandardMenu ( ActionListener targetAction , boolean bAddHelpMenu ) { Application  =  . getSharedInstance ( ) . getApplication ( ) ; ResourceBundle  =  . getResourceBundle ( ) ;  . getResources ( null , true ) ; this . setupActions (  ) ; JMenuBar  = new JMenuBar ( ) { private static final long serialVersionUID = 1L ; public Dimension getMaximumSize ( ) { return new Dimension ( super . getMaximumSize ( ) . width , super . getPreferredSize ( ) . height ) ; } } ;  . setOpaque ( false ) ; JMenu  ; char [ ]  = new char [ 20 ] ;  = this . addMenu (  ,  . FILE ) ; this . addMenuItem (  ,  . PRINT ,  ) ;  . addSeparator ( ) ; this . addMenuItem (  ,  . LOGON ,  ) ; this . addMenuItem (  ,  . LOGOUT ,  ) ; this . addMenuItem (  ,  . CHANGE_PASSWORD ,  ) ;  . addSeparator ( ) ; this . addMenuItem (  ,  . CLOSE ,  ) ;  = new char [ 20 ] ;  = this . addMenu (  ,  . EDIT ) ; this . addMenuItem (  ,  . CUT ,  ) ; this . addMenuItem (  ,  . COPY ,  ) ; this . addMenuItem (  ,  . PASTE ,  ) ;  . addSeparator ( ) ; this . addMenuItem (  ,  . PREFERENCES ,  ) ; if (  != null )  . setResourceBundle (  ) ; if (  )  = this . addHelpMenu (  ) ; return  ; }<CODESPLIT>Setup the standard menu items .
public static String getPreferredAttributeNameForLaneCount ( ) { final Preferences  =  . userNodeForPackage ( RoadNetworkConstants . class ) ; if (  != null ) { return  . get ( "LANE_COUNT_ATTR_NAME" ,  ) ; } return  ; }<CODESPLIT>Replies the preferred name for the number of lanes of the roads .
public static nsrollbackcmd [ ] get ( nitro_service service , nsrollbackcmd_args args ) throws Exception { nsrollbackcmd  = new nsrollbackcmd ( ) ; options  = new options ( ) ;  . set_args (  . object_to_string_withoutquotes (  ) ) ; nsrollbackcmd [ ]  = ( nsrollbackcmd [ ] )  . get_resources (  ,  ) ; return  ; }<CODESPLIT>Use this API to fetch all the nsrollbackcmd resources that are configured on netscaler . This uses nsrollbackcmd_args which is a way to provide additional arguments while fetching the resources .
private int translateElementNo ( int i ) { if ( !  ||  < 0 ) { return  ; } int  = 0 ; PatternRule  = ( PatternRule ) this . rule ; for ( int  = 0 ;  <  ;  ++ ) {  +=  . getElementNo ( ) . get (  ) ; } return  ; }<CODESPLIT>Gets the index of the element indexed by i adding any offsets because of the phrases in the rule .
public String [ ] getProxyHostsWhiteList ( ) { if (  == null ||  . size ( ) == 0 ) return new String [ 0 ] ; String [ ]  = new String [  . size ( ) ] ;  = ( String [ ] )  . toArray (  ) ; return  ; }<CODESPLIT>Get proxy host white list .
public boolean addMetatypeAd ( MetatypeAd metatypeAd ) { if ( this . metatypeAds == null ) this . metatypeAds = new LinkedList < MetatypeAd > ( ) ; for ( MetatypeAd  :  ) if (  . getID ( ) . equals (  . getID ( ) ) ) return false ; this . metatypeAds . add (  ) ; return true ; }<CODESPLIT>Adds a metatype AD .
public long skip ( long n ) throws IOException { if (  . available ( ) >=  ) { return  . skip (  ) ; }  . close ( ) ;  +=  ; try {  =  . getObject (  ,  , null , null , null , null ,  , null ) ;  = new BufferedInputStream (  . getDataInputStream ( ) ) ; } catch ( ServiceException e ) { throw new IOException (  ) ; } return  ; }<CODESPLIT>This method leverages the ability to open a stream from GCS from a given offset . When the underlying stream has fewer bytes buffered than the skip request the stream is closed and a new stream is opened starting at the requested offset .
public static boolean isSuperCall ( JCTree tree ) { Name  = calledMethodName (  ) ; if (  != null ) { Names  =  . table . names ; return  ==  . _super ; } else { return false ; } }<CODESPLIT>Is this a call to super?
public static String getShortRequestDump ( String fromMethod , boolean includeHeaders , HttpServletRequest request ) { StringBuilder  = new StringBuilder ( ) ;  . append ( "Timestamp : " ) . append (  . getTimestamp ( ) ) . append ( "\n" ) ;  . append ( "fromMethod : " ) . append (  ) . append ( "\n" ) ;  . append ( "Method : " ) . append (  . getMethod ( ) ) . append ( '\n' ) ;  . append ( "Scheme : " ) . append (  . getScheme ( ) ) . append ( '\n' ) ;  . append ( "URI : " ) . append (  . getRequestURI ( ) ) . append ( '\n' ) ;  . append ( "Query-String : " ) . append (  . getQueryString ( ) ) . append ( '\n' ) ;  . append ( "Auth-Type : " ) . append (  . getAuthType ( ) ) . append ( '\n' ) ;  . append ( "Remote-Addr : " ) . append (  . getRemoteAddr ( ) ) . append ( '\n' ) ;  . append ( "Scheme : " ) . append (  . getScheme ( ) ) . append ( '\n' ) ;  . append ( "Content-Type : " ) . append (  . getContentType ( ) ) . append ( '\n' ) ;  . append ( "Content-Length: " ) . append (  . getContentLength ( ) ) . append ( '\n' ) ; if (  ) {  . append ( "Headers :\n" ) ; Enumeration < String >  =  . getHeaderNames ( ) ; while (  . hasMoreElements ( ) ) { String  =  . nextElement ( ) ;  . append ( "\t" ) . append (  ) . append ( ": " ) . append (  . getHeader (  ) ) . append ( '\n' ) ; } } return (  . toString ( ) ) ; }<CODESPLIT>Build a String containing a short multi - line dump of an HTTP request .
public static void validateNotEmpty ( String stringToCheck , boolean trim , String argumentName ) throws NullArgumentException { validateNotNull (  ,  ) ; if (  . length ( ) == 0 || (  &&  . trim ( ) . length ( ) == 0 ) ) { throw new NullArgumentException (  +  ) ; } }<CODESPLIT>Validates that the string is not null and not an empty string .
public static JPanel createPanelWithVerticalLayout ( ) { JPanel  = new JPanel ( ) ;  . setLayout ( new BoxLayout (  ,  . Y_AXIS ) ) ; return  ; }<CODESPLIT>Create a panel that lays out components vertically .
protected boolean shouldAnalyze ( ) { if (  instanceof FileTypeAnalyzer ) { final FileTypeAnalyzer  = ( FileTypeAnalyzer )  ; return  . accept (  . getActualFile ( ) ) ; } return true ; }<CODESPLIT>Determines if the analyzer can analyze the given dependency .
public void registerServiceClass ( Class serviceClass ) {  . put (  . getSimpleName ( ) ,  ) ;  . Services . addAvailableOption (  . getSimpleName ( ) ) ; }<CODESPLIT>Registers a service enabling the service layer to automatically start autorun servies .
public String getSectionText ( String pageTitle , int sectionNumber ) throws Exception { String  = this . getPageContent (  , "&rvsection=" +  , false ) ; return  ; }<CODESPLIT>get the text for the given section
public static double pearson ( int [ ] x , int [ ] y ) { if (  . length !=  . length ) throw new IllegalArgumentException (  . format ( "Arrays have different length: x[%d], y[%d]" ,  . length ,  . length ) ) ; return 1 -  . cor (  ,  ) ; }<CODESPLIT>Pearson correlation distance between the two arrays of type int .
public static TileGrid getTileGridFromWGS84 ( Point point , int zoom ) { Projection  =  . getProjection (  . EPSG_WORLD_GEODETIC_SYSTEM ) ; return getTileGrid (  ,  ,  ) ; }<CODESPLIT>Get the tile grid for the location specified as WGS84
public List < VectorLayer > getVectorLayers ( ) { ArrayList < VectorLayer >  = new ArrayList < VectorLayer > ( ) ; for ( Layer < ? >  :  ) { if (  instanceof VectorLayer ) {  . add ( ( VectorLayer )  ) ; } } return  ; }<CODESPLIT>Return a list containing all vector layers within this model .
private void calcRmsd ( Point3d [ ] x , Point3d [ ] y ) { if (  ) { innerProduct (  ,  ) ; } else {  =  . clonePoint3dArray (  ) ;  =  . centroid (  ) ;  . debug ( "x centroid: " +  ) ;  . negate ( ) ;  . translate ( new Vector3d (  ) ,  ) ;  =  . clonePoint3dArray (  ) ;  =  . centroid (  ) ;  . debug ( "y centroid: " +  ) ;  . negate ( ) ;  . translate ( new Vector3d (  ) ,  ) ; innerProduct (  ,  ) ; } calcRmsd (  ) ; }<CODESPLIT>Calculates the RMSD value for superposition of y onto x . This requires the coordinates to be precentered .
public void setSectionHeading ( Title v ) { if (  . featOkTst && ( ( Section_Type )  ) . casFeat_sectionHeading == null )  . jcas . throwFeatMissing ( "sectionHeading" , "de.julielab.jules.types.Section" ) ;  . ll_cas . ll_setRefValue (  , ( ( Section_Type )  ) . casFeatCode_sectionHeading ,  . ll_cas . ll_getFSRef (  ) ) ; }<CODESPLIT>setter for sectionHeading - sets the title of the section
public Response process ( InputStream is ) throws IOException , SAXException , ParserConfigurationException { SxmpParser  = new SxmpParser (  ) ; Operation  = null ; try {  =  . parse (  ) ; } catch ( SxmpParsingException e ) { if (  . getOperation ( ) != null &&  . getOperation ( ) . getType ( ) != null ) {  . warn ( "Unable to fully parse XML into a request, returning ErrorResponse; error: " +  . getMessage ( ) + ", parsed: " +  . getOperation ( ) ) ; return new ErrorResponse (  . getOperation ( ) . getType ( ) ,  . getErrorCode ( ) . getIntValue ( ) ,  . getErrorMessage ( ) ) ; } else { throw new SAXException (  . getMessage ( ) ,  ) ; } } try { if ( ! (  instanceof Request ) ) { throw new SxmpErrorException (  . UNSUPPORTED_OPERATION , "A session can only process requests" ) ; } Request  = ( Request )  ; if (  . getAccount ( ) == null ) { throw new SxmpErrorException (  . MISSING_REQUIRED_ELEMENT , "A request must include account credentials" ) ; } if ( !  . authenticate (  . getAccount ( ) ) ) { throw new SxmpErrorException (  . AUTHENTICATION_FAILURE , "Authentication failure" ) ; } if (  instanceof SubmitRequest ) { return  . submit (  . getAccount ( ) , ( SubmitRequest )  ) ; } else if (  instanceof DeliverRequest ) { return  . deliver (  . getAccount ( ) , ( DeliverRequest )  ) ; } else if (  instanceof DeliveryReportRequest ) { return  . deliveryReport (  . getAccount ( ) , ( DeliveryReportRequest )  ) ; } else { throw new SxmpErrorException (  . UNSUPPORTED_OPERATION , "Unsupported operation request type" ) ; } } catch ( SxmpErrorException e ) {  . warn (  . getMessage ( ) ) ; return new ErrorResponse (  . getType ( ) ,  . getErrorCode ( ) . getIntValue ( ) ,  . getErrorMessage ( ) ) ; } catch ( Throwable t ) {  . error ( "Major uncaught throwable while processing request, generating an ErrorResponse" ,  ) ; return new ErrorResponse (  . getType ( ) ,  . GENERIC . getIntValue ( ) , "Generic error while processing request" ) ; } }<CODESPLIT>Processes an InputStream that contains a request . Does its best to only produce a Response that can be written to an OutputStream . Any exception this method throws should be treated as fatal and no attempt should be made to print out valid XML as a response .
private void submitPayload ( String url , HttpRequestUtil . ConnectionSettings connectionSettings , String jsonPayloadObject , String pushApplicationId , String masterSecret , MessageResponseCallback callback , List < String > redirectUrls ) { if (  . contains (  ) ) { throw new PushSenderException ( "The site contains an infinite redirect loop! Duplicate url: " +  ) ; } else {  . add (  ) ; } HttpURLConnection  = null ; try { final String  =  + ':' +  ; final String  =  . encodeBytes (  . getBytes (  ) ) ;  = ( HttpURLConnection )  . post (  ,  ,  ,  ,  ,  ,  ) ; final int  =  . getResponseCode ( ) ;  . log (  . INFO ,  . format ( "HTTP Response code from UnifiedPush Server: %s" ,  ) ) ; if ( isRedirect (  ) ) { String  =  . getHeaderField ( "Location" ) ;  . log (  . INFO ,  . format ( "Performing redirect to '%s'" ,  ) ) ; submitPayload (  ,  . getConnectionSettings ( ) ,  ,  ,  ,  ,  ) ; } else if (  >= 400 ) {  . log (  . SEVERE , "The Unified Push Server returned status code: " +  ) ; throw new PushSenderHttpException (  ) ; } else { if (  != null ) {  . onComplete ( ) ; } } } catch ( PushSenderHttpException pshe ) { throw  ; } catch ( Exception e ) {  . log (  . INFO , "Error happening while trying to send the push delivery request" ,  ) ; throw new PushSenderException (  . getMessage ( ) ,  ) ; } finally { if (  != null ) {  . disconnect ( ) ; } } }<CODESPLIT>The actual method that does the real send and connection handling
public String [ ] getChildNames ( ) { if (  == null ||  . size ( ) == 0 ) return  ; String [ ]  = new String [  . size ( ) ] ; for ( int  = 0 ;  <  . length ;  ++ ) {  [  ] = ( ( RamResourceCore )  . get (  ) ) . getName ( ) ; } return  ; }<CODESPLIT>Gibt den Feldnamen children zurueck .
public static Object getIndex ( Object array , int index ) throws UtilTargetError {  . debug ( "getIndex: " ,  , ", index=" ,  ) ; try { if (  instanceof List ) return ( ( List < ? > )  ) . get (  ) ; Object  =  . get (  ,  ) ; return  . wrap (  ,  . arrayElementType (  . getClass ( ) ) ) ; } catch ( IndexOutOfBoundsException e1 ) { int  =  instanceof List ? ( ( List < ? > )  ) . size ( ) :  . getLength (  ) ; throw new UtilTargetError ( "Index " +  + " out-of-bounds for length " +  ,  ) ; } }<CODESPLIT>Get object from array or list at index .
public static base_response add ( nitro_service client , aaakcdaccount resource ) throws Exception { aaakcdaccount  = new aaakcdaccount ( ) ;  . kcdaccount =  . kcdaccount ;  . keytab =  . keytab ;  . realmstr =  . realmstr ;  . delegateduser =  . delegateduser ;  . kcdpassword =  . kcdpassword ;  . usercert =  . usercert ;  . cacert =  . cacert ; return  . add_resource (  ) ; }<CODESPLIT>Use this API to add aaakcdaccount .
public synchronized void lockExclusive ( ) { if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . entry ( this ,  , "lockExclusive" , this ) ; boolean  = false ; while ( ! tryLockExclusive ( ) ) { try { if (  . isAnyTracingEnabled ( ) &&  . isDebugEnabled ( ) )  . debug ( this ,  , "Waiting to get exclusive lock" ) ; wait ( 1000 ) ; } catch ( InterruptedException e ) {  = true ; } } while (  > 0 ) { try { if (  . isAnyTracingEnabled ( ) &&  . isDebugEnabled ( ) )  . debug ( this ,  , "Waiting for lock count to reach 0 " +  ) ; wait ( 1000 ) ; } catch ( InterruptedException e ) {  = true ; } } if (  ) {  . currentThread ( ) . interrupt ( ) ; } if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . exit ( this ,  , "lockExclusive" ) ; }<CODESPLIT>This method locks the mutex so no other lockers can get the lock .
public void setCPOptionValueLocalService ( com . liferay . commerce . product . service . CPOptionValueLocalService cpOptionValueLocalService ) { this . cpOptionValueLocalService =  ; }<CODESPLIT>Sets the cp option value local service .
public static String inferModulePathFromType ( TypeDeclaration type ) { PackageDeclaration  =  . getPackage ( ) ; return  != null ? '/' +  . getQualifiedName ( ) . replace ( '.' , '/' ) : "/" ; }<CODESPLIT>Infers the Struts module path from the given controller class .
final int getLeapMonth ( int cycle , int yearOfCycle ) { int [ ]  = this . getLeapMonths ( ) ; int  = (  - 1 ) * 60 +  - 1 ; int  = 2 * ( (  -  [ 0 ] ) / 3 ) ; int  = 0 ; while ( (  <  . length ) ) { int  =  [  ] ; if (  <  ) {  +=  . max ( 2 * ( (  -  ) / 3 ) , 2 ) ; } else if (  >  ) { break ; } else {  =  [  + 1 ] ; break ; } } return  ; }<CODESPLIT>number of leap month or zero if no leap year
public Snippet getSnippet ( Integer snippetId , boolean downloadContent ) throws GitLabApiException { if (  == null ) { throw new RuntimeException ( "snippetId can't be null" ) ; } Response  = get (  . Status . OK , null , "snippets" ,  ) ; Snippet  =  . readEntity ( Snippet . class ) ; if (  ) {  . setContent ( getSnippetContent (  . getId ( ) ) ) ; } return  ; }<CODESPLIT>Get a specific Snippet .
public final int get ( int codePoint ) { int  ; int  ; if (  >= 0 ) { if (  < 0x0d800 || (  > 0x0dbff &&  <= 0x0ffff ) ) {  =  [  >>  ] ;  = (  <<  ) + (  &  ) ;  =  [  ] ; return  ; } if (  <= 0xffff ) {  =  [  + ( (  - 0xd800 ) >>  ) ] ;  = (  <<  ) + (  &  ) ;  =  [  ] ; return  ; } if (  <  ) {  = (  -  ) + (  >>  ) ;  =  [  ] ;  += (  >>  ) &  ;  =  [  ] ;  = (  <<  ) + (  &  ) ;  =  [  ] ; return  ; } if (  <= 0x10ffff ) {  =  [  ] ; return  ; } } return  ; }<CODESPLIT>Get the value for a code point as stored in the Trie2 .
public static Object getMBeanAttributeObject ( String name , String attrName ) throws JMException { MBeanServer  = getMBeanServer ( ) ; ObjectName  = new ObjectName (  ) ; return  . getAttribute (  ,  ) ; }<CODESPLIT>Get MBean attribute object
public synchronized void setSelectedIndex ( final int selectedIndex ) { if (  . size ( ) <=  ||  < - 1 ) { throw new IndexOutOfBoundsException ( "Illegal argument to ComboBox.setSelectedIndex: " +  ) ; } final int  = this . selectedIndex ; this . selectedIndex =  ; if (  == - 1 ) { updateText ( "" ) ; } else { updateText (  . get (  ) . toString ( ) ) ; } runOnGUIThreadIfExistsOtherwiseRunDirect ( new Runnable ( ) { public void run ( ) { for ( Listener  :  ) {  . onSelectionChanged (  ,  ) ; } } } ) ; invalidate ( ) ; }<CODESPLIT>Programmatically selects one item in the combo box which causes the displayed text to change to match the label of the selected index .
public Stats getPhotoStats ( String photoId , Date date ) throws FlickrException { return getStats (  , "photo_id" ,  ,  ) ; }<CODESPLIT>Get the number of views comments and favorites on a photo for a given date .
public ServiceCall < DocumentStatus > getDocumentStatus ( GetDocumentStatusOptions getDocumentStatusOptions ) {  . notNull (  , "getDocumentStatusOptions cannot be null" ) ; String [ ]  = { "v1/environments" , "collections" , "documents" } ; String [ ]  = {  . environmentId ( ) ,  . collectionId ( ) ,  . documentId ( ) } ; RequestBuilder  =  . get (  . constructHttpUrl ( getEndPoint ( ) ,  ,  ) ) ;  . query ( "version" ,  ) ; Map < String , String >  =  . getSdkHeaders ( "discovery" , "v1" , "getDocumentStatus" ) ; for ( Entry < String , String >  :  . entrySet ( ) ) {  . header (  . getKey ( ) ,  . getValue ( ) ) ; }  . header ( "Accept" , "application/json" ) ; return createServiceCall (  . build ( ) ,  . getObject ( DocumentStatus . class ) ) ; }<CODESPLIT>Get document details .
public Pager < Issue > getClosesIssues ( Object projectIdOrPath , Integer mergeRequestIid , int itemsPerPage ) throws GitLabApiException { return new Pager < Issue > ( this , Issue . class ,  , null , "projects" , getProjectIdOrPath (  ) , "merge_requests" ,  , "closes_issues" ) ; }<CODESPLIT>Get a Pager containing all the issues that would be closed by merging the provided merge request .
public static final void loge ( Class < ? > clazz , String msg , Exception ... e ) { if (  ) { String  = "" ; if (  != null &&  . length == 1 ) { StringWriter  = new StringWriter ( ) ; PrintWriter  = new PrintWriter (  ) ;  [ 0 ] . printStackTrace (  ) ;  . flush ( ) ;  = "exception = " +  . toString ( ) ; }  . err . println ( "[" +  . format ( new Date ( ) ) + "]" + "-" + "[" +  . getSimpleName ( ) + "] " +  + " " +  ) ; } }<CODESPLIT>To output the error log message to the error out
public static HtmlTree TH ( HtmlStyle styleClass , String scope , Content body ) { HtmlTree  = new HtmlTree (  . TH , nullCheck (  ) ) ; if (  != null )  . addStyle (  ) ;  . addAttr (  . SCOPE , nullCheck (  ) ) ; return  ; }<CODESPLIT>Generates a TH tag with style class and scope attributes and some content .
private void obtainDividerMargin ( final int themeResourceId ) { TypedArray  = getContext ( ) . getTheme ( ) . obtainStyledAttributes (  , new int [ ] {  . attr . materialDialogDividerMargin } ) ; setDividerMargin (  . getDimensionPixelSize ( 0 , 0 ) ) ; }<CODESPLIT>Obtains the left and right margin of dividers from a specific theme .
public void setDefaultButton ( SBaseButton button ) { this . getScreenFieldView ( ) . setDefaultButton (  == null ? null :  . getScreenFieldView ( ) ) ; }<CODESPLIT>Set the default button for this basepanel .
public Key select ( int k ) { if (  < 0 ||  >= size (  ) ) throw new IllegalArgumentException ( ) ; RedBlackTreeNode < Key , Value >  = select (  ,  ) ; return  . getKey ( ) ; }<CODESPLIT>Return the kth smallest key in the symbol table .
public void add ( RequestHandler request ) {  . writeLock ( ) . lock ( ) ; try {  . add (  ) ; } finally {  . writeLock ( ) . unlock ( ) ; } }<CODESPLIT>Adds a request handler to this queue .
public static < T > T withPrintWriter ( OutputStream stream , @ ClosureParams ( value = SimpleType . class , options = "java.io.PrintWriter" ) Closure < T > closure ) throws IOException { return withWriter ( newPrintWriter (  ) ,  ) ; }<CODESPLIT>Create a new PrintWriter for this OutputStream . The writer is passed to the closure and will be closed before this method returns .
public void addRegexRoute ( String urlPattern , Class < ? extends Actor > actorClass ) throws RouteAlreadyMappedException { addRoute ( new Route (  , true ) ,  ) ; }<CODESPLIT>Add a URL pattern to the routing table .
public synchronized void sendQueuedEvents ( KeenProject project , KeenCallback callback ) { if ( !  ) { handleLibraryInactive (  ) ; return ; } if (  == null &&  == null ) { handleFailure ( null , new IllegalStateException ( "No project specified, but no default project found" ) ) ; return ; } if ( ! isNetworkConnected ( ) ) {  . log ( "Not sending events because there is no network connection. " + "Events will be retried next time `sendQueuedEvents` is called." ) ; handleFailure (  , new Exception ( "Network not connected." ) ) ; return ; } KeenProject  = (  == null ?  :  ) ; try { String  =  . getProjectId ( ) ; Map < String , List < Object > >  =  . getHandles (  ) ; Map < String , List < Map < String , Object > > >  = buildEventMap (  ,  ) ; String  = publishAll (  ,  ) ; if (  != null ) { try { handleAddEventsResponse (  ,  ) ; } catch ( Exception e ) {  . log ( "Error handling response to batch publish: " +  . getMessage ( ) ) ; } } handleSuccess (  ) ; } catch ( Exception e ) { handleFailure (  ,  ) ; } }<CODESPLIT>Synchronously sends all queued events for the given project . This method will immediately publish the events to the Keen server in the current thread .
public int getMaxQueuedConnections ( ) { return getThreadPool ( ) == null ? - 1 : ( ( getThreadPool ( ) . getQueue ( ) instanceof ArrayBlockingQueue ) ? ( ( ArrayBlockingQueue ) getThreadPool ( ) . getQueue ( ) ) . size ( ) + ( ( ArrayBlockingQueue ) getThreadPool ( ) . getQueue ( ) ) . remainingCapacity ( ) : - 1 ) ; }<CODESPLIT>this should only be used as an estimate
final public AuxiliaryTree TreeRoot ( boolean requiresFoot ) throws ParseException { SimpleNode  = new SimpleNode (  ) ; boolean  = true ;  . openNodeScope (  ) ; Tree  ; try {  = TreeNode ( ) ;  . closeNodeScope (  , true ) ;  = false ; { if ( true ) return new AuxiliaryTree (  ,  ) ; } } catch ( Throwable jjte000 ) { if (  ) {  . clearNodeScope (  ) ;  = false ; } else {  . popNode ( ) ; } if (  instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException )  ; } } if (  instanceof ParseException ) { { if ( true ) throw ( ParseException )  ; } } { if ( true ) throw ( Error )  ; } } finally { if (  ) {  . closeNodeScope (  , true ) ; } } throw new Error ( "Missing return statement in function" ) ; }<CODESPLIT>the argument says whether there must be a foot node on the aux tree .
INodeDirectory addToParent ( byte [ ] src , INodeDirectory parentINode , INode newNode , boolean propagateModTime , int childIndex ) { INodeDirectory  = null ; writeLock ( ) ; try { try {  =  . addToParent (  ,  ,  , false ,  ,  ) ; cacheName (  ) ; } catch ( FileNotFoundException e ) { return null ; } if (  == null ) return null ; if ( !  . isDirectory ( ) ) { INodeFile  = ( INodeFile )  ; BlockInfo [ ]  =  . getBlocks ( ) ; for ( int  = 0 ;  <  . length ;  ++ ) {  . setBlock (  , getFSNamesystem ( ) . blocksMap . addINodeForLoading (  [  ] ,  ) ) ; } } } finally { writeUnlock ( ) ; } return  ; }<CODESPLIT>Add node to parent node when loading the image .
public void setModel ( final MindMap model , final boolean notifyModelChangeListeners ) { this . lock ( ) ; try { if ( this . elementUnderEdit != null ) {  . safeSwingBlockingCall ( new Runnable ( ) { public void run ( ) { endEdit ( false ) ; } } ) ; } final List < int [ ] >  = new ArrayList < int [ ] > ( ) ; for ( final Topic  : this . selectedTopics ) {  . add (  . getPositionPath ( ) ) ; } this . selectedTopics . clear ( ) ; final MindMap  = this . model ; this . model = assertNotNull ( "Model must not be null" ,  ) ; for ( final PanelAwarePlugin  :  . getInstance ( ) . findFor ( PanelAwarePlugin . class ) ) {  . onPanelModelChange ( this ,  , this . model ) ; } doLayout ( ) ; revalidate ( ) ; boolean  = false ; for ( final int [ ]  :  ) { final Topic  = this . model . findForPositionPath (  ) ; if (  == null ) {  = true ; } else if ( !  . isHidden (  ) ) { this . selectedTopics . add (  ) ; } } if (  ) { fireNotificationSelectionChanged ( ) ; } repaint ( ) ; } finally { this . unlock ( ) ; if (  ) { fireNotificationMindMapChanged ( true ) ; } } }<CODESPLIT>Set model for the panel allows to notify listeners optionally .
public OperationFuture < LoadBalancer > delete ( LoadBalancer loadBalancer ) { LoadBalancerMetadata  = findByRef (  ) ;  . delete (  . getDataCenterId ( ) ,  . getId ( ) ) ; return new OperationFuture < > (  , new NoWaitingJobFuture ( ) ) ; }<CODESPLIT>Delete load balancer
public GetSnapshotResponse getSnapshot ( GetSnapshotRequest request ) { checkNotNull (  , "request should not be null." ) ; checkStringNotEmpty (  . getSnapshotId ( ) , "request snapshotId should no be empty." ) ; InternalRequest  = this . createRequest (  ,  . GET ,  ,  . getSnapshotId ( ) ) ; return invokeHttpClient (  , GetSnapshotResponse . class ) ; }<CODESPLIT>Getting the detail information of specified snapshot .
@ SuppressWarnings ( "checkstyle:emptycatchblock" ) void excludeLoggers ( ) { try {  . addExcludedLoggerPattern ( "org.apache.catalina.core.ContainerBase." + "\\[Tomcat.*\\][.]\\[.*\\][.]\\[/.*\\][.]\\[.*\\]" ) ;  . addExcludedLoggerPattern ( "org.eclipse.jetty.server.HttpChannel" ) ;  . addExcludedLoggerPattern ( "io.undertow.request" ) ; } catch ( NoClassDefFoundError ignored ) { } }<CODESPLIT>If using Logback stop any configured appender from creating Bugsnag reports for Spring log messages as they effectively duplicate error reports for unhandled exceptions .
public void subtract ( R1 relationships ) { if ( null ==  ) { throw new AssertionError ( "" ) ; } for ( int  = 0 ;  <  . length ;  ++ ) { if ( null ==  [  ] ) { continue ; } final IConceptSet  =  [  ] = new SparseConceptHashSet ( ) ;  . addAll (  [  ] ) ; if ( null !=  . data [  ] ) {  . removeAll (  . data [  ] ) ; } } }<CODESPLIT>This should only ever be called when the relationships wrap an initial state and no other methods have been called .
private static < E > E getEndpoint ( Class < E > type , String name , Reflections reflections ) { E  = null ; Set < Class < ? extends E > >  =  . getSubTypesOf (  ) ; Set < Class < ? extends E > >  = new HashSet < > ( ) ; for ( Class < ? extends E >  :  ) { if ( !  . isAbstract (  . getModifiers ( ) ) ) {  . add (  ) ; } } Iterator < Class < ? extends E > >  =  . iterator ( ) ; while (  . hasNext ( ) ) { Class < ? extends E >  =  . next ( ) ; if (  . startsWithIgnoreCase (  . getName ( ) , "com.github.davidcarboni.restolino.routes." ) ) {  . remove ( ) ; } } if (  . size ( ) != 0 ) { if (  . size ( ) > 1 ) {  . info ( "Warning: found multiple candidates for {} endpoint: {}" ,  ,  ) ; } try {  =  . iterator ( ) . next ( ) . newInstance ( ) ; } catch ( Exception e ) {  . info ( "Error: cannot instantiate {} endpoint class {}" ,  ,  . iterator ( ) . next ( ) ) ;  . printStackTrace ( ) ; } } return  ; }<CODESPLIT>Locates a single endpoint class .
public final void writtenStartedFlush ( AOStream stream , Item startedFlushItem ) { if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . entry (  , "writtenStartedFlush" ) ; String  =  . getRemoteGetKey (  . getRemoteMEUuid ( ) ,  . getGatheringTargetDestUuid ( ) ) ; StreamInfo  =  . get (  ) ; if ( (  != null ) &&  . streamId . equals (  . streamId ) ) { synchronized (  ) {  . item = ( AOStartedFlushItem )  ; } } else { SIErrorException  = new SIErrorException (  . getFormattedMessage ( "INTERNAL_MESSAGING_ERROR_CWSIP0001" , new Object [ ] { "com.ibm.ws.sib.processor.impl.AnycastOutputHandler" , "1:2858:1.89.4.1" } , null ) ) ;  . processException (  , "com.ibm.ws.sib.processor.impl.AnycastOutputHandler.writtenStartedFlush" , "1:2865:1.89.4.1" , this ) ;  . exception (  ,  ) ;  . error (  , "INTERNAL_MESSAGING_ERROR_CWSIP0001" , new Object [ ] { "com.ibm.ws.sib.processor.impl.AnycastOutputHandler" , "1:2872:1.89.4.1" } ) ; if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . exit (  , "writtenStartedFlush" ,  ) ; throw  ; } if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . exit (  , "writtenStartedFlush" ) ; }<CODESPLIT>Callback when the Item that records that flush has been started has been committed to persistent storage
public static List < Report > getDetailSubreports ( ReportLayout reportLayout ) { List < Report >  = new ArrayList < Report > ( ) ; Band  =  . getDetailBand ( ) ; for ( int  = 0 ,  =  . getRowCount ( ) ;  <  ;  ++ ) { List < BandElement >  =  . getRow (  ) ; for ( int  = 0 ,  =  . size ( ) ;  <  ;  ++ ) { BandElement  =  . get (  ) ; if (  instanceof ReportBandElement ) {  . add ( ( ( ReportBandElement )  ) . getReport ( ) ) ; } } } return  ; }<CODESPLIT>Get detail band subreports for a report layout
public ApiAppList getApiApps ( ) throws HelloSignException { return new ApiAppList (  . withAuth (  ) . get (  +  ) . asJson ( ) ) ; }<CODESPLIT>Retrieves a paged list of API apps for the authenticated account .
public void detachAgent ( Object pVm ) { try { if (  != null ) { Class  =  . getClass ( ) ; Method  =  . getMethod ( "detach" ) ;  . setAccessible ( true ) ;  . invoke (  ) ; } } catch ( InvocationTargetException e ) { throw new ProcessingException ( "Error while detaching" ,  ,  ) ; } catch ( NoSuchMethodException e ) { throw new ProcessingException ( "Error while detaching" ,  ,  ) ; } catch ( IllegalAccessException e ) { throw new ProcessingException ( "Error while detaching" ,  ,  ) ; } }<CODESPLIT>Detach from the virtual machine
public ObjectGraph excludeClasses ( Class < ? > ... classes ) { for ( Class < ? >  :  ) { if (  == null ) { throw new NullPointerException ( "Null class not allowed" ) ; }  . add (  ) ; } return this ; }<CODESPLIT>Exclude any object that extends from these classes .
public void setSampling ( double min , double max , int total ) { this . sampleMin =  ; this . sampleMax =  ; this . numSamples =  ; this . scores = new double [  ] ; }<CODESPLIT>Specifies how focal lengths are sampled on a log scale . Remember 1 . 0 = nominal length
private void calcProductAtVar ( int v , VarTensor prod , int excl1 , int excl2 ) { for ( int  = 0 ;  <  . numNbsT1 (  ) ;  ++ ) { if (  ==  ||  ==  ) { continue ; } VarTensor  =  [  . opposingT1 (  ,  ) ] ;  . elemMultiply (  ) ; } }<CODESPLIT>Computes the product of all messages being sent to a node optionally excluding messages sent from another node or two .
protected ItemState findLastItemState ( QPath itemPath ) { for ( int  =  . size ( ) - 1 ;  >= 0 ;  -- ) { ItemState  =  . get (  ) ; if (  . getData ( ) . getQPath ( ) . equals (  ) ) return  ; } return null ; }<CODESPLIT>Find last ItemState .
public void addDispatcher ( String dispatcherId , AbsActorDispatcher dispatcher ) { synchronized (  ) { if (  . containsKey (  ) ) { return ; }  . put (  ,  ) ; } }<CODESPLIT>Registering custom dispatcher
private void sgdTrain ( ClassificationDataSet D , MatrixOfVecs W , Vec b , int sign_mul , boolean parallel ) { IntList  = new IntList (  . size ( ) ) ;  . addRange (  , 0 ,  . size ( ) , 1 ) ; final double  =  / (  . size ( ) *  ) ; int [ ]  = new int [  ] ; int  = 0 ; int [ ]  = new int [  . size ( ) ] ;  . fill (  , - 1 ) ; Vec  = new DenseVector (  . rows ( ) ) ; long  = 0 ; for ( int  = 0 ;  <  ;  ++ ) {  . shuffle (  ) ; for ( int  :  ) {  ++ ; double  = 1 / (  *  ) ; Vec  =  . getDataPoint (  ) . getNumericalValues ( ) ; int  = (  . getDataPointCategory (  ) * 2 - 1 ) *  ;  . copyTo (  ) ;  . multiply (  , 1.0 ,  ) ; if (  == - 1 ) { for ( int  = 0 ;  <  ;  ++ ) if (  . get (  ) > - 1 ) {  . getRowView (  ) . mutableSubtract (  ,  ) ;  . increment (  , -  ) ; } } else { int  = 0 ; for ( int  = 1 ;  <  . length ( ) ;  ++ ) if (  . get (  ) >  . get (  ) )  =  ; if (  . get (  ) < 1 ) { int  = ASSIGN (  ,  ,  ,  ,  ,  ) ;  . getRowView (  ) . mutableAdd (  ,  ) ;  . increment (  ,  ) ; if (  [  ] < 0 )  ++ ; else  [  [  ] ] -- ;  [  ] ++ ;  [  ] =  ; } }  . mutableMultiply ( 1 - 1.0 /  ) ;  . mutableMultiply ( 1 - 1.0 /  ) ; } } }<CODESPLIT>Training procedure that can be applied to each version of the CPM sub - problem .
public static appfwfieldtype [ ] get ( nitro_service service ) throws Exception { appfwfieldtype  = new appfwfieldtype ( ) ; appfwfieldtype [ ]  = ( appfwfieldtype [ ] )  . get_resources (  ) ; return  ; }<CODESPLIT>Use this API to fetch all the appfwfieldtype resources that are configured on netscaler .
public Future < Channel > create ( final Promise < Channel > channelReadyPromise ) { final long  = this . currentDelaySeconds . get ( ) ;  . addListener ( new GenericFutureListener < Future < Channel > > ( ) { public void operationComplete ( final Future < Channel > future ) { final long  =  . isSuccess ( ) ? 0 :  . max (  . min (  * 2 ,  ) ,  ) ;  . this . currentDelaySeconds . compareAndSet (  ,  ) ; } } ) ; this . bootstrapTemplate . config ( ) . group ( ) . schedule ( new Runnable ( ) { public void run ( ) { final Bootstrap  =  . this . bootstrapTemplate . clone ( ) . channelFactory ( new AugmentingReflectiveChannelFactory < > (  . getSocketChannelClass (  . this . bootstrapTemplate . config ( ) . group ( ) ) ,  ,  ) ) ; final ChannelFuture  =  . connect ( ) ;  . addListener ( new GenericFutureListener < ChannelFuture > ( ) { public void operationComplete ( final ChannelFuture future ) { if ( !  . isSuccess ( ) ) { tryFailureAndLogRejectedCause (  ,  . cause ( ) ) ; } } } ) ;  . channel ( ) . closeFuture ( ) . addListener ( new GenericFutureListener < ChannelFuture > ( ) { public void operationComplete ( final ChannelFuture future ) {  . tryFailure ( new IllegalStateException ( "Channel closed before HTTP/2 preface completed." ) ) ; } } ) ; } } ,  ,  . SECONDS ) ; return  ; }<CODESPLIT>Creates and connects a new channel . The initial connection attempt may be delayed to accommodate exponential back - off requirements .
public static List < String > loadOptions ( String optionFileName ) { List < String >  = new ArrayList < String > ( ) ; File  = new File (  ) ; StringWriter  = new StringWriter ( ) ; try { InputStream  = new FileInputStream (  ) ;  . copy (  ,  ) ; } catch ( FileNotFoundException e ) {  . err . println ( "Error reading options file: " +  . getMessage ( ) ) ;  . exit ( 1 ) ; } catch ( IOException e ) {  . err . println ( "Error reading options file: " +  . getMessage ( ) ) ;  . exit ( 1 ) ; } String  =  . toString ( ) ; StringTokenizer  = new StringTokenizer (  ) ; while (  . hasMoreTokens ( ) ) {  . add (  . nextToken ( ) ) ; } return  ; }<CODESPLIT>Load options from a file
public void runJob ( ) { try { this . currentJob = this . jobQueue . take ( ) ; ExecutionContext  = new ExecutionContext ( ) ; try { this . executionContextManager . initialize (  ) ; } catch ( ExecutionContextException e ) { throw new RuntimeException ( "Failed to initialize Job " + this . currentJob + " execution context" ,  ) ; } this . currentJob . run ( ) ; } catch ( InterruptedException e ) { } finally { this . execution . removeContext ( ) ; } }<CODESPLIT>Execute one job .
public Response bind ( String name , Object model ) { getLocals ( ) . put (  ,  ) ; return this ; }<CODESPLIT>Binds an object to the response .
public byte [ ] getByteArray ( Integer offset ) { byte [ ]  = null ; if (  != null ) {  =  . get (  ) ; } return (  ) ; }<CODESPLIT>This method retrieves a byte array containing the data at the given offset in the block . If no data is found at the given offset this method returns null .
public Object [ ] getMetaMethods ( ) { MetaClass  =  . getMetaClass (  ) ; List  =  . getMetaMethods ( ) ; Object [ ]  = new Object [  . size ( ) ] ; int  = 0 ; for ( Iterator  =  . iterator ( ) ;  . hasNext ( ) ;  ++ ) { MetaMethod  = ( MetaMethod )  . next ( ) ;  [  ] = methodInfo (  ) ; } return  ; }<CODESPLIT>Get info about instance and class Methods that are dynamically added through Groovy .
static long [ ] parse ( String pollers ) { String [ ]  =  . split ( ",\\s*" ) ; long [ ]  = new long [  . length ] ; boolean  = false ; Logger  =  . getLogger ( Pollers . class ) ; for ( int  = 0 ;  <  . length ; ++  ) { String  =  [  ] ; try {  [  ] =  . parseLong (  ) ; if (  [  ] <= 0 ) {  . error ( "Invalid polling interval: {} must be positive." ,  ) ;  = true ; } } catch ( NumberFormatException e ) {  . error ( "Cannot parse '{}' as a long: {}" ,  ,  . getMessage ( ) ) ;  = true ; } } if (  ||  . length == 0 ) {  . info ( "Using a default configuration for poller intervals: {}" , join (  ) ) ; return  ; } else { return  ; } }<CODESPLIT>Parse the content of the system property that describes the polling intervals and in case of errors use the default of one poller running every minute .
public void setFooter ( String key , String value ) {  . requireNonNull (  ) ; int  = 0 ; boolean  = false ; for (  =  . size ( ) - 1 ;  >= 0 ;  -- ) { String  =  . get (  ) ; if (  . equalsIgnoreCase (  ) ) { if (  ) {  . remove (  ) ;  . remove (  ) ; } else {  = true ;  . set (  ,  ) ; } } } if ( !  ) {  . add (  ) ;  . add (  ) ; } }<CODESPLIT>Sets a footer replacing an already - existing footer
public void addAttribute ( String name , final String value ) { if (  . m_startTagOpen ) { final String  = patchName (  ) ; final String  = getLocalName (  ) ; final String  = getNamespaceURI (  , false ) ; addAttributeAlways (  ,  ,  , "CDATA" ,  , false ) ; } }<CODESPLIT>Adds the given attribute to the set of collected attributes but only if there is a currently open element .
public MimeMessage createMimeMessage ( Session session ) throws MessagingException { if ( isEmpty (  ) && isEmpty (  ) ) { throw new IllegalArgumentException ( "Missing email content" ) ; } final MimeMessage  = new MimeMessage (  ) ;  . setSubject (  ) ;  . setFrom ( new InternetAddress (  ) ) ;  . setContent ( createMultiPart ( ) ) ;  . setRecipients (  . RecipientType . TO ,  . parse (  , false ) ) ; return  ; }<CODESPLIT>Creates a MimeMessage containing given Multipart . Subject sender and content and session will be set .
public static ForwardCurveInterpolation createForwardCurveFromMonteCarloLiborModel ( String name , LIBORModelMonteCarloSimulationModel model , double startTime ) throws CalculationException { int  =  . getTimeIndex (  ) ; ArrayList < RandomVariable >  = new ArrayList < > ( ) ; int  =  . getLiborPeriodDiscretization ( ) . getTimeIndexNearestGreaterOrEqual (  ) ; double  =  . getLiborPeriodDiscretization ( ) . getTime (  ) ; if (  >  ) {  . add (  . getLIBOR (  ,  ,  ) ) ; } double [ ]  = new double [  ==  ? (  . getNumberOfLibors ( ) -  ) : (  . getNumberOfLibors ( ) -  + 1 ) ] ;  [ 0 ] = 0 ; int  =  ==  ? 0 : 1 ; for ( int  =  ;  <  . getNumberOfLibors ( ) ;  ++ ) {  . add (  . getLIBOR (  ,  ) ) ;  [  -  +  ] =  . getLiborPeriodDiscretization ( ) . getTime (  ) -  ; } RandomVariable [ ]  =  . toArray ( new RandomVariable [  . size ( ) ] ) ; return  . createForwardCurveFromForwards (  ,  ,  ,  . getLiborPeriodDiscretization ( ) . getTimeStep (  ) ) ; }<CODESPLIT>Create a forward curve from forwards given by a LIBORMonteCarloModel .
public ServiceCall < Void > deleteWord ( DeleteWordOptions deleteWordOptions ) {  . notNull (  , "deleteWordOptions cannot be null" ) ; String [ ]  = { "v1/customizations" , "words" } ; String [ ]  = {  . customizationId ( ) ,  . word ( ) } ; RequestBuilder  =  . delete (  . constructHttpUrl ( getEndPoint ( ) ,  ,  ) ) ; Map < String , String >  =  . getSdkHeaders ( "text_to_speech" , "v1" , "deleteWord" ) ; for ( Entry < String , String >  :  . entrySet ( ) ) {  . header (  . getKey ( ) ,  . getValue ( ) ) ; } return createServiceCall (  . build ( ) ,  . getVoid ( ) ) ; }<CODESPLIT>Delete a custom word .
private boolean tryMove ( float x , float y ) { float  =  +  ; float  =  +  ; if ( blocked (  ,  ) ) { if ( blocked (  ,  ) ) { if ( blocked (  ,  ) ) { return false ; } else {  =  ; return true ; } } else {  =  ; return true ; } } else {  =  ;  =  ; return true ; } }<CODESPLIT>Try to move in the direction specified . If it s blocked try sliding . If that doesn t work just don t bother
public void recover ( ) { try { this . messages . clear ( ) ; this . dataLogger . prepareForRead ( ) ; this . dataLogger . recover ( this ) ; } catch ( Exception e ) { throw new DelegatedRuntimeException (  ) ; } }<CODESPLIT>recovers the dataRecorder all messages are removed and all the messsages of the logger are recoverd
public void clearSources ( ) { synchronized (  ) { for ( GVRAudioSource  :  ) {  . setListener ( null ) ; }  . clear ( ) ; } }<CODESPLIT>Remove all of the audio sources from the audio manager . This will stop all sound from playing .
@ SuppressWarnings ( "unchecked" ) public static < V extends NumberVector > NumberVector . Factory < V > guessFactory ( SimpleTypeInformation < V > in ) { NumberVector . Factory < V >  = null ; if (  instanceof VectorTypeInformation ) {  = ( NumberVector . Factory < V > ) ( ( VectorTypeInformation < V > )  ) . getFactory ( ) ; } if (  == null ) { try { Field  =  . getRestrictionClass ( ) . getField ( "FACTORY" ) ;  = ( NumberVector . Factory < V > )  . get ( null ) ; } catch ( Exception e ) {  . warning ( "Cannot determine factory for type " +  . getRestrictionClass ( ) ,  ) ; } } return  ; }<CODESPLIT>Try to guess the appropriate factory .
public void balance ( ) { if ( !  . exists ( ) )  . mkdirs ( ) ; if ( !  . exists ( ) )  . mkdirs ( ) ; if (  == null )  =  . newHashMap ( ) ; if (  == null )  =  . newArrayList ( ) ; for ( int  = 0 ;  <  ;  ++ ) {  . put (  , new ArrayList < File > ( ) ) ;  . add ( new File (  ,  . valueOf (  ) ) ) ; } while (  . hasNext ( ) ) { DataSet  =  . next ( ) ; if (  < 0 )  =  . numExamples ( ) ; for ( int  = 0 ;  <  . numExamples ( ) ;  ++ ) { DataSet  =  . get (  ) ; if ( !  . get (  . outcome ( ) ) . exists ( ) )  . get (  . outcome ( ) ) . mkdirs ( ) ; File  = new File (  . get (  . outcome ( ) ) ,  . valueOf (  . get (  . outcome ( ) ) . size ( ) ) ) ;  . save (  ) ;  . get (  . outcome ( ) ) . add (  ) ; } } int  = 0 ; while ( !  . isEmpty ( ) ) { List < DataSet >  = new ArrayList < > ( ) ; while (  . size ( ) <  && !  . isEmpty ( ) ) { for ( int  = 0 ;  <  ;  ++ ) { if (  . get (  ) != null && !  . get (  ) . isEmpty ( ) ) { DataSet  = new DataSet ( ) ;  . load (  . get (  ) . remove ( 0 ) ) ;  . add (  ) ; } else  . remove (  ) ; } } if ( !  . exists ( ) )  . mkdirs ( ) ; if ( !  . isEmpty ( ) ) { DataSet  =  . merge (  ) ; if (  != null )  . transform (  ) ;  . save ( new File (  ,  . format ( "dataset-%d.bin" ,  ++ ) ) ) ; } } }<CODESPLIT>Generate a balanced dataset minibatch fileset .
private static boolean isunixtimeleap ( double unixTime ) { double  =  - 315964800 ;  += countleaps (  , true ) - 1 ; return isleap (  ) ; }<CODESPLIT>Test to see if a unixtime second is a leap second
public static void setSunXMLHeaders ( final Marshaller aMarshaller , final String sXMLHeaders ) { final String  =  ; _setProperty (  ,  ,  ) ; }<CODESPLIT>Set the Sun specific XML header string .
private void sendKeepAliveBridgeMessage ( int appId , String bridgeId , String token , final CallStatsHttp2Client httpClient ) { long  =  . currentTimeMillis ( ) ; BridgeKeepAliveMessage  = new BridgeKeepAliveMessage (  ,  ) ; String  =  . toJson (  ) ;  . sendBridgeAlive (  ,  ,  , new CallStatsHttp2ResponseListener ( ) { public void onResponse ( Response response ) { int  =  . code ( ) ; BridgeKeepAliveResponse  ; try { String  =  . body ( ) . string ( ) ;  =  . fromJson (  , BridgeKeepAliveResponse . class ) ; } catch ( IOException e ) {  . printStackTrace ( ) ; throw new RuntimeException (  ) ; } catch ( JsonSyntaxException e ) {  . error ( "Json Syntax Exception " +  . getMessage ( ) ,  ) ;  . printStackTrace ( ) ; throw new RuntimeException (  ) ; }  . setDisrupted ( false ) ; if (  ==  . RESPONSE_STATUS_SUCCESS ) {  . onSuccess ( ) ; } else if (  ==  . INVALID_AUTHENTICATION_TOKEN ) { stopKeepAliveSender ( ) ;  . onKeepAliveError (  . AUTH_ERROR ,  . getMsg ( ) ) ; } else {  . setDisrupted ( true ) ; } } public void onFailure ( Exception e ) {  . info ( "Response exception " +  . toString ( ) ) ;  . setDisrupted ( true ) ; } } ) ; }<CODESPLIT>Send keep alive bridge message .
public StreamingOutput getResource ( final String resourceName , final long nodeId , final Map < QueryParameter , String > queryParams ) throws JaxRxException { final StreamingOutput  = new StreamingOutput ( ) { public void write ( final OutputStream output ) throws IOException , JaxRxException { final String  =  . get (  . REVISION ) ; final String  =  . get (  . WRAP ) ; final String  =  . get (  . OUTPUT ) ; final boolean  = (  == null ) ? false :  . equalsIgnoreCase (  ) ; final boolean  = (  == null ) ? false :  . equalsIgnoreCase (  ) ; final Long  =  == null ? null :  . valueOf (  ) ; serialize (  ,  ,  ,  ,  ,  ) ; } } ; return  ; }<CODESPLIT>This method is responsible to deliver the whole XML resource addressed by a unique node id .
public static ManagedEntity [ ] createManagedEntities ( ServerConnection sc , ManagedObjectReference [ ] mors ) { if (  == null ) { return new ManagedEntity [ 0 ] ; } ManagedEntity [ ]  = new ManagedEntity [  . length ] ; for ( int  = 0 ;  <  . length ;  ++ ) {  [  ] = createExactManagedEntity (  ,  [  ] ) ; } return  ; }<CODESPLIT>Given a ServerConnection and an array of MORs return an array of MEs
public static Function < String , String > createStringTemplateSource ( I_CmsFormatterBean formatter , Supplier < CmsXmlContent > contentSupplier ) { return key -> { String  = null ; if (  != null ) {  =  . getAttributes ( ) . get (  ) ; } if (  == null ) { CmsXmlContent  =  . get ( ) ; if (  != null ) {  =  . getHandler ( ) . getParameter (  ) ; } } return  ; } ; }<CODESPLIT>Helper method to create a string template source for a given formatter and content .
private static final ByteBuffer createReadWriteMessage ( final byte opCode , final int logicalBlockAddress , final short transferLength ) { ByteBuffer  =  . allocate (  ) ;  . put (  ) ;  . position (  ) ;  . putInt (  ) ;  . position (  ) ;  . putShort (  ) ;  . rewind ( ) ; return  ; }<CODESPLIT>Creates the Command Descriptor Block for a given Operation Message .
public long read ( ByteBuffer [ ] dsts , int offset , int length ) throws IOException { long  = fillAppRead ( ) ; if (  <= 0 ) { return  ; } return  . move (  ,  ,  ,  ) ; }<CODESPLIT>Reads ByteBuffer from peer . Starts handshaking if needed .
public static void setInt ( MemorySegment [ ] segments , int offset , int value ) { if ( inFirstSegment (  ,  , 4 ) ) {  [ 0 ] . putInt (  ,  ) ; } else { setIntMultiSegments (  ,  ,  ) ; } }<CODESPLIT>set int from segments .
public Optional < User > getOptionalUser ( String username ) { try { return (  . ofNullable ( getUser (  ) ) ) ; } catch ( GitLabApiException glae ) { return (  . createOptionalFromException (  ) ) ; } }<CODESPLIT>Lookup a user by username and return an Optional instance .
protected void registerRateLimiterComponent ( ) { String  =  . COMPONENT_PREFIX + IRateLimiterComponent . class . getSimpleName ( ) ; setConfigProperty (  , ESRateLimiterComponent . class . getName ( ) ) ; setConfigProperty (  + ".client.type" , "jest" ) ; setConfigProperty (  + ".client.protocol" , "${apiman.es.protocol}" ) ; setConfigProperty (  + ".client.host" , "${apiman.es.host}" ) ; setConfigProperty (  + ".client.port" , "${apiman.es.port}" ) ; setConfigProperty (  + ".client.username" , "${apiman.es.username}" ) ; setConfigProperty (  + ".client.password" , "${apiman.es.password}" ) ; }<CODESPLIT>The rate limiter component .
public Point3d getCoordinatesFromGridPoint ( int gridPoint ) { int  = 0 ; Point3d  = new Point3d ( 0 , 0 , 0 ) ; for ( int  = 0 ;  <  [ 0 ] [ 0 ] . length ;  ++ ) { for ( int  = 0 ;  <  [ 0 ] . length ;  ++ ) { for ( int  = 0 ;  <  . length ;  ++ ) { if (  ==  ) {  . x =  +  *  ;  . y =  +  *  ;  . z =  +  *  ; return  ; }  ++ ; } } } return  ; }<CODESPLIT>Method calculates coordinates from a given grid array position .
public void setColor ( final Color COLOR ) { if ( null ==  ) {  =  ; } else {  . set (  ) ; } }<CODESPLIT>Defines the color that will be used to colorize the section in a clock .
public void releaseEvent ( EventId eventId ) throws Exception { Lockable < V >  =  . getEvent (  ) ; if (  != null ) { if (  . release ( ) ) {  . removeEvent (  ) ; } else {  . upsertEvent (  ,  ) ; } } }<CODESPLIT>Decreases the reference counter for the given event so that it can be removed once the reference counter reaches 0 .
public String toSql ( boolean showParameters ) { String  ; if (  ) {  =  . getDialect ( ) . formSelect ( null , null ,  ,  ,  ,  ) ; } else {  =  != null ?  :  . getDialect ( ) . formSelect (  . getTableName ( ) , null ,  ,  ,  ,  ) ; } if (  ) { StringBuilder  = new StringBuilder (  ) . append ( ", with parameters: " ) ; join (  ,  , ", " ) ;  =  . toString ( ) ; } return  ; }<CODESPLIT>Use to see what SQL will be sent to the database .
private Source getSourceFromUriResolver ( StylesheetHandler handler ) throws TransformerException { Source  = null ; TransformerFactoryImpl  =  . getStylesheetProcessor ( ) ; URIResolver  =  . getURIResolver ( ) ; if (  != null ) { String  = getHref ( ) ; String  =  . getBaseIdentifier ( ) ;  =  . resolve (  ,  ) ; } return  ; }<CODESPLIT>Get the Source object for the included or imported stylesheet module obtained from the user s URIResolver if there is no user provided URIResolver null is returned .
public String getTitle ( ) { if (  . featOkTst && ( ( Journal_Type )  ) . casFeat_title == null )  . jcas . throwFeatMissing ( "title" , "de.julielab.jules.types.Journal" ) ; return  . ll_cas . ll_getStringValue (  , ( ( Journal_Type )  ) . casFeatCode_title ) ; }<CODESPLIT>getter for title - gets Full journal title C
public static Val of ( Object o ) { if (  != null &&  instanceof Val ) { return  . as (  ) ; } return new Val (  ) ; }<CODESPLIT>Convenience method for creating a Convertible Object
protected void addContextTerms ( SparseDoubleVector meaning , Queue < String > words , int distance ) { for ( String  :  ) { if ( !  . equals (  . EMPTY_TOKEN ) ) { int  =  . getDimension (  ) ; if (  == - 1 ) continue ;  . set (  ,  . weight (  ,  ) ) ; ++  ; } } }<CODESPLIT>Adds a feature for each word in the context that has a valid dimension . Feature are scored based on the context word s distance from the focus word .
public ArrayList < View > getViews ( ) { try { if (  . commandLogging ) {  . d (  . commandLoggingTag , "getViews()" ) ; } return  . getViews ( null , false ) ; } catch ( Exception e ) {  . printStackTrace ( ) ; return null ; } }<CODESPLIT>Returns an ArrayList of all the View objects located in the focused Activity or Dialog .
private < E extends WeightedEdge > SparseDoubleVector getVertexWeightVector ( WeightedGraph < E > g , int vertex ) { if (  ) { SparseDoubleVector  =  . get (  ) ; if (  == null ) { synchronized ( this ) {  =  . get (  ) ; if (  == null ) {  = computeWeightVector (  ,  ) ;  . put (  ,  ) ; } } } return  ; } else return computeWeightVector (  ,  ) ; }<CODESPLIT>Returns the normalized weight vector for the specified row to be used in edge comparisons . The weight vector is normalized by the number of edges from the row with positive weights and includes a weight for the row to itself which reflects the similarity of the keystone nod .
static int fillRows ( Row [ ] rows , TypeDescription schema , VectorizedRowBatch batch , int [ ] selectedFields ) { int  =  . min ( ( int )  . count ( ) ,  . length ) ; List < TypeDescription >  =  . getChildren ( ) ; for ( int  = 0 ;  <  . length ;  ++ ) { int  =  [  ] ; readField (  ,  ,  . get (  ) ,  . cols [  ] ,  ) ; } return  ; }<CODESPLIT>Fills an ORC batch into an array of Row .
public List < ICalProperty > getProperties ( T component ) { return new ArrayList < ICalProperty > (  . getProperties ( ) . values ( ) ) ; }<CODESPLIT>Gets the properties to marshal . Child classes can override this for better control over which properties are marshalled .
public static double computeTauAndDivide ( final int j , final int numRows , final double [ ] u , final double max ) { double  = 0 ; for ( int  =  ;  <  ;  ++ ) { double  =  [  ] /=  ;  +=  *  ; }  =  . sqrt (  ) ; if (  [  ] < 0 )  = -  ; return  ; }<CODESPLIT>Normalizes elements in u by dividing by max and computes the norm2 of the normalized array u . Adjust the sign of the returned value depending on the size of the first element in u . Normalization is done to avoid overflow .
public Epic getEpic ( String epicKey , Map < String , Epic > epicMap ) { try { String  =  . getJiraBaseUrl ( ) + (  . getJiraBaseUrl ( ) . endsWith ( "/" ) ? "" : "/" ) +  . format (  ,  ) ; ResponseEntity < String >  = makeRestCall (  ) ; String  =  . getBody ( ) ; JSONObject  = ( JSONObject )  . parse (  ) ; if (  == null ) { return null ; } return saveEpic (  ,  , false ) ; } catch ( ParseException pe ) {  . error ( "Parser exception when parsing teams" ,  ) ; } catch ( HygieiaException e ) {  . error ( "Error in calling JIRA API" ,  ) ; } return null ; }<CODESPLIT>Get Epic using Jira API
public Serializable getLayoutConstraints ( final WComponent child ) { PanelModel  = getComponentModel ( ) ; if (  . layoutConstraints != null ) { return  . layoutConstraints . get (  ) ; } return null ; }<CODESPLIT>Retrieves the layout constraints for the given component if they have been set .
public Map < String , Set < String > > getReverseMap ( ) { Set < Map . Entry < String , Set < String > > >  =  . entrySet ( ) ; Map < String , Set < String > >  = new HashMap < String , Set < String > > (  . size ( ) ) ; for ( Map . Entry < String , Set < String > >  :  ) { String  =  . getKey ( ) ; Set < String >  =  . getValue ( ) ; for ( String  :  ) { Set < String >  =  . get (  ) ; if (  == null ) { Set < String >  = new LinkedHashSet < String > ( 6 ) ;  . add (  ) ;  . put (  ,  ) ; } else {  . add (  ) ; } } } return  ; }<CODESPLIT>Returns a reversed map of the current map .
public Credential setRefreshToken ( String refreshToken ) {  . lock ( ) ; try { if (  != null ) {  . checkArgument (  != null &&  != null &&  != null &&  != null , "Please use the Builder and call setJsonFactory, setTransport, setClientAuthentication" + " and setTokenServerUrl/setTokenServerEncodedUrl" ) ; } this . refreshToken =  ; } finally {  . unlock ( ) ; } return this ; }<CODESPLIT>Sets the refresh token .
public void makeCurrent ( EGLSurface eglSurface ) { if (  ==  . EGL_NO_DISPLAY ) {  . d (  , "NOTE: makeCurrent w/o display" ) ; } if ( !  . eglMakeCurrent (  ,  ,  ,  ) ) { throw new RuntimeException ( "eglMakeCurrent failed" ) ; } }<CODESPLIT>Makes our EGL context current using the supplied surface for both draw and read .
public static < T > T navigateSafe ( final T defaultValue , final Object source , final Object ... paths ) { return navigateOrDefault (  ,  ,  ) ; }<CODESPLIT>Use navigateOrDefault which is a much better name .
public void clearCache ( CommerceWarehouseItem commerceWarehouseItem ) {  . removeResult (  . ENTITY_CACHE_ENABLED , CommerceWarehouseItemImpl . class ,  . getPrimaryKey ( ) ) ;  . clearCache (  ) ;  . clearCache (  ) ; clearUniqueFindersCache ( ( CommerceWarehouseItemModelImpl )  , true ) ; }<CODESPLIT>Clears the cache for the commerce warehouse item .
private void process ( String input , String output ) throws MPXJException , IOException { MPPReader  = new MPPReader ( ) ;  =  . read (  ) ; String  ; String  ; int  =  . getInt (  . getProjectProperties ( ) . getMppFileType ( ) ) ; switch (  ) { case 8 : {  = " 1" ;  = "FixDeferFix 0" ; break ; } case 9 : {  = " 19" ;  = "Var2Data" ; break ; } case 12 : {  = " 112" ;  = "Var2Data" ; break ; } case 14 : {  = " 114" ;  = "Var2Data" ; break ; } default : { throw new IllegalArgumentException ( "Unsupported file type " +  ) ; } } FileInputStream  = new FileInputStream (  ) ; POIFSFileSystem  = new POIFSFileSystem (  ) ;  . close ( ) ; DirectoryEntry  =  . getRoot ( ) ;  = ( DirectoryEntry )  . getEntry (  ) ; Map < String , String >  = new HashMap < String , String > ( ) ; for ( Task  :  . getTasks ( ) ) { mapText (  . getName ( ) ,  ) ; } processReplacements ( ( ( DirectoryEntry )  . getEntry ( "TBkndTask" ) ) ,  ,  , true ) ;  . clear ( ) ; for ( Resource  :  . getResources ( ) ) { mapText (  . getName ( ) ,  ) ; mapText (  . getInitials ( ) ,  ) ; } processReplacements ( ( DirectoryEntry )  . getEntry ( "TBkndRsc" ) ,  ,  , true ) ;  . clear ( ) ; ProjectProperties  =  . getProjectProperties ( ) ; mapText (  . getProjectTitle ( ) ,  ) ; processReplacements (  , "Props" ,  , true ) ;  . clear ( ) ; mapText (  . getProjectTitle ( ) ,  ) ; mapText (  . getSubject ( ) ,  ) ; mapText (  . getAuthor ( ) ,  ) ; mapText (  . getKeywords ( ) ,  ) ; mapText (  . getComments ( ) ,  ) ; processReplacements (  , "\005SummaryInformation" ,  , false ) ;  . clear ( ) ; mapText (  . getManager ( ) ,  ) ; mapText (  . getCompany ( ) ,  ) ; mapText (  . getCategory ( ) ,  ) ; processReplacements (  , "\005DocumentSummaryInformation" ,  , false ) ; FileOutputStream  = new FileOutputStream (  ) ;  . writeFilesystem (  ) ;  . flush ( ) ;  . close ( ) ;  . close ( ) ; }<CODESPLIT>Process an MPP file to make it anonymous .
public void setRollbackOnly ( ) { final boolean  =  . isAnyTracingEnabled ( ) ; if (  &&  . isEntryEnabled ( ) ) {  . entry (  , "setRollbackOnly" , this ) ; } LocalTransactionCoordinator  = getLocalCoord ( ) ; if (  != null ) {  . setRollbackOnly ( ) ; } else { try {  . setRollbackOnly ( ) ; } catch ( Exception e ) {  . processException (  ,  + ".setRollbackOnly" , "556" , this ) ; throw new IllegalStateException ( "No active transaction" ) ; } } if (  &&  . isEntryEnabled ( ) ) {  . exit (  , "setRollbackOnly" ) ; } }<CODESPLIT>Marks the current local or global transaction to be rolled back
private static boolean analyse404Response ( final String content ) { if (  . contains ( "\"reason\":\"missing\"" ) ) { return true ; }  . debug ( "Design document not found, error is {}" ,  ) ; return false ; }<CODESPLIT>Analyses the content of a 404 response to see if it is legible for retry .
private ListenableFuture < ? > writeBlocksToTargets ( Collection < DBBPool . BBContainer > outputBuffers , int [ ] serialized ) {  . checkArgument (  . size ( ) ==  . length ) ;  . checkArgument (  . size ( ) ==  . length ) ; final List < ListenableFuture < ? > >  = new ArrayList < ListenableFuture < ? > > (  . size ( ) ) ; Iterator < DBBPool . BBContainer >  =  . iterator ( ) ; int  = 0 ; for ( SnapshotTableTask  :  ) { final DBBPool . BBContainer  =  . next ( ) ; final ByteBuffer  =  . b ( ) ;  . limit (  [  ++ ] +  . m_target . getHeaderSize ( ) ) ;  . position ( 0 ) ; Callable < DBBPool . BBContainer >  =  . returning (  ) ; if (  . m_filters != null ) { for ( SnapshotDataFilter  :  . m_filters ) {  =  . filter (  ) ; } } ListenableFuture < ? >  =  . m_target . write (  ,  ) ; if (  != null ) {  . add (  ) ; } } return  . allAsList (  ) ; }<CODESPLIT>Finalize the output buffers and write them to the corresponding data targets
private boolean isTerminal ( IAtom atom , Map < IAtom , Integer > atomToIndex ) { return  [  . get (  ) ] . length == 1 ; }<CODESPLIT>Is the atom terminal having only one connection .
private Handler < AsyncResult < Void > > createUndeployHandler ( final Message < JsonObject > message ) { return new Handler < AsyncResult < Void > > ( ) { public void handle ( AsyncResult < Void > result ) { if (  . failed ( ) ) {  . reply ( new JsonObject ( ) . putString ( "status" , "error" ) . putString ( "message" ,  . cause ( ) . getMessage ( ) ) ) ; } else {  . reply ( new JsonObject ( ) . putString ( "status" , "ok" ) ) ; } } } ; }<CODESPLIT>Creates a platform undeploy handler .
public PhotoAllContext getAllContexts ( String photoId ) throws FlickrException { PhotoSetList < PhotoSet >  = new PhotoSetList < PhotoSet > ( ) ; PoolList < Pool >  = new PoolList < Pool > ( ) ; PhotoAllContext  = new PhotoAllContext ( ) ; Map < String , Object >  = new HashMap < String , Object > ( ) ;  . put ( "method" ,  ) ;  . put ( "photo_id" ,  ) ; Response  =  . get (  . getPath ( ) ,  ,  ,  ) ; if (  . isError ( ) ) { throw new FlickrException (  . getErrorCode ( ) ,  . getErrorMessage ( ) ) ; } Collection < Element >  =  . getPayloadCollection ( ) ; for ( Element  :  ) { if (  . getTagName ( ) . equals ( "set" ) ) { PhotoSet  = new PhotoSet ( ) ;  . setTitle (  . getAttribute ( "title" ) ) ;  . setSecret (  . getAttribute ( "secret" ) ) ;  . setId (  . getAttribute ( "id" ) ) ;  . setFarm (  . getAttribute ( "farm" ) ) ;  . setPrimary (  . getAttribute ( "primary" ) ) ;  . setServer (  . getAttribute ( "server" ) ) ;  . setViewCount (  . parseInt (  . getAttribute ( "view_count" ) ) ) ;  . setCommentCount (  . parseInt (  . getAttribute ( "comment_count" ) ) ) ;  . setCountPhoto (  . parseInt (  . getAttribute ( "count_photo" ) ) ) ;  . setCountVideo (  . parseInt (  . getAttribute ( "count_video" ) ) ) ;  . add (  ) ;  . setPhotoSetList (  ) ; } else if (  . getTagName ( ) . equals ( "pool" ) ) { Pool  = new Pool ( ) ;  . setTitle (  . getAttribute ( "title" ) ) ;  . setId (  . getAttribute ( "id" ) ) ;  . setUrl (  . getAttribute ( "url" ) ) ;  . setIconServer (  . getAttribute ( "iconserver" ) ) ;  . setIconFarm (  . getAttribute ( "iconfarm" ) ) ;  . setMemberCount (  . parseInt (  . getAttribute ( "members" ) ) ) ;  . setPoolCount (  . parseInt (  . getAttribute ( "pool_count" ) ) ) ;  . add (  ) ;  . setPoolList (  ) ; } } return  ; }<CODESPLIT>Returns all visble sets and pools the photo belongs to .
public Map < String , Object > getFieldData ( Map < String , Object > properties ) { Map < String , Object >  = null ; if (  != null ) {  = new Hashtable < String , Object > ( ) ; for ( int  = 1 ; ;  ++ ) { String  =  . FIELD +  . toString (  ) ; String  = ( String )  . get (  ) ; if (  == null ) break ; Record  = this . getMainRecord ( ) ; if (  . indexOf ( '.' ) != - 1 ) {  = this . getRecord (  . substring ( 0 ,  . indexOf ( '.' ) ) ) ;  =  . substring (  . indexOf ( '.' ) + 1 ) ; } BaseField  = null ; if (  != null )  =  . getField (  ) ; if (  != null )  . put (  ,  . getData ( ) ) ; } } return  ; }<CODESPLIT>GetFieldData Method .
protected void connect ( InetAddress address , int port ) throws SocketException {  . getThreadPolicy ( ) . onNetwork ( ) ; connect0 (  ,  ) ;  =  ;  =  ;  = true ; }<CODESPLIT>Connects a datagram socket to a remote destination . This associates the remote address with the local socket so that datagrams may only be sent to this destination and received from this destination .
private char getEscaped ( ) {  ++ ; if (  ==  ) { throw new IllegalStateException ( "Unexpected end of DN: " +  ) ; } switch (  [  ] ) { case '"' : case '\\' : case ',' : case '=' : case '+' : case '<' : case '>' : case '#' : case ';' : case ' ' : case '*' : case '%' : case '_' : return  [  ] ; default : return getUTF8 ( ) ; } }<CODESPLIT>returns escaped char
private static String cutOffValidationMatchersPrefix ( String expression ) { if (  . startsWith (  . VALIDATION_MATCHER_PREFIX ) &&  . endsWith (  . VALIDATION_MATCHER_SUFFIX ) ) { return  . substring (  . VALIDATION_MATCHER_PREFIX . length ( ) ,  . length ( ) -  . VALIDATION_MATCHER_SUFFIX . length ( ) ) ; } return  ; }<CODESPLIT>Cut off validation matchers prefix and suffix .
public SortedSet < TypeElement > implementingClasses ( TypeElement typeElement ) { SortedSet < TypeElement >  = get (  ,  ) ; SortedSet < TypeElement >  = allSubClasses (  , false ) ; Iterator < TypeElement >  =  . iterator ( ) ; while (  . hasNext ( ) ) { Iterator < TypeElement >  = implementingClasses (  . next ( ) ) . iterator ( ) ; while (  . hasNext ( ) ) { TypeElement  =  . next ( ) ; if ( !  . contains (  ) ) {  . add (  ) ; } } } return  ; }<CODESPLIT>Return the set of classes which implement the interface passed .
public void add ( ValidationResult validation ) {  &=  . correct ; if ( !  ) return ;  . addAll (  . errors ) ;  . addAll (  . warnings ) ; }<CODESPLIT>Adds a validation result to this .
public static String toMetaFieldInfoString ( Object obj ) { StringBuffer  = new StringBuffer ( 100 ) ; MetaFieldInfo [ ]  = toMetaFieldInfoArray (  , null , true ) ; for ( int  = 0 ;  <  . length ;  ++ ) { MetaFieldInfo  =  [  ] ;  . append (  . name ) ;  . append ( "=" ) ; if (  . actualValue != null &&  . actualValue . getClass ( ) . equals ( String . class ) ) {  . append ( '"' ) ;  . append (  . value ) ;  . append ( '"' ) ; } else {  . append (  . value ) ; } if (  + 1 <  . length )  . append ( "," ) ; } return  . toString ( ) ; }<CODESPLIT>Creates a string for an object based on the MetaField annotations .
public String getArrayClassName ( Class < ? > clazz ) { if (  . isArray ( ) ) { return getArrayClassName (  . getComponentType ( ) ) + "[]" ; } return  . getName ( ) ; }<CODESPLIT>Formats the class name with trailing square brackets .
synchronized void addBlock ( Block block ) { if ( ! isInitialized ( ) ) { return ; } BlockScanInfo  =  . get (  ) ; if (  != null ) {  . warn ( "Adding an already existing block " +  ) ; delBlockInfo (  ) ; }  = new BlockScanInfo (  ) ;  . lastScanTime = getNewBlockScanTime ( ) ; addBlockInfo (  ) ; adjustThrottler ( ) ; }<CODESPLIT>Adds block to list of blocks
public String getTile ( int x , int y ) { if ( (  > getArrayWidth ( ) ) || (  > getArrayHeight ( ) ) || (  < 0 ) || (  < 0 ) ) { throw new IllegalArgumentException ( ) ; } return  [  ] [  ] ; }<CODESPLIT>Gets a tile of the XPM Image .
public JBBPDslBuilder BitArray ( final String name , final String bitLenExpression , final String sizeExpression ) { final Item  = new Item (  . BIT_ARRAY ,  , this . byteOrder ) ;  . bitLenExpression = assertExpressionChars (  ) ;  . sizeExpression = assertExpressionChars (  ) ; this . addItem (  ) ; return this ; }<CODESPLIT>Add named bit array where each bit length is calculated through expression .
public static Object indexOf ( String strPattern , String strInput , int offset , boolean caseSensitive , boolean matchAll ) throws MalformedPatternException { PatternMatcherInput  = new PatternMatcherInput (  ) ; Perl5Matcher  = new Perl5Matcher ( ) ; int  =  ? 0 :  . CASE_INSENSITIVE_MASK ;  +=  . SINGLELINE_MASK ; if (  < 1 )  = 1 ; Pattern  = getPattern (  ,  ) ; if (  <=  . length ( ) )  . setCurrentOffset (  - 1 ) ; if (  <=  . length ( ) ) { Array  = new ArrayImpl ( ) ; while (  . contains (  ,  ) ) { int  =  . getMatch ( ) . beginOffset ( 0 ) + 1 ; if ( !  ) { return new Double (  ) ; }  . appendEL (  ) ; } if (  . size ( ) != 0 ) { return  ; } } return 0 ; }<CODESPLIT>return index of the first occurence of the pattern in input text
private Object checkRegisteredServicesByLdapFilter ( String filter ) throws InvalidSyntaxException { ServiceReference < ? > [ ]  = getBundleContext ( ) . getServiceReferences ( ( String ) null ,  ) ; if ( isEmptyOrNull (  ) ) { return null ; } if (  . length == 1 ) { return getBundleContext ( ) . getService (  [ 0 ] ) ; } throw new RuntimeException ( "Too many services registered for filter: " +  ) ; }<CODESPLIT>Checks the OSGi ServiceRegistry if a service matching the given filter is present .
public void postEvent ( DEvent event ) { if (  != null ) {  . postEvent (  ) ; } else if (  != null ) {  . postEvent (  ) ; } else {  . info ( "Dropping event for non- or no longer managed object" , "oid" , getOid ( ) , "class" , getClass ( ) . getName ( ) , "event" ,  ) ; } }<CODESPLIT>Posts the specified event either to our dobject manager or to the compound event for which we are currently transacting .
public static Identity createOverlayManagerGroup ( String name ) { return  . createExtendedIdentifier (  . ICS_METADATA_NS_URI ,  . ICS_METADATA_PREFIX , "overlay-manager-group" ,  ) ; }<CODESPLIT>Create a overlay - manager - group identifier that is an extended identity identifier .
public static DoubleMatrix cholesky ( DoubleMatrix A ) { DoubleMatrix  =  . dup ( ) ; int  =  . dpotrf ( 'U' ,  . rows ,  . data , 0 ,  . rows ) ; if (  < 0 ) { throw new LapackArgumentException ( "DPOTRF" , -  ) ; } else if (  > 0 ) { throw new LapackPositivityException ( "DPOTRF" , "Minor " +  + " was negative. Matrix must be positive definite." ) ; } clearLower (  ) ; return  ; }<CODESPLIT>Compute Cholesky decomposition of A
public static boolean isCaller ( final String className , final String methodName ) { final Throwable  = new Throwable ( ) ; final StackTraceElement [ ]  =  . getStackTrace ( ) ; if ( null ==  ) {  . log (  . WARN , "Empty call stack" ) ; return false ; } final boolean  = "*" . equals (  ) ; for ( int  = 1 ;  <  . length ;  ++ ) { if (  [  ] . getClassName ( ) . equals (  ) ) { return  ? true :  [  ] . getMethodName ( ) . equals (  ) ; } } return false ; }<CODESPLIT>Checks the current method is whether invoked by a caller specified by the given class name and method name .
public InputStream setFlag ( String name , String value ) throws IOException { return executeCommand ( "setflag" ,  ,  ) ; }<CODESPLIT>set JVM command line flag
public Q addFlag ( Position position , String prefix , Expression < ? > expr ) { Expression < ? >  =  . template (  . getType ( ) ,  + "{0}" ,  ) ; return  . addFlag ( new QueryFlag (  ,  ) ) ; }<CODESPLIT>Add the given prefix and expression as a general query flag
static ConnectionInfo newConnectionInfo ( Channel c ) { SocketChannel  = ( SocketChannel )  ; InetSocketAddress  =  . localAddress ( ) ; InetSocketAddress  = getRemoteAddress (  ) ; String  =  . pipeline ( ) . get ( SslHandler . class ) != null ? "https" : "http" ; return new ConnectionInfo (  ,  ,  ) ; }<CODESPLIT>Retrieve the connection information from the current connection directly
public PDPDomain getPDPDomain ( String pdpDomainName ) throws IOException { SortedSet < String >  = null ; if (  != null ) { if (  . containsKey (  ) ) {  =  . get (  ) ; } } boolean  = checkDomainRanges (  ) ; try { if (  ) { URL  = new URL (  + "getPDPDomain?pdpId=" +  ) ;  . info ( "Fetching {}" ,  ) ; InputStream  =  . getInputStream (  ) ; String  =  . convertStreamToString (  ) ;  =  . getDomainRangesFromXML (  ) ; if (  != null ) cache (  ,  ) ; } } catch ( MalformedURLException e ) {  . error ( "Problem generating PDP request URL for " +  ,  ) ; throw new IllegalArgumentException ( "Invalid PDP name: " +  ,  ) ; } String  = null ; List < ResidueRange >  = new ArrayList < ResidueRange > ( ) ; for ( String  :  ) { SubstructureIdentifier  = new SubstructureIdentifier (  ) ; if (  == null ) {  =  . getPdbId ( ) ; } else if ( !  . equals (  . getPdbId ( ) ) ) { throw new RuntimeException ( "Don't know how to take the union of domains from multiple PDB IDs." ) ; }  . addAll (  . getResidueRanges ( ) ) ; } return new PDPDomain (  ,  ) ; }<CODESPLIT>Get a StructureIdentifier representing the specified PDP domain .
public Context getContext ( ) { if (  != null ) { return  . getContext ( ) ; } else if (  != null ) { return  . getContext ( ) ; } throw new IllegalStateException (  ) ; }<CODESPLIT>Returns the context the view is running in through which it can access the current theme resources etc .
private boolean isMacroCycle ( IRing ring , IRingSet rs ) { if (  . getAtomCount ( ) < 8 ) return false ; for ( IBond  :  . bonds ( ) ) { boolean  = false ; for ( IAtomContainer  :  . atomContainers ( ) ) { if (  ==  ) continue ; if (  . contains (  ) ) {  = true ; break ; } } if ( !  ) return true ; } return false ; }<CODESPLIT>Check if a ring in a ring set is a macro cycle . We define this as a ring with > = 10 atom and has at least one bond that isn t contained in any other rings .
public < T > T datastoreToJava ( Entity entity ) { try { if (  == null ) { return null ; } T  = ( T )  . newInstance ( ) ; populate (  ,  ) ; return  ; } catch ( InstantiationException e ) { throw new RuntimeException (  ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException (  ) ; } }<CODESPLIT>Convert a value from Google representation to a Java value
private void updateCacheState ( Map < String , Object > props ) { getAuthenticationConfig (  ) ; if (  ) {  . activate (  ) ; } else {  . deactivate (  ) ; } }<CODESPLIT>Based on the configuration properties the auth cache should either be active or not .
public static QuerySnapshot withChanges ( final Query query , Timestamp readTime , final DocumentSet documentSet , final List < DocumentChange > documentChanges ) { return new QuerySnapshot (  ,  ) { volatile List < QueryDocumentSnapshot > documents ; public List < QueryDocumentSnapshot > getDocuments ( ) { if (  == null ) { synchronized (  ) { if (  == null ) {  =  . toList ( ) ; } } } return  . unmodifiableList (  ) ; } public List < DocumentChange > getDocumentChanges ( ) { return  . unmodifiableList (  ) ; } public int size ( ) { return  . size ( ) ; } public boolean equals ( Object o ) { if ( this ==  ) { return true ; } if (  == null || getClass ( ) !=  . getClass ( ) ) { return false ; } QuerySnapshot  = ( QuerySnapshot )  ; return  . equals (  ,  . query ) &&  . equals ( this . size ( ) ,  . size ( ) ) &&  . equals ( this . getDocumentChanges ( ) ,  . getDocumentChanges ( ) ) &&  . equals ( this . getDocuments ( ) ,  . getDocuments ( ) ) ; } public int hashCode ( ) { return  . hash (  , this . getDocumentChanges ( ) , this . getDocuments ( ) ) ; } } ; }<CODESPLIT>Creates a new QuerySnapshot representing a snapshot of a Query with changed documents .
private boolean readSend ( InH3 hIn , OutboxAmp outbox , HeadersAmp headers ) throws IOException { MethodRefHamp  = null ; try {  = readMethod (  ) ; } catch ( Throwable e ) {  . log (  . FINER ,  . toString ( ) ,  ) ; skipArgs (  ) ; return true ; } MethodRefAmp  =  . getMethod ( ) ; ClassLoader  =  . getClassLoader ( ) ; Thread  =  . currentThread ( ) ;  . setContextClassLoader (  ) ; Object [ ]  = readArgs (  ,  ) ; if (  . isLoggable (  ) ) {  . log (  , this + " send-r " +  . getName ( ) + debugArgs (  ) + " {to:" +  + ", " +  + "}" ) ; } SendMessage_N  = new SendMessage_N (  ,  ,  . serviceRef ( ) ,  . method ( ) ,  ) ; long  = 1000L ; try {  . offer (  ) ; } catch ( Throwable e ) {  . fine (  . toString ( ) ) ; if (  . isLoggable (  . FINEST ) ) {  . log (  . FINEST ,  . toString ( ) ,  ) ; } } return true ; }<CODESPLIT>The send message is a on - way call to a service .
private String getRemoteFileName ( UploadFile file ) { if (  . getProperty (  ) . endsWith ( "/" ) ) { return  . getName (  ) ; } if (  . getProperty (  ) . contains ( "/" ) ) { String [ ]  =  . getProperty (  ) . split ( "/" ) ; return  [  . length - 1 ] ; } return  . getProperty (  ) ; }<CODESPLIT>Checks if the remote file path contains also the remote file name . If it s not specified the name of the local file will be used .
public void initializeBufferMetrics ( Task task ) { final MetricGroup  = addGroup ( "buffers" ) ;  . gauge ( "inputQueueLength" , new InputBuffersGauge (  ) ) ;  . gauge ( "outputQueueLength" , new OutputBuffersGauge (  ) ) ;  . gauge ( "inPoolUsage" , new InputBufferPoolUsageGauge (  ) ) ;  . gauge ( "outPoolUsage" , new OutputBufferPoolUsageGauge (  ) ) ; }<CODESPLIT>Initialize Buffer Metrics for a task .
public void doubleClick ( String fileName ) throws QTasteException { try { new Region ( this . rect ) . doubleClick (  ) ; } catch ( Exception ex ) { throw new QTasteException (  . getMessage ( ) ,  ) ; } }<CODESPLIT>Simulates a double click on the specified image of the area .
public void setDestinationSSECustomerKey ( SSECustomerKey sseKey ) { if (  != null && this . sseAwsKeyManagementParams != null ) { throw new IllegalArgumentException ( "Either SSECustomerKey or SSEAwsKeyManagementParams must not be set at the same time." ) ; } this . destinationSSECustomerKey =  ; }<CODESPLIT>Sets the optional customer - provided server - side encryption key to use to encrypt the destination object being copied .
public void onFailure ( Throwable t ) {  . makeText ( this ,  . getMessage ( ) ,  ) . show ( ) ; }<CODESPLIT>show any error messages posted to the bus .
private void paintDropLines ( SeaGlassContext context , Graphics g ) { JTable . DropLocation  =  . getDropLocation ( ) ; if (  == null ) { return ; } Color  = ( Color )  . get (  , "Table.dropLineColor" ) ; Color  = ( Color )  . get (  , "Table.dropLineShortColor" ) ; if (  == null &&  == null ) { return ; } Rectangle  ;  = getHDropLineRect (  ) ; if (  != null ) { int  =  . x ; int  =  . width ; if (  != null ) { extendRect (  , true ) ;  . setColor (  ) ;  . fillRect (  . x ,  . y ,  . width ,  . height ) ; } if ( !  . isInsertColumn ( ) &&  != null ) {  . setColor (  ) ;  . fillRect (  ,  . y ,  ,  . height ) ; } }  = getVDropLineRect (  ) ; if (  != null ) { int  =  . y ; int  =  . height ; if (  != null ) { extendRect (  , false ) ;  . setColor (  ) ;  . fillRect (  . x ,  . y ,  . width ,  . height ) ; } if ( !  . isInsertRow ( ) &&  != null ) {  . setColor (  ) ;  . fillRect (  . x ,  ,  . width ,  ) ; } } }<CODESPLIT>Paint the drop lines if any .
public DatalogProgram createDatalog ( SWRLRule rule ) {  . accept ( this ) ; if (  ) {  . warn ( "Not Supported Translation of: " +  ) ;  . clear ( ) ; } DatalogProgram  =  . getDatalogProgram ( ) ;  . appendRule (  ) ; return  ; }<CODESPLIT>Translate the swrl_rule Return a datalog program containing the supported datalog facts
protected String inflateAuthnRequest ( final byte [ ] decodedBytes ) { val  =  . inflate (  ) ; if ( !  . isEmpty (  ) ) { return  ; } return  . decodeByteArrayToString (  ) ; }<CODESPLIT>Inflate authn request string .
public static FrameworkProjectConfig create ( final String name , final File propertyFile , final Properties properties , final IFilesystemFramework filesystemFramework ) { if ( !  . exists ( ) ) { generateProjectPropertiesFile (  ,  , false ,  , true ) ; } return create (  ,  ,  ) ; }<CODESPLIT>Create and generate file with the given properties if not null
static synchronized void clearLogContext ( ) { final LogContext  =  . LOG_CONTEXT ; final Configurator  =  . getLogger ( "" ) . detach (  . ATTACHMENT_KEY ) ; if (  instanceof PropertyConfigurator ) { final LogContextConfiguration  = ( ( PropertyConfigurator )  ) . getLogContextConfiguration ( ) ; clearLogContext (  ) ; } else if (  instanceof LogContextConfiguration ) { clearLogContext ( ( LogContextConfiguration )  ) ; } else { final List < String >  =  . list (  . getLoggerNames ( ) ) ; for ( String  :  ) { final Logger  =  . getLoggerIfExists (  ) ; if (  != null ) { final Handler [ ]  =  . clearHandlers ( ) ; if (  != null ) { for ( Handler  :  ) {  . close ( ) ; } }  . setFilter ( null ) ;  . setUseParentFilters ( false ) ;  . setUseParentHandlers ( true ) ;  . setLevel (  . INFO ) ; } } } }<CODESPLIT>Attempts to clear the global log context used for embedded servers .
public RestApiResponse execute ( long timeout , TimeUnit timeUnit ) { return  . blockForSingle (  . execute ( ) ,  ,  ) ; }<CODESPLIT>Executes the API request in a synchronous fashion using the given timeout .
public InputStream getInputStream ( HttpServletRequest request , MutableObject < byte [ ] > sourceMapResult ) throws IOException { byte [ ]  = this . bytes ; byte [ ]  = this . sourceMap ; String  = this . filename ; InputStream  = null ; if (  != null ) {  = new ByteArrayInputStream (  ) ; if (  != null &&  > 0 ) {  . setValue (  ) ; } } else if (  != null ) { ICacheManager  = ( ( IAggregator )  . getAttribute (  . AGGREGATOR_REQATTRNAME ) ) . getCacheManager ( ) ; File  = new File (  . getCacheDir ( ) ,  ) ; if (  == 0 ) {  = new FileInputStream (  ) ; } else { CacheData  ; ObjectInputStream  = new ObjectInputStream ( new FileInputStream (  ) ) ; try {  = ( CacheData )  . readObject ( ) ; } catch ( ClassNotFoundException e ) { throw new IOException (  . getMessage ( ) ,  ) ; } finally {  . closeQuietly (  ) ; }  =  . bytes ;  =  . sourceMap ; if (  != null ) {  . setValue (  ) ; }  = new ByteArrayInputStream (  ) ; } } else { throw new IOException ( ) ; } return  ; }<CODESPLIT>Return an input stream to the layer . Has side effect of setting the appropriate Content - Type Content - Length and Content - Encoding headers in the response .
public void cacheIncludeAndIgnore ( WebElement table ) { if ( getIgnoreByMatches ( ) == null ) { setIgnoreByMatches ( new ArrayList < WebElement > ( ) ) ; for ( By  : getIgnoreRowsMatching ( ) ) { getIgnoreByMatches ( ) . addAll (  . findElements (  ) ) ; } } if ( getIncludeByMatches ( ) == null ) { setIncludeByMatches ( new ArrayList < WebElement > ( ) ) ; for ( By  : getIncludeOnlyRowsMatching ( ) ) { getIncludeByMatches ( ) . addAll (  . findElements (  ) ) ; } } }<CODESPLIT>Does the table comparison
public < E > List < InlineDiffChunk < E > > inline ( List < E > previous , List < E > next ) { setError ( null ) ; try { return this . inlineDiffDisplayer . display ( this . diffManager . diff (  ,  , null ) ) ; } catch ( DiffException e ) { setError (  ) ; return null ; } }<CODESPLIT>Builds an in - line diff between two versions of a list of elements .
public static CompletableFuture < MessageSet > getMessagesAroundUntil ( TextChannel channel , Predicate < Message > condition , long around ) { CompletableFuture < MessageSet >  = new CompletableFuture < > ( ) ;  . getApi ( ) . getThreadPool ( ) . getExecutorService ( ) . submit ( ( ) -> { try { List < Message >  = new ArrayList < > ( ) ; Optional < Message >  = getMessagesAroundAsStream (  ,  ) . peek ( messages :: add ) . filter (  ) . findFirst ( ) ;  . complete ( new MessageSetImpl (  . map ( message ->  ) . orElse (  . emptyList ( ) ) ) ) ; } catch ( Throwable t ) {  . completeExceptionally (  ) ; } } ) ; return  ; }<CODESPLIT>Gets messages in the given channel around a given message in any channel until one that meets the given condition is found . If no message matches the condition an empty set is returned . The given message will be part of the result in addition to the messages around if it was sent in the given channel and is matched against the condition and will abort retrieval . Half of the messages will be older than the given message and half of the messages will be newer . If there aren t enough older or newer messages the halves will not be same - sized . It s also not guaranteed to be perfectly balanced .
public static boolean findSipApplicationAnnotation ( InputStream stream ) { try { byte [ ]  ;  = new byte [  . available ( ) ] ;  . read (  ) ; boolean  = contains (  ,  ) ; boolean  = contains (  ,  ) ; if (  &&  ) return true ; } catch ( Exception e ) { } return false ; }<CODESPLIT>Determine if this stream contains SipApplication annotations
protected Map < String , Object > buildJobDataMap ( final JmxCommand jmxCommand , final Object [ ] params ) throws MBeanException { final Map < String , Object >  = new HashMap < String , Object > ( ) ; try { int  = 0 ; for ( JmxOption  :  . getOptions ( ) ) {  . process (  ,  . valueOf (  [  ++ ] ) ) ; } for ( Argument  : this . remoteProgram . getArguments ( ) ) {  . setValueUsingParser (  . valueOf (  [  ++ ] ) ) ; } } catch ( Exception e ) { throw new MBeanException (  ) ; } return  ; }<CODESPLIT>Initialize the JobDataMap with the Program arguments
private void V ( StringBuilder buf ) { Token  = getNextToken ( ) ; if (  . tokenType !=  . VALUE ) { throw new IllegalStateException ( "Unexpected token " +  ) ; }  . append (  . getValue ( ) ) ;  = getNextToken ( ) ; if (  . tokenType ==  . EOL ) { return ; } else if (  . tokenType ==  . TRAILING_BACKSLASH ) { Vopt (  ) ; } }<CODESPLIT>Vopt = EOL V
public void addHeader ( final String sName , final String sValue ) { if (  != null ) _addHeader (  ,  ) ; }<CODESPLIT>Add the passed header as is .
public static < N extends Number > Number max ( List < N > numberList ) { return cal (  , DoubleStream :: max ) ; }<CODESPLIT>Max number .
public int getChaincodeActionResponseStatus ( ) throws InvalidArgumentException { if (  != - 1 ) { return  ; } try { final ProposalResponsePayloadDeserializer  = getProposalResponsePayloadDeserializer ( ) ;  =  . getExtension ( ) . getResponseStatus ( ) ; return  ; } catch ( InvalidArgumentException e ) { throw  ; } catch ( Exception e ) { throw new InvalidArgumentException (  ) ; } }<CODESPLIT>getChaincodeActionResponseStatus returns the what chaincode executions set as the return status .
public void generate ( Queue < Pair < Env < AttrContext > , JCClassDecl > > queue ) { generate (  , null ) ; }<CODESPLIT>Generates the source or class file for a list of classes . The decision to generate a source file or a class file is based upon the compiler s options . Generation stops if an error occurs while writing files .
public static EnhancedMimeType create ( final String primary , final String sub , final Charset encoding , final String version , final Map < String , String > parameters ) { try { return new EnhancedMimeType (  ,  ,  ,  ,  ) ; } catch ( final MimeTypeParseException ex ) { throw new RuntimeException ( "Failed to create versioned mime type: " +  + "/" +  ,  ) ; } }<CODESPLIT>Creates an instance with all data and exceptions wrapped to runtime exceptions .
public static long toLongWithDefault ( Object value , long defaultValue ) { Long  = toNullableLong (  ) ; return  != null ? ( long )  :  ; }<CODESPLIT>Converts value into integer or returns default when conversion is not possible .
public void setIsolation ( String iso ) throws JspTagException { if (  . equals (  ) ) {  =  . TRANSACTION_READ_COMMITTED ; } else if (  . equals (  ) ) {  =  . TRANSACTION_READ_UNCOMMITTED ; } else if (  . equals (  ) ) {  =  . TRANSACTION_REPEATABLE_READ ; } else if (  . equals (  ) ) {  =  . TRANSACTION_SERIALIZABLE ; } else { throw new JspTagException (  . getMessage ( "TRANSACTION_INVALID_ISOLATION" ) ) ; } }<CODESPLIT>Setter method for the transaction isolation level .
public void traverse ( Node root ) { try { initTraversal (  ) ;  =  ; pushScope (  ) ; traverseBranch (  , null ) ; popScope ( ) ; } catch ( Error | Exception unexpectedException ) { throwUnexpectedException (  ) ; } }<CODESPLIT>Traverses a parse tree recursively .
public CollectionRequest < Tag > findByWorkspace ( String workspace ) { String  =  . format ( "/workspaces/%s/tags" ,  ) ; return new CollectionRequest < Tag > ( this , Tag . class ,  , "GET" ) ; }<CODESPLIT>Returns the compact tag records for all tags in the workspace .
public Rule CriteriaOnlyFindQuery ( ) { return Sequence ( ! peek ( ) . isCliQuery ( ) , JsonParameter ( JsonObject ( ) ) , peek ( ) . setOperation (  . FIND ) , peek ( ) . setCriteria ( match ( ) ) ) ; }<CODESPLIT>A find query only given as criterion . Leave it to MongoDB s own parser to handle it .
private E unlinkLast ( Node < E > l ) { final E  =  . item ; final Node < E >  =  . prev ;  . item = null ;  . prev = null ;  =  ; if (  == null )  = null ; else  . next = null ;  -- ;  ++ ; return  ; }<CODESPLIT>Unlinks non - null last node l .
private static void setupSimpleSecurityProperties ( Hashtable < String , Object > env , String userDn , char [ ] pwd ) {  . put (  . SECURITY_AUTHENTICATION , "simple" ) ;  . put (  . SECURITY_PRINCIPAL ,  ) ;  . put (  . SECURITY_CREDENTIALS , new String (  ) ) ; }<CODESPLIT>Sets the environment properties needed for a simple username + password authenticated jndi connection .
public Team createTeam ( String name , String tag ) { return  . sendRpcAndWait (  , "createTeam" ,  ,  ) ; }<CODESPLIT>Create a new ranked team with the specified name and tag
private static void checkFilePattern ( String s ) throws ProblemException { Pattern  = null ; if (  . separatorChar == '\\' ) {  =  . compile ( "\\*?(.+\\\\)*.+" ) ; } else if (  . separatorChar == '/' ) {  =  . compile ( "\\*?(.+/)*.+" ) ; } else { throw new ProblemException ( "This platform uses the unsupported " +  . separatorChar + " as file separator character. Please add support for it!" ) ; } Matcher  =  . matcher (  ) ; if ( !  . matches ( ) ) { throw new ProblemException ( "The string \"" +  + "\" is not a proper file name." ) ; } }<CODESPLIT>Verify that a source file name is valid .
public void close ( ) throws Exception { for ( Entry < TransactionType , ShardingTransactionManager >  :  . entrySet ( ) ) {  . getValue ( ) . close ( ) ; } }<CODESPLIT>Close sharding transaction managers .
protected static String getBar ( long percentage ) { StringBuilder  = new StringBuilder ( ) ;  . append (  ) ;  . append ( "% [" ) ; for ( int  = 0 ;  < 100 ;  ++ ) { if (  == 100 ||  <  - 1 ) {  . append ( "=" ) ; } else if (  ==  - 1 ) {  . append ( ">" ) ; } else {  . append ( " " ) ; } }  . append ( "] " ) ; return  . toString ( ) ; }<CODESPLIT>Generates the progress bar for the given percentage
private void resolve ( T element , List < T > result ) { Set < T >  =  . get (  ) ; if (  != null ) { for ( T  :  ) { resolve (  ,  ) ; }  . remove (  ) ;  . add (  ) ; } }<CODESPLIT>Resolves an element .
public B camundaOut ( String source , String target ) { CamundaOut  =  . newInstance ( CamundaOut . class ) ;  . setCamundaSource (  ) ;  . setCamundaTarget (  ) ; addExtensionElement (  ) ; return  ; }<CODESPLIT>Sets a camunda out parameter to pass a variable from a sub process instance to the super process instance
Node createArgumentsReference ( ) { Node  =  . name ( "arguments" ) ; if ( isAddingTypes ( ) ) {  . setJSType (  . get ( ) ) ; } return  ; }<CODESPLIT>Creates a reference to arguments with the type specified in externs or unknown if the externs for it weren t included .
public Date toDate ( String dateString ) { Date  = null ; DateFormat  = new SimpleDateFormat ( "yyyy-MM-dd" ) ; try {  =  . parse (  ) ; } catch ( ParseException ex ) {  . out . println (  . fillInStackTrace ( ) ) ; } return  ; }<CODESPLIT>Takes a String and converts it to a Date
public static int cusolverRfSetNumericProperties ( cusolverRfHandle handle , double zero , double boost ) { return checkResult ( cusolverRfSetNumericPropertiesNative (  ,  ,  ) ) ; }<CODESPLIT>CUSOLVERRF set and get numeric properties
public static Object quoteIfString ( Object obj ) { return  instanceof String ? quote ( ( String )  ) :  ; }<CODESPLIT>Turn the given Object into a String with single quotes if it is a String ; keeping the Object as - is else .
public Deferred < Object > deleteUidAsync ( final String type , final String name ) { final UniqueIdType  =  . stringToUniqueIdType (  ) ; switch (  ) { case  : return  . deleteAsync (  ) ; case  : return  . deleteAsync (  ) ; case  : return  . deleteAsync (  ) ; default : throw new IllegalArgumentException ( "Unrecognized UID type: " +  ) ; } }<CODESPLIT>Attempts to delete the given UID name mapping from the storage table as well as the local cache .
public boolean scrollDownList ( int index ) { if (  . commandLogging ) {  . d (  . commandLoggingTag , "scrollDownList(" +  + ")" ) ; } return  . scrollList (  . waitForAndGetView (  , ListView . class ) ,  . DOWN , false ) ; }<CODESPLIT>Scrolls down a ListView matching the specified index .
protected void makeAnnotationTypeElementDoc ( MethodSymbol meth , TreePath treePath ) { AnnotationTypeElementDocImpl  = ( AnnotationTypeElementDocImpl )  . get (  ) ; if (  != null ) { if (  != null )  . setTreePath (  ) ; } else {  = new AnnotationTypeElementDocImpl ( this ,  ,  ) ;  . put (  ,  ) ; } }<CODESPLIT>Create the AnnotationTypeElementDoc for a MethodSymbol . Should be called only on symbols representing annotation type elements .
public Object call ( String method , Object ... arguments ) throws PickleException , PyroException , IOException { return internal_call (  , null , 0 , true ,  ) ; }<CODESPLIT>Call a method on the remote Pyro object this proxy is for .
public static String formatAsPercentage ( int value , int total ) { float  =  == 0 ? 0 : 1F *  /  ; return  . format (  ) ; }<CODESPLIT>Returns value converted to percentage format .
public static < T extends Geometry > JTSGeometryExpression < T > translate ( Expression < T > expr , float deltax , float deltay ) { return geometryOperation (  . getType ( ) ,  . TRANSLATE ,  ,  . create (  ) ,  . create (  ) ) ; }<CODESPLIT>Translates the geometry to a new location using the numeric parameters as offsets .
private static byte [ ] requestWebContent ( String url ) throws TVRageException { try { HttpGet  = new HttpGet (  ) ;  . addHeader ( "accept" , "application/xml" ) ; final DigestedResponse  =  . requestContent (  ,  ,  ) ; if (  . getStatusCode ( ) >= 500 ) { throw new TVRageException (  . HTTP_503_ERROR ,  ) ; } else if (  . getStatusCode ( ) >= 300 ) { throw new TVRageException (  . HTTP_404_ERROR ,  ) ; } return  . getContent ( ) . getBytes (  ) ; } catch ( IOException ex ) { throw new TVRageException (  . MAPPING_FAILED ,  ,  ,  ) ; } }<CODESPLIT>Get content from URL in byte array
private static boolean isNumeric ( String value ) { for ( char  :  . toCharArray ( ) ) { if ( !  . isDigit (  ) ) { return false ; } } return true ; }<CODESPLIT>Returns a boolean indicating whether the given string value is numeric .
@ RequestMapping ( method =  , value = "/foo" ) public Map < String , String > getFoo ( ) { final Map < String , String >  = new HashMap < > ( ) ;  . put ( "foo" , "bar" ) ; return  ; }<CODESPLIT>Controller to just support pinging .
protected static void fireArrayStartEvent ( JsonConfig jsonConfig ) { if (  . isEventTriggeringEnabled ( ) ) { for ( Iterator  =  . getJsonEventListeners ( ) . iterator ( ) ;  . hasNext ( ) ; ) { JsonEventListener  = ( JsonEventListener )  . next ( ) ; try {  . onArrayStart ( ) ; } catch ( RuntimeException e ) {  . warn (  ) ; } } } }<CODESPLIT>Fires a start of array event .
public static < E extends Exception > Runnable sneaked ( SneakyRunnable < E > runnable ) { return ( ) -> { @ SuppressWarnings ( "unchecked" ) SneakyRunnable < RuntimeException >  = ( SneakyRunnable < RuntimeException > )  ;  . run ( ) ; } ; }<CODESPLIT>Sneaky throws a Runnable lambda .
public static Domain update ( final BandwidthClient client , final String id , final Map < String , Object > params ) throws AppPlatformException , ParseException , IOException , Exception { assert (  != null &&  != null ) ; final String  =  . getUserResourceInstanceUri (  . DOMAINS_URI_PATH ,  ) ; final RestResponse  =  . post (  ,  ) ; final JSONObject  = toJSONObject (  . get (  , null ) ) ; return new Domain (  ,  ) ; }<CODESPLIT>Convenience method to return a Domain .
public static Stream < String > getResourceTypes ( final Event event ) { if (  instanceof org . modeshape . jcr . api . observation . Event ) { try { final org . modeshape . jcr . api . observation . Event  = ( org . modeshape . jcr . api . observation . Event )  ; final Stream . Builder < NodeType >  =  . builder ( ) ; for ( final NodeType  :  . getMixinNodeTypes ( ) ) {  . add (  ) ; }  . add (  . getPrimaryNodeType ( ) ) ; return  . build ( ) . map ( NodeType :: getName ) ; } catch ( final RepositoryException e ) { throw new RepositoryRuntimeException (  ) ; } } return empty ( ) ; }<CODESPLIT>Get the RDF Types of the resource corresponding to this JCR Event
private void processDefaultHeader ( ParserContext context ) { for ( String  :  . getFileLines ( ) ) { if ( hasHeaderSeparator (  ) ) { break ; } processHeaderLine (  ,  . getDocumentModel ( ) ) ; } }<CODESPLIT>Process the header of the file .
public Connection getConnection ( String url , String username , String password ) throws SQLException { boolean  = isConnectionAlive ( ) ; if ( !  ) { createConnection (  ,  ,  ) ; } return  ; }<CODESPLIT>Retrieves the connection object . If the connection doesnt exist or is dead it will attempt to create a new connection .
protected static final StringBuilder renderPad ( final StringBuilder builder , final int pad , final boolean newLine ) { renderNewLine (  ,  ) ; for ( int  = 0 ;  <  ;  ++ ) {  . append ( ' ' ) ; } return  ; }<CODESPLIT>Render some leading spaces onto a line of html .
public OvhAsyncTaskArray < OvhLine > eligibility_lines_active_POST ( OvhCity city , String contactName , OvhStreet street , String streetNumber ) throws IOException { String  = "/xdsl/eligibility/lines/active" ; StringBuilder  = path (  ) ; HashMap < String , Object >  = new HashMap < String , Object > ( ) ; addBody (  , "city" ,  ) ; addBody (  , "contactName" ,  ) ; addBody (  , "street" ,  ) ; addBody (  , "streetNumber" ,  ) ; String  = exec (  , "POST" ,  . toString ( ) ,  ) ; return convertTo (  ,  ) ; }<CODESPLIT>Get the active lines at given address
private static String evaluateExpressionStack ( final Deque < String > operators , final Deque < String > values ) { while ( !  . isEmpty ( ) ) {  . push ( getBooleanResultAsString (  . pop ( ) ,  . pop ( ) ,  . pop ( ) ) ) ; } return replaceIntegerStringByBooleanRepresentation (  . pop ( ) ) ; }<CODESPLIT>This method takes stacks of operators and values and evaluates possible expressions This is done by popping one operator and two values applying the operator to the values and pushing the result back onto the value stack
public int write ( byte [ ] buffer , int offset , int length , boolean isEnd ) throws IOException { int  ; long  =  ; if (  > 0 &&  <  . currentTime ( ) ) { close ( ) ; throw new ClientDisconnectException (  . l ( "{0}: request-timeout write exp={0}s" , addressRemote ( ) ,  . currentTime ( ) -  ) ) ; } synchronized (  ) { long  =  . getCurrentTimeActual ( ) ; long  =  +  ; do {  = writeNative (  ,  ,  ,  ) ; } while (  ==  . TIMEOUT_EXN &&  . getCurrentTimeActual ( ) <  ) ; } if (  ) { closeWrite ( ) ; } return  ; }<CODESPLIT>Writes to the socket .
public void setAmbientLight ( float r , float g , float b ) { float    = {  ,  ,  , 255 } ; normalize (  ) ;  . glEnable (  . GL_LIGHTING ) ;  . glEnable (  . GL_LIGHT0 ) ;  . glLightfv (  . GL_LIGHT0 ,  . GL_AMBIENT ,  , 0 ) ; }<CODESPLIT>Sets the RGB value of the ambientLight
BigInteger setMultiChoiceCount ( ) { if (  != null ) for ( int  = 0 ;  <  . length ;  ++ )  =  . multiply (  [  ] . setMultiChoiceCount ( ) ) ; return  ; }<CODESPLIT>Set the multiChoiceCount for this tuple
public void delete ( boolean forceDelete ) throws APIException { HttpResponse  =  . delete ( getUrl ( ) + "?force=" +  ) ;  . throwIfNotOk (  ) ; }<CODESPLIT>Creates this directory vi the Algorithmia Data API
protected void addNameToApplicationMap ( String name ) { String  = getApplicationName ( ) ; if (  == null ) return ; ConcurrentLinkedQueue < String >  =  . get (  ) ; if (  == null ) { ConcurrentLinkedQueue < String >  = new ConcurrentLinkedQueue < String > ( ) ;  =  . putIfAbsent (  ,  ) ; if (  == null )  =  ; }  . add (  ) ; }<CODESPLIT>Adds the metric name to an application map . This map is not a complete list of metrics owned by an application produced metrics are managed in the MetricsExtension
public static Envelope getTableEnvelope ( Connection connection , TableLocation location , String geometryField ) throws SQLException { if (  == null ||  . isEmpty ( ) ) { List < String >  = getGeometryFields (  ,  ) ; if (  . isEmpty ( ) ) { throw new SQLException ( "The table " +  + " does not contain a Geometry field, then the extent " + "cannot be computed" ) ; }  =  . get ( 0 ) ; } ResultSet  =  . createStatement ( ) . executeQuery ( "SELECT ST_Extent(" +  . quoteIdentifier (  ) + ") ext FROM " +  ) ; if (  . next ( ) ) { return ( ( Geometry )  . getObject ( 1 ) ) . getEnvelopeInternal ( ) ; } throw new SQLException ( "Unable to get the table extent it may be empty" ) ; }<CODESPLIT>Merge the bounding box of all geometries inside the provided table .
private void doListGet ( final Message < JsonObject > message ) { final String  =  . body ( ) . getString ( "name" ) ; if (  == null ) {  . reply ( new JsonObject ( ) . putString ( "status" , "error" ) . putString ( "message" , "No name specified." ) ) ; return ; } final Integer  =  . body ( ) . getInteger ( "index" ) ; if (  == null ) {  . reply ( new JsonObject ( ) . putString ( "status" , "error" ) . putString ( "message" , "No index specified." ) ) ; return ; }  . execute ( new Action < Object > ( ) { public Object perform ( ) { return  . getList ( formatKey (  ) ) . get (  ) ; } } , new Handler < AsyncResult < Object > > ( ) { public void handle ( AsyncResult < Object > result ) { if (  . failed ( ) ) {  . reply ( new JsonObject ( ) . putString ( "status" , "error" ) . putString ( "message" ,  . cause ( ) . getMessage ( ) ) ) ; } else {  . reply ( new JsonObject ( ) . putString ( "status" , "ok" ) . putValue ( "result" ,  . result ( ) ) ) ; } } } ) ; }<CODESPLIT>Handles a list get .
public static PlotCanvas plot ( String id , double [ ] data ) { Histogram  = new Histogram (  ) ;  . setID (  ) ; double [ ]  = {  . min (  ) , 0 } ; double [ ]  = {  . max (  ) , 0 } ; double [ ] [ ]  =  . getHistogram ( ) ; for ( int  = 0 ;  <  . length ;  ++ ) { if (  [  ] [ 1 ] >  [ 1 ] ) {  [ 1 ] =  [  ] [ 1 ] ; } } PlotCanvas  = new PlotCanvas (  ,  ) ;  . getAxis ( 0 ) . setGridVisible ( false ) ;  . add (  ) ; return  ; }<CODESPLIT>Create a plot canvas with the histogram plot .
public static Pair < List < Tuple > , List < Tuple > > splitData ( final List < Tuple > trainingData , double proportion ) { if (  < 0 ||  > 1 ) { throw new RuntimeException ( "Proportion should between 0.0 - 1.0" ) ; } if (  > 0.5 ) {  = 1 -  ; } List < Tuple >  = new ArrayList < > ( ) ; List < Tuple >  = new ArrayList < > ( ) ; int  = ( int )  . floor (  *  . size ( ) ) ; int  = 0 ; Set < Integer >  = new HashSet < > ( ) ; while (  <  &&  . size ( ) >  . size ( ) ) { int  = ( int ) (  . random ( ) * (  . size ( ) - 1 ) ) ; while (  . contains (  ) ) {  = ( int ) (  . random ( ) * (  . size ( ) - 1 ) ) ; }  . add (  ) ;  ++ ; }  . addAll (  . stream ( ) . map ( trainingData :: get ) . collect (  . toList ( ) ) ) ;  . range ( 0 ,  . size ( ) ) . filter ( x -> !  . contains (  ) ) . forEach ( i ->  . add (  . get (  ) ) ) ; return new ImmutablePair < > (  ,  ) ; }<CODESPLIT>Shuffle the data and split by proportion
public static void getScreenShotABGR ( ByteBuffer bgraBuf , BufferedImage out ) { WritableRaster  =  . getRaster ( ) ; DataBufferByte  = ( DataBufferByte )  . getDataBuffer ( ) ; byte [ ]  =  . getData ( ) ;  . clear ( ) ;  . get (  ) ;  . clear ( ) ; int  =  . getWidth ( ) ; int  =  . getHeight ( ) ; for ( int  = 0 ;  <  / 2 ;  ++ ) { for ( int  = 0 ;  <  ;  ++ ) { int  = (  *  +  ) * 4 ; int  = ( (  -  - 1 ) *  +  ) * 4 ; byte  =  [  + 0 ] ; byte  =  [  + 1 ] ; byte  =  [  + 2 ] ; byte  =  [  + 3 ] ; byte  =  [  + 0 ] ; byte  =  [  + 1 ] ; byte  =  [  + 2 ] ; byte  =  [  + 3 ] ;  [  + 0 ] =  ;  [  + 1 ] =  ;  [  + 2 ] =  ;  [  + 3 ] =  ;  [  + 0 ] =  ;  [  + 1 ] =  ;  [  + 2 ] =  ;  [  + 3 ] =  ; } } }<CODESPLIT>Good format for java swing .
public Pair < int [ ] [ ] [ ] , int [ ] > documentToDataAndLabels ( List < IN > document ) { int  =  . size ( ) ; int [ ] [ ] [ ]  = new int [  ] [  ] [ ] ; int [ ]  = new int [  ] ; if (  . useReverse ) {  . reverse (  ) ; } for ( int  = 0 ;  <  ;  ++ ) { CRFDatum < List < String > , CRFLabel >  = makeDatum (  ,  ,  ) ; List < List < String > >  =  . asFeatures ( ) ; for ( int  = 0 ,  =  . size ( ) ;  <  ;  ++ ) { Collection < String >  =  . get (  ) ;  [  ] [  ] = new int [  . size ( ) ] ; int  = 0 ; for ( String  :  ) { int  =  . indexOf (  ) ; if (  >= 0 ) {  [  ] [  ] [  ] =  ;  ++ ; } else { } } if (  <  [  ] [  ] . length ) { int [ ]  = new int [  ] ;  . arraycopy (  [  ] [  ] , 0 ,  , 0 ,  ) ;  [  ] [  ] =  ; } } IN  =  . get (  ) ;  [  ] =  . indexOf (  . get ( AnswerAnnotation . class ) ) ; } if (  . useReverse ) {  . reverse (  ) ; } return new Pair < int [ ] [ ] [ ] , int [ ] > (  ,  ) ; }<CODESPLIT>Convert a document List into arrays storing the data features and labels .
public static synchronized List < Class < ? > > locateAll ( final String serviceName ) { if (  == null ) { throw new IllegalArgumentException ( "serviceName cannot be null" ) ; } List < Class < ? > >  = new ArrayList < Class < ? > > ( ) ; if (  != null ) { List < Callable < Class < ? > > >  =  . get (  ) ; if (  != null ) { for ( Callable < Class < ? > >  :  ) { try {  . add (  . call ( ) ) ; } catch ( Exception e ) { } } } } return  ; }<CODESPLIT>Finds all providers for the given service .
String decodeCString ( ByteBuf buffer ) throws IOException { int  =  . bytesBefore (  . STRING_TERMINATION ) ; if (  < 0 ) throw new IOException ( "string termination not found" ) ; String  =  . toString (  . readerIndex ( ) ,  ,  . UTF_8 ) ;  . skipBytes (  + 1 ) ; return  ; }<CODESPLIT>default visibility for unit test
public void addCase ( JMFType theCase ) { if (  == null ) throw new NullPointerException ( "Variant case cannot be null" ) ; JSType  = ( JSType )  ; if (  == null )  = new JSType [ 1 ] ; else { JSType [ ]  =  ;  = new JSType [  . length + 1 ] ;  . arraycopy (  , 0 ,  , 0 ,  . length ) ; }  . parent = this ;  . siblingPosition =  . length - 1 ;  [  . siblingPosition ] =  ; }<CODESPLIT>Add a case to the variant . Note that every variant must have at least one case .
public String summarizeState ( ) { StringBuilder  = new StringBuilder ( ) ;  . append ( "clipVol=" ) . append (  ) ;  . append ( ", disabled=[" ) ; int  = 0 ; for ( SoundType  :  ) { if (  ++ > 0 ) {  . append ( ", " ) ; }  . append (  ) ; } return  . append ( "]" ) . toString ( ) ; }<CODESPLIT>Returns a string summarizing our volume settings and disabled sound types .
private Map < String , String > getCustomMap ( Pattern keyPattern ) { Map < String , String >  = new HashMap < > ( ) ; for ( Iterator < Object >  =  . keySet ( ) . iterator ( ) ;  . hasNext ( ) ; ) { String  = ( String )  . next ( ) ; Matcher  =  . matcher (  ) ; if (  . matches ( ) ) { String  =  . group ( 2 ) ; String  =  . getProperty (  ) ;  . put (  ,  ) ; } } return  ; }<CODESPLIT>Returns the map where the key is the 2 group of the pattern and the value is the property value
public static long rawUncompress ( long inputAddr , long inputSize , long destAddr ) throws IOException { return  . rawUncompress (  ,  ,  ) ; }<CODESPLIT>Zero - copy decompress using memory addresses .
public void write ( byte [ ] b , int off , int len ) { this . checkIncreaseArray (  ) ;  . arraycopy (  ,  , this . buffer , this . pos ,  ) ; this . pos +=  ; }<CODESPLIT>Writes a byte array content into the stream
public final Operation patchHealthCheck ( ProjectGlobalHealthCheckName healthCheck , HealthCheck healthCheckResource , List < String > fieldMask ) { PatchHealthCheckHttpRequest  =  . newBuilder ( ) . setHealthCheck (  == null ? null :  . toString ( ) ) . setHealthCheckResource (  ) . addAllFieldMask (  ) . build ( ) ; return patchHealthCheck (  ) ; }<CODESPLIT>Updates a HealthCheck resource in the specified project using the data included in the request . This method supports PATCH semantics and uses the JSON merge patch format and processing rules .
private void initializeNoxItemMargin ( TypedArray attributes ) { float  = getResources ( ) . getDimension (  . dimen . default_nox_item_margin ) ; float  =  . getDimension (  . styleable . nox_item_margin ,  ) ;  . setNoxItemMargin (  ) ; }<CODESPLIT>Configures the nox item default margin used in NoxConfig Shape and NoxItemCatalog to draw nox item instances during the onDraw execution .
public static OperationResult failed ( long index , long eventIndex , Throwable error ) { return new OperationResult (  ,  ,  , null ) ; }<CODESPLIT>Returns a failed operation result .
public static InsnList ifIntegersEqual ( InsnList lhs , InsnList rhs , InsnList action ) {  . notNull (  ) ;  . notNull (  ) ;  . notNull (  ) ; InsnList  = new InsnList ( ) ; LabelNode  = new LabelNode ( ) ;  . add (  ) ;  . add (  ) ;  . add ( new JumpInsnNode (  . IF_ICMPNE ,  ) ) ;  . add (  ) ;  . add (  ) ; return  ; }<CODESPLIT>Compares two integers and performs some action if the integers are equal .
public static FormatOptions of ( int flags , int width , int precision ) { if ( ! checkFlagConsistency (  ,  !=  ) ) { throw new IllegalArgumentException ( "invalid flags: 0x" +  . toHexString (  ) ) ; } if ( (  < 1 ||  >  ) &&  !=  ) { throw new IllegalArgumentException ( "invalid width: " +  ) ; } if ( (  < 0 ||  >  ) &&  !=  ) { throw new IllegalArgumentException ( "invalid precision: " +  ) ; } return new FormatOptions (  ,  ,  ) ; }<CODESPLIT>Creates a options instance with the given values .
public void tripleClick ( Coordinates where ) { Point  = getPoint (  , "triple click" ) ;  . mouseAction (  . x ,  . y , 3 ,  . LEFT ) ; }<CODESPLIT>Triple click is an Opera specific way of selecting a sentence .
private void initializeNoxItemPlaceholder ( TypedArray attributes ) { Drawable  =  . getDrawable (  . styleable . nox_item_placeholder ) ; if (  == null ) {  = getContext ( ) . getResources ( ) . getDrawable (  . drawable . ic_nox ) ; }  . setPlaceholder (  ) ; }<CODESPLIT>Configures the placeholder used if there is no another placeholder configured in the NoxItem instances during the onDraw execution .
public void pruneInvalidOptional ( DependencyExplorerOutput output , InvalidKeys invalidKeys ) { DependencyGraph . GraphPruner  = new DependencyGraph . GraphPruner (  . getGraph ( ) ) ; for ( Key < ? >  :  . getInvalidOptionalKeys ( ) ) {  . remove (  ) ;  . removeBinding (  ) ; }  . setGraph (  . update ( ) ) ; }<CODESPLIT>Prune all of the invalid optional keys from the graph . After this method all of the keys remaining in the graph are resolvable .
private PersistentResourceXMLDescription getSimpleMapperParser ( ) { if (  . equals (  . VERSION_1_0 ) ) { return  ; } else if (  . equals (  . VERSION_1_1 ) ) { return  ; } return  ; }<CODESPLIT>1 . 0 version of parser is different at simple mapperParser
public String getAbsoluteTemplateURI ( String templateName , boolean includeExtension ) { FastStringWriter  = new FastStringWriter ( ) ; String  =  . substring ( 1 ,  . length ( ) ) ; if (  . indexOf (  ) > - 1 ) {  . append (  ) ; int  =  . lastIndexOf (  ) ;  . append (  . substring ( 0 ,  ) ) ;  . append (  ) ;  . append (  . substring (  + 1 ,  . length ( ) ) ) ; } else {  . append (  ) ;  . append (  . substring ( 1 ,  . length ( ) ) ) ; } if (  ) {  . append (  ) ; } String  =  . toString ( ) ;  . close ( ) ; return  ; }<CODESPLIT>Used to resolve template names that are not relative to a controller .
protected void scanResourcePaths ( String startPath ) throws IOException , SAXException { Set < String >  =  . getResourcePaths (  ) ; if (  != null ) { for ( String  :  ) { if (  . startsWith ( "/WEB-INF/classes/" ) ) { } else if (  . startsWith ( "/WEB-INF/lib/" ) ) { } else if (  . endsWith ( "/" ) ) { scanResourcePaths (  ) ; } else if (  . startsWith ( "/WEB-INF/tags/" ) ) { if (  . endsWith ( "/implicit.tld" ) ) { parseTld (  ) ; } } else if (  . endsWith (  ) ) { parseTld (  ) ; } } } }<CODESPLIT>Scan web application resources for TLDs recursively .
protected boolean duringDrag ( SVGPoint startPoint , SVGPoint dragPoint , Event evt , boolean inside ) { if (  != null ) { return  . duringDrag (  ,  ,  ,  ) ; } return true ; }<CODESPLIT>Method called during drags .
private PGPKeyRingGenerator createKeyRingGenerator ( String userId , String password , int keySize ) {  . trace ( "createKeyRingGenerator(String, String, int)" ) ;  . trace ( "User ID: {}, Password: {}, Key Size: {}" ,  ,  == null ? "not set" : "********" ,  ) ; PGPKeyRingGenerator  = null ; try {  . debug ( "Creating RSA key pair generator" ) ; RSAKeyPairGenerator  = new RSAKeyPairGenerator ( ) ;  . init ( new RSAKeyGenerationParameters (  . valueOf ( 0x10001 ) , getSecureRandom ( ) ,  , 12 ) ) ;  . debug ( "Generating Signing Key Pair" ) ; BcPGPKeyPair  = new BcPGPKeyPair (  . RSA_SIGN ,  . generateKeyPair ( ) , new Date ( ) ) ;  . debug ( "Generating Encyption Key Pair" ) ; BcPGPKeyPair  = new BcPGPKeyPair (  . RSA_ENCRYPT ,  . generateKeyPair ( ) , new Date ( ) ) ;  . debug ( "Generating Signature Key Properties" ) ; PGPSignatureSubpacketGenerator  = new PGPSignatureSubpacketGenerator ( ) ;  . setKeyFlags ( false ,  . SIGN_DATA |  . CERTIFY_OTHER ) ;  . setPreferredSymmetricAlgorithms ( false , getPreferredEncryptionAlgorithms ( ) ) ;  . setPreferredHashAlgorithms ( false , getPreferredHashingAlgorithms ( ) ) ;  . setPreferredCompressionAlgorithms ( false , getPreferredCompressionAlgorithms ( ) ) ;  . debug ( "Generating Encyption Key Properties" ) ; PGPSignatureSubpacketGenerator  = new PGPSignatureSubpacketGenerator ( ) ;  . setKeyFlags ( false ,  . ENCRYPT_COMMS |  . ENCRYPT_STORAGE ) ;  . info ( "Creating PGP Key Ring Generator" ) ;  = new PGPKeyRingGenerator (  . RSA_SIGN ,  ,  , new BcPGPDigestCalculatorProvider ( ) . get (  . SHA1 ) ,  . generate ( ) , null , new BcPGPContentSignerBuilder (  . RSA_SIGN ,  . SHA256 ) , new BcPBESecretKeyEncryptorBuilder ( getEncryptionAlgorithm ( ) ) . build (  . toCharArray ( ) ) ) ;  . addSubKey (  ,  . generate ( ) , null ) ; } catch ( PGPException e ) {  . error ( "{}" ,  . getMessage ( ) ) ;  = null ; } return  ; }<CODESPLIT>creates and initializes a PGP Key Ring Generator
public static Date getDateFromString ( final String dateString , final String pattern ) { try { SimpleDateFormat  = buildDateFormat (  ) ; return  . parse (  ) ; } catch ( ParseException e ) { throw new DateException (  . format ( "Could not parse %s with pattern %s." ,  ,  ) ,  ) ; } }<CODESPLIT>Get data from data string using the given pattern and the default date format symbols for the default locale .
public Object remove ( Object key ) { synchronized (  ) { if ( !  . containsKey (  ) && !  . containsKey (  ) ) { return null ; } Object  ; Map  ; synchronized (  ) {  =  . merge (  ,  ) ;  =  . remove (  ) ; }  =  ;  . clear ( ) ;  = 0 ; return  ; } }<CODESPLIT>This operation is very expensive . A full copy of the Map is created
private String getItemType ( Cmdb cmdb ) { String  = null ; String  =  . getConfigurationItemSubType ( ) ; String  =  . getConfigurationItemType ( ) ; String  =  . getAppSubType ( ) ; String  =  . getAppType ( ) ; boolean  = false ; boolean  = false ; if ( ! "" . equals (  ) ) {  = true ; } if ( ! "" . equals (  ) ) {  = true ; } if ( !  &&  ) { if (  != null &&  . equals (  . getAppSubType ( ) ) ) {  =  ; } else if (  != null &&  . equals (  . getCompSubType ( ) ) ) {  =  ; } else if (  != null &&  . equals (  . getEnvSubType ( ) ) ) {  =  ; } } else if (  && !  ) { if (  != null &&  . equals (  . getAppType ( ) ) ) {  =  ; } else if (  != null &&  . equals (  . getCompType ( ) ) ) {  =  ; } else if (  != null &&  . equals (  . getEnvType ( ) ) ) {  =  ; } } else { if (  != null &&  . equals (  . getAppSubType ( ) ) &&  != null &&  . equals (  . getAppType ( ) ) ) {  =  ; } else if (  != null &&  . equals (  . getCompSubType ( ) ) &&  != null &&  . equals (  . getCompType ( ) ) ) {  =  ; } else if (  != null &&  . equals (  . getEnvSubType ( ) ) &&  != null &&  . equals (  . getEnvType ( ) ) ) {  =  ; } } return  ; }<CODESPLIT>Returns the type of the configuration item .
public void readXML ( final List < String > _tags , final Map < String , String > _attributes , final String _text ) throws SAXException , EFapsException { if (  . size ( ) == 1 ) { final String  =  . get ( 0 ) ; if ( "uuid" . equals (  ) ) { this . uuid =  ; } else if ( "file-application" . equals (  ) ) { this . fileApplication =  ; } else if ( "definition" . equals (  ) ) { this . definitions . add ( newDefinition ( ) ) ; } } else if ( "definition" . equals (  . get ( 0 ) ) ) { final AbstractDefinition  = this . definitions . get ( this . definitions . size ( ) - 1 ) ;  . readXML (  . subList ( 1 ,  . size ( ) ) ,  ,  ) ; } else { throw new SAXException ( "Unknown XML Tag: " +  + " for: " + this . installFile ) ; } }<CODESPLIT>Read event for given tags path with attributes and text .
public String getSQLUpdate ( boolean bUseCurrentValues ) { String  = this . getBaseRecord ( ) . makeTableNames ( false ) ; KeyArea  = this . getBaseRecord ( ) . getKeyArea ( 0 ) ; boolean  =  ? true :  . isNull (  . TEMP_KEY_AREA , true ) ; boolean  = this . getBaseRecord ( ) . isQueryRecord ( ) ; String  =  . addSelectParams ( "=" ,  . TEMP_KEY_AREA , false ,  ,  , null , true , true ) ; if (  . length ( ) > 0 )  = " WHERE " +  ; String  = this . getBaseRecord ( ) . getSQLFields (  . SQL_UPDATE_TYPE ,  ) ; if (  . length ( ) == 0 ) return null ;  = "UPDATE " +  + " SET " +  +  ; return  ; }<CODESPLIT>Get the SQL Update string . UPDATE table SET field1 = value1 field2 = value2 WHERE key = value
public static synchronized void verify ( Object ... objects ) { for ( Object  :  ) { if (  instanceof Class < ? > ) { verifyClass ( ( Class < ? > )  ) ; } else { EasyMockMethodInvocationControl  = ( EasyMockMethodInvocationControl )  . getInstanceMethodInvocationControl (  ) ; if (  != null ) {  . verify ( ) ; } else { if ( isNiceReplayAndVerifyMode ( ) && ! isEasyMocked (  ) ) { } else { try {  . easymock . EasyMock . verify (  ) ; } catch ( RuntimeException e ) { throw new RuntimeException (  + " is not a mock object" ,  ) ; } } } } } }<CODESPLIT>Switches the mocks or classes to verify mode . Note that you must use this method when using PowerMock!
public void mapTileRequestFailed ( final MapTileRequestState pState ) { if (  != null ) { putTileIntoCache (  . getMapTile ( ) ,  ,  . NOT_FOUND ) ; for ( final Handler  :  ) { if (  != null ) {  . sendEmptyMessage (  ) ; } } } else { for ( final Handler  :  ) { if (  != null ) {  . sendEmptyMessage (  ) ; } } } if (  . getInstance ( ) . isDebugTileProviders ( ) ) {  . d (  . LOGTAG , "MapTileProviderBase.mapTileRequestFailed(): " +  . toString (  . getMapTile ( ) ) ) ; } }<CODESPLIT>Called by implementation class methods indicating that they have failed to retrieve the requested map tile . a MAPTILE_FAIL_ID message is sent .
static void validateFactoryAndClass ( FieldDefinition fd , int factoryId , int classId , String fullPath ) { if (  !=  . getFactoryId ( ) ) { throw new IllegalArgumentException ( "Invalid factoryId! Expected: " +  . getFactoryId ( ) + ", Current: " +  + " in path " +  ) ; } if (  !=  . getClassId ( ) ) { throw new IllegalArgumentException ( "Invalid classId! Expected: " +  . getClassId ( ) + ", Current: " +  + " in path " +  ) ; } }<CODESPLIT>Validates if the given factoryId and classId match the ones from the fieldDefinition
public static String getLabelFor ( InputComponent < ? , ? > input , boolean addColon ) { String  =  . getLabel ( ) ; if (  == null ) {  =  . getName ( ) ; } if (  && !  . endsWith (  ) ) {  +=  ; } return  ; }<CODESPLIT>Returns the label for this component
protected final View inflatePlaceholderView ( final View convertView , final int height ) { View  =  ; if ( ! (  instanceof PlaceholderView ) ) {  = new PlaceholderView ( getContext ( ) ) ; }  . setMinimumHeight (  ) ; return  ; }<CODESPLIT>Inflates an invisible placeholder view with a specific height .
public void stopService ( ) throws Exception {  . info (  , "stopService" , "Stopping LdapServer" ) ; this . server . stop ( ) ;  . info (  , "stopService" , "Stopping DirectoryService" ) ;  . shutdown ( ) ;  . info (  , "stopService" , "Ldap stopped." ) ; }<CODESPLIT>Stop the LdapServer and the Directory service . Use for JUnit teardown . If the service is not stopped then future instances with the same name cannot clean up the file directory .
public void setCacheMinutes ( int iMinutes ) { if (  == - 1 )  =  ;  =  ; if (  == 0 ) { if (  != null ) {  . cancel ( ) ;  = null ; this . stopCache ( ) ; } } else { if (  != null ) {  . cancel ( ) ; } this . startCache ( ) ;  = new DBTimerTask ( ) ;  = new java . util . Timer ( ) ;  . schedule (  ,  * 60 * 1000 ) ; } }<CODESPLIT>This will set this database to start caching records until they haven t been used for iMinutes minutes .
protected void propagateOnEnter ( GVRPickedObject hit ) { GVRSceneObject  =  . getHitObject ( ) ; GVREventManager  = getGVRContext ( ) . getEventManager ( ) ; if (  . contains (  . SEND_TOUCH_EVENTS ) ) { if (  . contains (  . SEND_TO_LISTENERS ) ) {  . sendEvent ( this , ITouchEvents . class , "onEnter" ,  ,  ) ; } if (  . contains (  . SEND_TO_HIT_OBJECT ) ) {  . sendEvent (  , ITouchEvents . class , "onEnter" ,  ,  ) ; } if (  . contains (  . SEND_TO_SCENE ) && (  != null ) ) {  . sendEvent (  , ITouchEvents . class , "onEnter" ,  ,  ) ; } } if (  . contains (  . SEND_PICK_EVENTS ) ) { if (  . contains (  . SEND_TO_LISTENERS ) ) {  . sendEvent ( this , IPickEvents . class , "onEnter" ,  ,  ) ; } if (  . contains (  . SEND_TO_HIT_OBJECT ) ) {  . sendEvent (  , IPickEvents . class , "onEnter" ,  ,  ) ; } if (  . contains (  . SEND_TO_SCENE ) && (  != null ) ) {  . sendEvent (  , IPickEvents . class , "onEnter" ,  ,  ) ; } } }<CODESPLIT>Propagate onEnter events to listeners
public java . util . concurrent . Future < GetSendQuotaResult > getSendQuotaAsync ( com . amazonaws . handlers . AsyncHandler < GetSendQuotaRequest , GetSendQuotaResult > asyncHandler ) { return getSendQuotaAsync ( new GetSendQuotaRequest ( ) ,  ) ; }<CODESPLIT>Simplified method form for invoking the GetSendQuota operation with an AsyncHandler .
public short shortValue ( ) throws OtpErlangRangeException { final long  = longValue ( ) ; final short  = ( short )  ; if (  !=  ) { throw new OtpErlangRangeException ( "Value too large for short: " +  ) ; } return  ; }<CODESPLIT>Get this number as a short .
private MjdbcSQLException translateSQLStatePrefix ( String reason , String SQLState , int vendorCode , SQLException cause ) { MjdbcSQLException  = null ; String  = getSqlState (  ) ; String  = null ; if (  != null &&  . length ( ) >= 2 ) {  =  . substring ( 0 , 2 ) ; if (  . SQL_STATE_PREFIX_BAD_SQL_GRAMMAR . contains (  ) == true ) {  = new BadSqlGrammarException (  ,  ,  ) ; } else if (  . SQL_STATE_PREFIX_DATA_INTEGRITY_VIOLATION . contains (  ) == true ) {  = new DataIntegrityViolationException (  ,  ,  ) ; } else if (  . SQL_STATE_PREFIX_DATA_ACCESS_RESOURCE_FAILURE . contains (  ) == true ) {  = new DataAccessResourceFailureException (  ,  ,  ) ; } else if (  . SQL_STATE_PREFIX_TRANSIENT_DATA_ACCESS_RESOURCE_EXCEPTION . contains (  ) == true ) {  = new TransientDataAccessResourceException (  ,  ,  ) ; } else if (  . SQL_STATE_PREFIX_CONCURRENCY_FAILURE . contains (  ) == true ) {  = new ConcurrencyFailureException (  ,  ,  ) ; } } return  ; }<CODESPLIT>Checks SQL state and tries to convert it into Spring SQL Exception . This implementation is vendor free .
public boolean matches ( String name ) { if (  == null ) { return  . equals ( "" ) ; } if (  != null ) { return  . equals (  ) ; } if (  != null ) { return  . contains (  ) ; } if (  != null && !  . startsWith (  ) ) { return false ; } return  == null ||  . endsWith (  ) ; }<CODESPLIT>Checks if Simon name matches this pattern .
public static nslimitselector get ( nitro_service service , String selectorname ) throws Exception { nslimitselector  = new nslimitselector ( ) ;  . set_selectorname (  ) ; nslimitselector  = ( nslimitselector )  . get_resource (  ) ; return  ; }<CODESPLIT>Use this API to fetch nslimitselector resource of given name .
public static int solveQuad ( double [ ] eqn , double [ ] res ) { double  =  [ 2 ] ; double  =  [ 1 ] ; double  =  [ 0 ] ; int  = 0 ; if (  == 0f ) { if (  == 0f ) { return - 1 ; }  [  ++ ] = -  /  ; } else { double  =  *  - 4f *  *  ; if (  < 0f ) { return 0 ; }  =  . sqrt (  ) ;  [  ++ ] = ( -  +  ) / (  * 2f ) ; if (  != 0f ) {  [  ++ ] = ( -  -  ) / (  * 2f ) ; } } return fixRoots (  ,  ) ; }<CODESPLIT>Solves quadratic equation
public Set < Term > getAllTerms ( ) { final Set < Term >  = new HashSet < Term > ( ) ; for ( final StatementGroup  :  ) { for ( final Statement  :  . getAllStatements ( ) ) {  . addAll (  . getAllTerms ( ) ) ; } } return  ; }<CODESPLIT>Returns the set of all terms contained within the document .
public void cancelCopy ( CopyOperationImpl op ) throws SQLException { if ( ! hasLock (  ) ) { throw new PSQLException (  . tr ( "Tried to cancel an inactive copy operation" ) ,  . OBJECT_NOT_IN_STATE ) ; } SQLException  = null ; int  = 0 ; try { if (  instanceof CopyIn ) { synchronized ( this ) {  . log (  . FINEST , "FE => CopyFail" ) ; final byte [ ]  =  . encodeUTF8 ( "Copy cancel requested" ) ;  . sendChar ( 'f' ) ;  . sendInteger4 ( 5 +  . length ) ;  . send (  ) ;  . sendChar ( 0 ) ;  . flush ( ) ; do { try { processCopyResults (  , true ) ; } catch ( SQLException se ) {  ++ ; if (  != null ) { SQLException  =  ; SQLException  ; while ( (  =  . getNextException ( ) ) != null ) {  =  ; }  . setNextException (  ) ; }  =  ; } } while ( hasLock (  ) ) ; } } else if (  instanceof CopyOut ) { sendQueryCancel ( ) ; } } catch ( IOException ioe ) { throw new PSQLException (  . tr ( "Database connection failed when canceling copy operation" ) ,  . CONNECTION_FAILURE ,  ) ; } finally { synchronized ( this ) { if ( hasLock (  ) ) { unlock (  ) ; } } } if (  instanceof CopyIn ) { if (  < 1 ) { throw new PSQLException (  . tr ( "Missing expected error response to copy cancel request" ) ,  . COMMUNICATION_ERROR ) ; } else if (  > 1 ) { throw new PSQLException (  . tr ( "Got {0} error responses to single copy cancel request" ,  . valueOf (  ) ) ,  . COMMUNICATION_ERROR ,  ) ; } } }<CODESPLIT>Finishes a copy operation and unlocks connection discarding any exchanged data .
public com . google . api . ads . adwords . axis . v201809 . o . AttributeType [ ] getRequestedAttributeTypes ( ) { return  ; }<CODESPLIT>Gets the requestedAttributeTypes value for this TargetingIdeaSelector .
public void setRange ( Annotation v ) { if (  . featOkTst && ( ( OntRelationMention_Type )  ) . casFeat_range == null )  . jcas . throwFeatMissing ( "range" , "de.julielab.jules.types.OntRelationMention" ) ;  . ll_cas . ll_setRefValue (  , ( ( OntRelationMention_Type )  ) . casFeatCode_range ,  . ll_cas . ll_getFSRef (  ) ) ; }<CODESPLIT>setter for range - sets
public List < com . ibm . wsspi . security . wim . model . RolePlayer > getRelatedRolePlayer ( ) { if (  == null ) {  = new ArrayList < com . ibm . wsspi . security . wim . model . RolePlayer > ( ) ; } return this . relatedRolePlayer ; }<CODESPLIT>Gets the value of the relatedRolePlayer property .
public JCExpression getUnderlyingBinding ( Unifier unifier ) { return (  == null ) ? null :  . getBinding ( new UFreeIdent . Key ( identifier ( ) ) ) ; }<CODESPLIT>Gets the binding of the underlying identifier in the unifier .
public void clearCache ( ) {  . clearCache ( CommercePriceEntryImpl . class ) ;  . clearCache (  ) ;  . clearCache (  ) ;  . clearCache (  ) ; }<CODESPLIT>Clears the cache for all commerce price entries .
private int computeCapacity ( int initial ) { if (  <  ) { return  ; } if (  >  ) { return  ; } int  = 1 ; while (  <  ) {  <<= 1 ; } return  ; }<CODESPLIT>Compute capacity given initial capacity .
public V get ( K k , long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException { await (  ,  ,  ) ; return  . get (  ) ; }<CODESPLIT>Retrieve the value associated with the given key blocking as long as necessary up to the specified maximum .
public static void setupClasspath ( final Path distributedClassPath , final Path intermediateClassPath , final Job job ) throws IOException { String  =  . getProperty ( "druid.hadoop.internal.classpath" ) ; if (  == null ) {  =  . getProperty ( "java.class.path" ) ; } String [ ]  =  . split (  . pathSeparator ) ; final Configuration  =  . getConfiguration ( ) ; final FileSystem  =  . getFileSystem (  ) ; if (  instanceof LocalFileSystem ) { return ; } for ( String  :  ) { final File  = new File (  ) ; if (  . getName ( ) . endsWith ( ".jar" ) ) { try {  . retry ( ( ) -> { if ( isSnapshot (  ) ) { addSnapshotJarToClassPath (  ,  ,  ,  ) ; } else { addJarToClassPath (  ,  ,  ,  ,  ) ; } return true ; } , shouldRetryPredicate ( ) ,  ) ; } catch ( Exception e ) { throw new RuntimeException (  ) ; } } } }<CODESPLIT>Uploads jar files to hdfs and configures the classpath . Snapshot jar files are uploaded to intermediateClasspath and not shared across multiple jobs . Non - Snapshot jar files are uploaded to a distributedClasspath and shared across multiple jobs .
public void eval ( String javascript ) throws WidgetException { WebElement  = findElement ( false ) ; WebDriver  = getGUIDriver ( ) . getWrappedDriver ( ) ; try { ( ( JavascriptExecutor )  ) . executeScript (  ,  ) ; } catch ( Exception e ) { long  =  . currentTimeMillis ( ) + 2000 ; boolean  = false ; while ( !  &&  . currentTimeMillis ( ) <  ) { try { ( ( JavascriptExecutor )  ) . executeScript (  ,  ) ;  = true ; } catch ( Exception e2 ) { try {  . sleep ( 500 ) ; } catch ( InterruptedException e1 ) { }  =  ; } } if ( !  ) { throw new RuntimeException (  ) ; } } }<CODESPLIT>Executes JavaScript code on the current element in the current frame or window .
public long addWrapField ( long instant , int amount ) { return set (  ,  . getWrappedValue ( get (  ) ,  , 0 ,  - 1 ) ) ; }<CODESPLIT>Add the specified amount to the specified time instant wrapping around within the remainder range if necessary . The amount added may be negative .
protected synchronized SendRequest makeUnsignedChannelContract ( Coin valueToMe ) { Transaction  = new Transaction (  . getParams ( ) ) ; if ( ! getTotalValue ( ) . subtract (  ) . equals (  . ZERO ) ) {  . addOutput ( getTotalValue ( ) . subtract (  ) ,  . fromKey (  . getParams ( ) , getClientKey ( ) ) ) ; }  . addInput (  . getOutput ( 0 ) ) ; return  . forTx (  ) ; }<CODESPLIT>Create a payment transaction with valueToMe going back to us
public static String getUserNameFromToken ( String authToken ) { if ( null ==  ) { return null ; } return  . split (  ) [ 0 ] ; }<CODESPLIT>Extracts the user name from token .
protected Class < ? > resolveProxyClass ( String [ ] interfaceNames ) throws ClassNotFoundException { ClassLoader  =  ; Class < ? > [ ]  = new Class [  . length ] ; Class < ? >  = null ; for ( int  = 0 ;  <  . length ;  ++ ) { Class < ? >  = loadClass (  [  ] ) ; if ( !  . isPublic (  . getModifiers ( ) ) ) { ClassLoader  = getClassLoader (  ) ; if (  != null ) { if (  !=  ) { throw new IllegalAccessError (  + " and " +  + " both declared non-public in different class loaders" ) ; } } else {  =  ;  =  ; } }  [  ] =  ; } try { return  . getProxyClass (  ,  ) ; } catch ( IllegalArgumentException ex ) { throw new ClassNotFoundException ( null ,  ) ; } }<CODESPLIT>Delegates class loading to the specified class loader .
public static double [ ] rowSums ( double [ ] [ ] data ) { double [ ]  = new double [  . length ] ; for ( int  = 0 ;  <  . length ;  ++ ) {  [  ] = sum (  [  ] ) ; } return  ; }<CODESPLIT>Returns the row sums for a matrix .
protected void rehash ( int newCapacity ) { int  =  . length ; long    =  ; int    =  ; byte    =  ; long    = new long [  ] ; int    = new int [  ] ; byte    = new byte [  ] ; this . lowWaterMark = chooseLowWaterMark (  , this . minLoadFactor ) ; this . highWaterMark = chooseHighWaterMark (  , this . maxLoadFactor ) ; this . table =  ; this . values =  ; this . state =  ; this . freeEntries =  - this . distinct ; for ( int  =  ;  -- > 0 ; ) { if (  [  ] ==  ) { long  =  [  ] ; int  = indexOfInsertion (  ) ;  [  ] =  ;  [  ] =  [  ] ;  [  ] =  ; } } }<CODESPLIT>Rehashes the contents of the receiver into a new table with a smaller or larger capacity . This method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark .
public void add ( HpackHeaderField header ) { int  =  . size ( ) ; if (  >  ) { clear ( ) ; return ; } while (  -  <  ) { remove ( ) ; }  [  ++ ] =  ;  +=  . size ( ) ; if (  ==  . length ) {  = 0 ; } }<CODESPLIT>Add the header field to the dynamic table . Entries are evicted from the dynamic table until the size of the table and the new header field is less than or equal to the table s capacity . If the size of the new entry is larger than the table s capacity the dynamic table will be cleared .
private void fired ( Direction initial ) { for ( final LauncherListener  :  ) {  . notifyFired ( ) ; } for ( final LaunchableConfig  :  ) { final Media  =  . create (  . getMedia ( ) ) ; final Featurable  =  . create (  ) ; try { final Launchable  =  . getFeature ( Launchable . class ) ; if (  . getDelay ( ) > 0 ) {  . add ( new DelayedLaunch (  ,  ,  ,  ) ) ; } else { launch (  ,  ,  ,  ) ; } } catch ( final LionEngineException exception ) {  . getFeature ( Identifiable . class ) . destroy ( ) ; throw  ; } } }<CODESPLIT>Called when fire is performed .
public static void init ( InvocationManager invmgr , RootDObjectManager omgr ) {  =  ;  =  ;  . registerProvider ( new TimeBaseProvider ( ) , TimeBaseMarshaller . class ,  ) ; }<CODESPLIT>Registers the time provider with the appropriate managers . Called by the presents server at startup .
static UfsJournalFile createLogFile ( URI location , long start , long end ) { return new UfsJournalFile (  ,  ,  , false ) ; }<CODESPLIT>Creates a journal log file .
protected Object writeReplace ( ) throws java . io . ObjectStreamException { try { return new CertificateRep (  , getEncoded ( ) ) ; } catch ( CertificateException e ) { throw new java . io . NotSerializableException ( "java.security.cert.Certificate: " +  + ": " +  . getMessage ( ) ) ; } }<CODESPLIT>Replace the Certificate to be serialized .
private static Throwable extractThrowable ( final Object [ ] arguments ) { return  . length == 0 ? null : extractThrowable (  [  . length - 1 ] ) ; }<CODESPLIT>Returns a throwable if the last argument is one .
public static List < Map < IBond , IBond > > makeBondMapsOfAtomMaps ( IAtomContainer ac1 , IAtomContainer ac2 , List < Map < IAtom , IAtom > > mappings ) { List < Map < IBond , IBond > >  = new ArrayList < Map < IBond , IBond > > ( ) ; for ( Map < IAtom , IAtom >  :  ) {  . add ( makeBondMapOfAtomMap (  ,  ,  ) ) ; } return  ; }<CODESPLIT>Returns bond maps between source and target molecules based on the atoms
public LongConstant addLong ( long value ) { LongConstant  = getLongByValue (  ) ; if (  != null ) return  ;  = new LongConstant ( this ,  . size ( ) ,  ) ; addConstant (  ) ; addConstant ( null ) ; return  ; }<CODESPLIT>Adds a long constant .
public GeoPackage getOrOpen ( String name , File file ) { return getOrOpen (  ,  , true ) ; }<CODESPLIT>Get the cached GeoPackage or open and cache the GeoPackage file
public static int extractVersionFromSchemaName ( String clz_name ) { int  =  . lastIndexOf ( 'V' ) ; if (  == - 1 ) return - 1 ; try { return  . valueOf (  . substring (  + 1 ) ) ; } catch ( NumberFormatException ex ) { return - 1 ; } }<CODESPLIT>Extract the version number from the schema class name . Returns - 1 if there s no version number at the end of the classname .
private void drawShape ( Canvas canvas , Paint paint , Path path , ShapeAppearanceModel shapeAppearanceModel , RectF bounds ) { if (  . isRoundRect ( ) ) { float  =  . getTopRightCorner ( ) . getCornerSize ( ) ;  . drawRoundRect (  ,  ,  ,  ) ; } else {  . drawPath (  ,  ) ; } }<CODESPLIT>Draw the path or try to draw a round rect if possible .
public AnalyzerJob getAnalyzerJob ( final String descriptorName , final String analyzerName , final String analyzerInputName ) { List < AnalyzerJob >  = new ArrayList < > (  ) ;  =  . refineCandidates (  , o -> { final String  =  . getDescriptor ( ) . getDisplayName ( ) ; return  . equals (  ) ; } ) ; if (  != null ) {  =  . refineCandidates (  , o -> { final String  =  . getName ( ) ; return  . equals (  ) ; } ) ; } if (  != null ) {  =  . refineCandidates (  , o -> { final InputColumn < ? >  = getIdentifyingInputColumn (  ) ; if (  == null ) { return false ; } return  . equals (  . getName ( ) ) ; } ) ; } if (  . isEmpty ( ) ) {  . error ( "No more AnalyzerJob candidates to choose from" ) ; return null ; } else if (  . size ( ) > 1 ) {  . warn ( "Multiple ({}) AnalyzerJob candidates to choose from, picking first" ) ; } return  . iterator ( ) . next ( ) ; }<CODESPLIT>Gets the best candidate analyzer job based on search criteria offered in parameters .
public boolean removeExecutedTradeCallback ( final BitfinexExecutedTradeSymbol tradeSymbol , final BiConsumer < BitfinexExecutedTradeSymbol , BitfinexExecutedTrade > callback ) throws BitfinexClientException { return  . removeCallback (  ,  ) ; }<CODESPLIT>Remove a executed trade callback
public HealthDto doPrimaryHealthCheck ( ) { List < HealthDependency >  =  . values ( ) . stream ( ) . filter ( HealthDependency :: isPrimary ) . collect (  . toList ( ) ) ; return checkHealth (  ) ; }<CODESPLIT>Performs the Primary Health Check .
public static appfwxmlerrorpage get ( nitro_service service ) throws Exception { appfwxmlerrorpage  = new appfwxmlerrorpage ( ) ; appfwxmlerrorpage [ ]  = ( appfwxmlerrorpage [ ] )  . get_resources (  ) ; return  [ 0 ] ; }<CODESPLIT>Use this API to fetch all the appfwxmlerrorpage resources that are configured on netscaler .
private void setupClient ( final AbstractHttpClient client ) { this . client . addResponseInterceptor ( new HttpResponseInterceptor ( ) { public void process ( final HttpResponse response , final HttpContext context ) throws HttpException , IOException { Header  =  . getFirstHeader ( "Location" ) ; if (  != null )  . setAttribute ( "Location" ,  . getValue ( ) ) ; } } ) ; }<CODESPLIT>This method is used to capture Location headers after HttpClient redirect handling .
private void quickSelect ( List < P > points , int splitAxis , int medianNum ) { int  =  . size ( ) ; if (  . length <  ) {  = new double [  ] ;  = new int [  ] ; } for ( int  = 0 ;  <  ;  ++ ) {  [  ] =  . valueAt (  . get (  ) ,  ) ; }  . selectIndex (  ,  ,  ,  ) ; }<CODESPLIT>Uses quick - select to find the median value
public void writeHtml ( JspWriter pOut , String pHtml ) throws IOException { StringTokenizer  = new StringTokenizer (  , "<>&" , true ) ; while (  . hasMoreTokens ( ) ) { String  =  . nextToken ( ) ; if (  . equals ( "<" ) ) {  . print ( "&lt;" ) ; } else if (  . equals ( ">" ) ) {  . print ( "&gt;" ) ; } else if (  . equals ( "&" ) ) {  . print ( "&amp;" ) ; } else {  . print (  ) ; } } }<CODESPLIT>writeHtml ensures that the text being outputted appears as it was entered . This prevents users from hacking the system by entering html or jsp code into an entry form where that value will be displayed later in the site .
protected String getNodeName ( Node node ) { String  =  . getLocalName ( ) ; return  == null ?  . getNodeName ( ) :  ; }<CODESPLIT>Returns the node name . First tries local name . If this is null returns instead the full node name .
public void setExpiryDate ( @ IntRange ( from = 1 , to = 12 ) int month , @ IntRange ( from = 0 , to = 9999 ) int year ) {  . setText (  . createDateStringFromIntegerInput (  ,  ) ) ; }<CODESPLIT>Set the expiration date . Method invokes completion listener and changes focus to the CVC field if a valid date is entered .
protected void writeApplyDdl ( DdlWrite write ) {  . setApplyDdl ( "-- drop dependencies\n" +  . applyDropDependencies ( ) . getBuffer ( ) + "\n" + "-- apply changes\n" +  . apply ( ) . getBuffer ( ) +  . applyForeignKeys ( ) . getBuffer ( ) +  . applyHistoryView ( ) . getBuffer ( ) +  . applyHistoryTrigger ( ) . getBuffer ( ) ) ; }<CODESPLIT>Write the Apply DDL buffers to the writer .
protected static final boolean classEquals ( Class clz1 , Class clz2 ) { if (  == null ||  == null ) { throw new NullPointerException ( ) ; } return  ==  ||  . getName ( ) . equals (  . getName ( ) ) ; }<CODESPLIT>Compares if two classes are equal or their class names are equal .
public void addSharedFunction ( ISource source ) { String  =  instanceof FileSource ? ( ( FileSource )  ) . getFileName ( ) : null ; doAddSharedFunction (  ,  ) ; }<CODESPLIT>Add shared function by ISource
public void setCommercePriceListService ( com . liferay . commerce . price . list . service . CommercePriceListService commercePriceListService ) { this . commercePriceListService =  ; }<CODESPLIT>Sets the commerce price list remote service .
public static HtmlTree MAIN ( ) { HtmlTree  = new HtmlTree (  . MAIN ) ;  . setRole (  . MAIN ) ; return  ; }<CODESPLIT>Generates a MAIN tag with role attribute .
public static cachepolicylabel_stats get ( nitro_service service , String labelname ) throws Exception { cachepolicylabel_stats  = new cachepolicylabel_stats ( ) ;  . set_labelname (  ) ; cachepolicylabel_stats  = ( cachepolicylabel_stats )  . stat_resource (  ) ; return  ; }<CODESPLIT>Use this API to fetch statistics of cachepolicylabel_stats resource of given name .
protected void saveBroker ( File mapfile , HashMapIDBroker broker ) throws RuntimeException { if ( !  . isModified ( ) ) { return ; } try { BufferedWriter  = new BufferedWriter ( new FileWriter (  ) ) ;  . writeTo (  ) ;  . close ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( "Unable to store component ID map [mapfile=" +  + "]" ,  ) ; } }<CODESPLIT>Stores a persistent representation of the supplied hashmap ID broker in the specified file .
public void update ( final Collection < T > values ) throws DataAccessException {  . execute ( new ConnectionCallback < Object > ( ) { public Object doInConnection ( Connection connection ) throws SQLException , DataAccessException {  . update (  ,  ) ; return null ; } } ) ; }<CODESPLIT>update the objects .
public static MutableInt fromExternal ( final IntSupplier s , final IntConsumer c ) { return new MutableInt ( ) { public int getAsInt ( ) { return  . getAsInt ( ) ; } public Integer get ( ) { return getAsInt ( ) ; } public MutableInt set ( final int value ) {  . accept (  ) ; return this ; } } ; }<CODESPLIT>Construct a MutableInt that gets and sets an external value using the provided Supplier and Consumer
public void configure ( Config config ) {  . debug ( "Reloading configuration." ) ; this . configWriteLock . lock ( ) ; try { this . config =  ; processAppPackages (  ) ; } finally { this . configWriteLock . unlock ( ) ; } }<CODESPLIT>Replace the configuration of this instance directly .
protected void addPropertiesStart ( String type ) { putProperty (  . Host . name ( ) ,  . getHostName ( ) ) ; putProperty (  . Type . name ( ) ,  ) ; putProperty (  . Status . name ( ) ,  . Start . name ( ) ) ; }<CODESPLIT>Add properties to properties map on transaction start
public List < SequenceListType . Sequence > getSequence ( ) { if (  == null ) {  = new ArrayList < SequenceListType . Sequence > ( ) ; } return this . sequence ; }<CODESPLIT>Gets the value of the sequence property .
public MapBuilder addNumber ( String fieldName , boolean include , Supplier < Number > supplier ) { if (  ) { Number  =  . get ( ) ; if (  != null ) {  . put ( getFieldName (  ) ,  ) ; } } return this ; }<CODESPLIT>Adds the number value to the provided map under the provided field name if it should be included . The supplier is only invoked if the field is to be included .
public void disconnectCardOneConsumer ( ) { if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . entry (  , "disconnectCardOneConsumer" ) ; Object [ ]  = null ; synchronized (  ) {  =  . toArray ( ) ; } SILimitExceededException  = new SILimitExceededException (  . getFormattedMessage ( "CONSUMERCARDINALITY_LIMIT_REACHED_CWSIP0472" , new Object [ ] { getDestName ( ) , getLocalisationUuid ( ) . toString ( ) } , null ) ) ;  . processException (  , "com.ibm.ws.sib.processor.impl.RemoteConsumerDispatcher.disconnectCardOneConsumer" , "1:945:1.97.2.21" , this ) ;  . exception (  ,  ) ; for ( int  = 0 ;  <  . length ;  ++ ) { DispatchableKey  = ( DispatchableKey )  [  ] ;  . notifyConsumerPointAboutException (  ) ; } if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) )  . exit (  , "disconnectCardOneConsumer" ) ; }<CODESPLIT>The disconnectCardOneConsumer method is invoked by the Anycast Input Handler to notify it that the current cardinality - one consumer must be disconnected . This can happen when this RME becomes unreachable and the DME allows a consumer in a separate RME to connect . As soon as this RME becomes reachable again the DME sends ControlCardinalityInfo to trigger this consumer s disconnection .
public boolean isAdministrator ( AuthContext ctx ) { return  . getUsername ( ) != null &&  . getUsername ( ) . equals (  ) &&  . getPassword ( ) != null &&  . getPassword ( ) . equals (  ) ; }<CODESPLIT>Check if the given credentials allow administrative access
protected void init ( ) { if (  . autostart ( ) ) {  =  . getRunner ( ) ;  . config ( "Using runner " +  . getClass ( ) . getSimpleName ( ) ) ; } else {  . setPort (  . SERVER_DEFAULT_PORT_IDENTIFIER ) ; } createScopeServices ( ) ; if (  != null ) {  . startOpera ( ) ; }  . init ( ) ;  =  . getDebugger ( ) ;  . setDriver ( this ) ;  =  . getWindowManager ( ) ;  =  . getExec ( ) ;  =  . getCore ( ) ;  =  . getCookieManager ( ) ;  = new OperaMouse ( this ) ;  = new OperaKeyboard ( this ) ;  . getConsoleLogger ( ) . onConsoleMessage ( new ConsoleMessageConverter (  ) ) ;  . setProduct ( utils ( ) . getProduct ( ) ) ; if ( ! utils ( ) . getUserAgent ( ) . contains ( "Mini" ) ) {  = new OperaScopePreferences (  . getPrefs ( ) ) ; preferences ( ) . set ( "User Prefs" , "Ignore Unrequested Popups" , false ) ; if ( utils ( ) . getProduct ( ) . is (  ) ) { preferences ( ) . set ( "User Prefs" , "Allow Autofocus Form Element" , true ) ; } }  = new OperaProxy ( this ) ;  . parse (  . getProxy ( ) ) ; }<CODESPLIT>Initialize required Scope services .
public static String calculateMD5 ( String string ) { byte [ ]  ; try {  =  . getInstance ( "MD5" ) . digest (  . getBytes ( "UTF-8" ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( "Huh, MD5 should be supported?" ,  ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( "Huh, UTF-8 should be supported?" ,  ) ; } StringBuilder  = new StringBuilder (  . length * 2 ) ; for ( byte  :  ) { int  = (  & 0xFF ) ; if (  < 0x10 )  . append ( '0' ) ;  . append (  . toHexString (  ) ) ; } return  . toString ( ) ; }<CODESPLIT>Calculate the MD5 of a given String
protected static File findRawDir ( File dir ) { for ( int  = 0 ;  != null &&  < 20 ;  ++ ) { File  = findResRawDir (  ) ; if (  != null ) { return  ; }  =  . getParentFile ( ) ; } return null ; }<CODESPLIT>Look for the resource - directory in the current directory or the directories above . Then look for the raw - directory underneath the resource - directory .
public Object resolveVariable ( String pName ) throws ELException { ELContext  = this . getELContext ( ) ; return  . getELResolver ( ) . getValue (  , null ,  ) ; }<CODESPLIT>LIDB4147 - 9 Begin - modified for JSP 2 . 1
protected DependantValue createPrimaryKeyValue ( InFlightMetadataCollector mappings , PersistentProperty property , Collection collection , Map < ? , ? > persistentClasses ) { KeyValue  ; DependantValue  ; String  =  . getReferencedPropertyName ( ) ; if (  == null ) {  =  . getOwner ( ) . getIdentifier ( ) ; } else {  = ( KeyValue )  . getOwner ( ) . getProperty (  ) . getValue ( ) ; } if (  . isDebugEnabled ( ) )  . debug ( "[GrailsDomainBinder] creating dependant key value to table [" +  . getTable ( ) . getName ( ) + "]" ) ;  = new DependantValue (  ,  . getCollectionTable ( ) ,  ) ;  . setTypeName ( null ) ;  . setNullable ( true ) ;  . setUpdateable ( false ) ; return  ; }<CODESPLIT>Creates the DependentValue object that forms a primary key reference for the collection .
protected AVariableExp getVarExp ( ILexNameToken name , PDefinition vardef , PType type ) { AVariableExp  = getVarExp (  ,  ) ;  . setType (  ) ; return  ; }<CODESPLIT>Generate Var Exp with everything!
public static boolean isNullOrWhiteSpace ( String arg ) { if (  . isNullOrEmpty (  ) ||  . trim ( ) . isEmpty ( ) ) { return true ; } return false ; }<CODESPLIT>Determines whether the parameter string is null empty or whitespace .
public BlockInfo queryBlockByNumber ( long blockNumber ) throws InvalidArgumentException , ProposalException { return queryBlockByNumber ( getShuffledPeers (  . of (  . LEDGER_QUERY ) ) ,  ) ; }<CODESPLIT>query this channel for a Block by the blockNumber . The request is retried on all peers till successful
@ SuppressWarnings ( "unchecked" ) public static Getter getGetter ( Class type , String name ) { return getGettersAsMap (  ) . get (  ) ; }<CODESPLIT>Search getter for given class and property name .
public static String decodeLZToString ( byte [ ] data , String dictionary ) { try { return new String ( decodeLZ (  ) , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException (  ) ; } }<CODESPLIT>Decode lz to string string .
public static AirlineFlightUpdateTemplateBuilder addAirlineFlightUpdateTemplate ( String introMessage , String locale , String pnrNumber , UpdateType updateType ) { return new AirlineFlightUpdateTemplateBuilder (  ,  ,  ,  ) ; }<CODESPLIT>Adds an Airline Flight Update Template to the response .
private void addModulesArgument ( final String argument , final List < String > arguments , final Module [ ] modules , final String aditionalpath , final String role ) throws MojoExecutionException { StringBuilder  = new StringBuilder ( ) ; if ( null !=  ) {  . add (  ) ;  . append (  ) ; } if (  != null &&  . length > 0 ) { if ( !  . contains (  ) ) {  . add (  ) ; } for ( int  = 0 ;  <  . length ; ++  ) { Module  =  [  ] ; Artifact  = null ; @ SuppressWarnings ( "unchecked" ) Set < Artifact >  =  . getArtifacts ( ) ; for ( Artifact  :  ) { if (  . getGroupId ( ) . equals (  . getGroupId ( ) ) &&  . getArtifactId ( ) . equals (  . getArtifactId ( ) ) &&  . defaultString (  . getClassifier ( ) ) . equals (  . defaultString (  . getClassifier ( ) ) ) &&  . defaultString (  . getType ( ) , "jar" ) . equals (  . defaultString (  . getType ( ) ) ) ) {  =  ; break ; } } if (  == null ) { throw new MojoExecutionException ( "The artifact " +  . toString ( ) + " referenced in aspectj plugin as " +  + ", is not found the project dependencies" ) ; } if (  . length ( ) != 0 ) {  . append (  . pathSeparatorChar ) ; }  . append (  . getFile ( ) . getPath ( ) ) ; } } if (  . length ( ) > 0 ) { String  =  . toString ( ) ;  . add (  ) ; getLog ( ) . debug ( "Adding " +  + ": " +  ) ; } }<CODESPLIT>Finds all artifacts in the weavemodule property and adds them to the ajc options .
public static String extractAeroGearSenderInformation ( final HttpServletRequest request ) { String  =  . getHeader ( "aerogear-sender" ) ; if ( hasValue (  ) ) { return  ; } return  . getHeader ( "user-agent" ) ; }<CODESPLIT>Reads the aerogear - sender header to check if an AeroGear Sender client was used . If the header value is NULL the value of the standard user - agent header is returned
public Flux < ServiceMessage > requestMany ( ServiceMessage request , Class < ? > responseType , Address address ) { return  . defer ( ( ) -> { requireNonNull (  , "requestMany address parameter is required and must not be null" ) ; requireNonNull (  , "transport is required and must not be null" ) ; return  . create (  ) . requestStream (  ) . map ( message ->  . decodeData (  ,  ) ) . map ( this :: throwIfError ) ; } ) ; }<CODESPLIT>Given an address issues request to remote service which returns stream of service messages back .
public void incrementalRestore ( File incrementalBackupFile ) throws FileNotFoundException , IOException , ClassNotFoundException , RepositoryException { ObjectInputStream  = null ; try {  = new ObjectInputStream (  . fileInputStream (  ) ) ; while ( true ) { TransactionChangesLog  = readExternal (  ) ;  . setSystemId (  . JCR_CORE_RESTORE_WORKSPACE_INITIALIZER_SYSTEM_ID ) ; ChangesLogIterator  =  . getLogIterator ( ) ; while (  . hasNextLog ( ) ) { if (  . nextLog ( ) . getEventType ( ) ==  . LOCK ) {  . removeLog ( ) ; } } saveChangesLog (  ) ; } } catch ( EOFException ioe ) { if (  . isTraceEnabled ( ) ) {  . trace ( "An exception occurred: " +  . getMessage ( ) ) ; } } }<CODESPLIT>Perform incremental restore operation .
public Key < Integer > start ( ) { final Key < Integer >  = new Key < Integer > ( ) ;  . put (  , new Consumer < Integer > ( ) { int count ; public void consume ( final ByteBuffer buffer ) {  +=  . remaining ( ) ; } public Integer finish ( ) { return  ; } } ) ; return  ; }<CODESPLIT>Initializes a byte counter on this channel .
public static boolean isElementPresent ( String locator ) {  . entering (  ) ; boolean  = false ; try {  =  . locateElement (  ) != null ; } catch ( NoSuchElementException e ) { }  . exiting (  ) ; return  ; }<CODESPLIT>Checks if the provided element is present on the page based on the locator provided
public static void main ( String args [ ] ) throws Exception { final StringBuffer  = new StringBuffer ( "The lazy fox" ) ; Thread  = new Thread ( ) { public void run ( ) { synchronized (  ) {  . delete ( 0 , 4 ) ;  . append ( " in the middle" ) ;  . err . println ( "Middle" ) ; try {  . sleep ( 4000 ) ; } catch ( Exception e ) { }  . append ( " of fall" ) ;  . err . println ( "Fall" ) ; } } } ; Thread  = new Thread ( ) { public void run ( ) { try {  . sleep ( 1000 ) ; } catch ( Exception e ) { }  . append ( " jump over the fence" ) ;  . err . println ( "Fence" ) ; } } ;  . start ( ) ;  . start ( ) ;  . join ( ) ;  . join ( ) ;  . err . println (  ) ; }<CODESPLIT>We have more input since wait started
protected double interpolate ( double boundA , double boundB ) { double  ; if (  . isNaN (  ) ) {  =  . quadratic (  ,  ,  ,  ,  ) ; } else {  =  . cubic2 (  ,  ,  ,  ,  ,  ) ; if (  . isNaN (  ) )  =  . quadratic (  ,  ,  ,  ,  ) ; } double  ,  ; if (  <  ) {  =  ;  =  ; } else {  =  ;  =  ; } if (  <  )  =  ; else if (  >  )  =  ; return  ; }<CODESPLIT>Use either quadratic of cubic interpolation to guess the minimum .
private List < SemanticError > check ( DataType dataType ) {  . finer ( "Checking semantic constraints on datatype " +  . name ) ; final List < SemanticError >  = new ArrayList < SemanticError > ( ) ; final Set < String >  = new HashSet < String > ( ) ; for ( Constructor  :  . constructors ) {  . finest ( "Checking semantic constraints on constructor " +  . name + " in datatype " +  . name ) ; if (  . constructors . size ( ) > 1 &&  . name . equals (  . name ) ) {  . info ( "Constructor with same name as its data type " +  . name + "." ) ;  . add ( _ConstructorDataTypeConflict (  . name ) ) ; } if (  . contains (  . name ) ) {  . info ( "Two constructors with same name " +  . name + " in data type " +  . name + "." ) ;  . add ( _DuplicateConstructor (  . name ,  . name ) ) ; } else {  . add (  . name ) ; }  . addAll ( check (  ,  ) ) ; } return  ; }<CODESPLIT>Checks a data type for duplicate constructor names or constructors having the same name as the data type
@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) protected void registerDependency ( List additionalList , GrailsPlugin plugin ) { if ( !  . contains (  . getName ( ) ) ) {  . add (  . getName ( ) ) ;  . add (  ) ; addPluginDependencies (  ,  ) ; } }<CODESPLIT>Adds a plugin to the additional if this hasn t happened already
private JsonNode executeRequest ( HttpPost request ) throws IOException , GroovesharkException { HttpResponse  =  . execute (  ) ; if (  ) { logRequest (  ,  ) ; } String  =  . toString ( new InputStreamReader (  . getEntity ( ) . getContent ( ) ,  . UTF_8 ) ) ; try { return  . readTree ( new StringReader (  ) ) ; } catch ( JsonProcessingException e ) { throw new GroovesharkException . ServerErrorException ( "Failed to parse response - received data was not valid JSON: " +  ) ; } }<CODESPLIT>Boilerplate to send the request and parse the response payload as JSON .
public Map < String , T > parseMap ( JsonParser jsonParser ) throws IOException { HashMap < String , T >  = new HashMap < String , T > ( ) ; while (  . nextToken ( ) !=  . END_OBJECT ) { String  =  . getText ( ) ;  . nextToken ( ) ; if (  . getCurrentToken ( ) ==  . VALUE_NULL ) {  . put (  , null ) ; } else {  . put (  , parse (  ) ) ; } } return  ; }<CODESPLIT>Parse a map of objects from a JsonParser .
public DateFuncSup subtract ( DateSeperator d ) {  . setTime (  . getTime ( ) -  . parse ( ) ) ; return this ; }<CODESPLIT>subtract date on supported date
private double radicalInverse ( long i ) { double  = 1.0 / ( double )  ; double  =  ; double  = 0.0 ; while (  > 0 ) {  +=  * ( double ) (  %  ) ;  *=  ;  /=  ; } return  ; }<CODESPLIT>Compute the radical inverse of i .
public static String getTempDir ( ) { synchronized ( FileUtil . class ) { if (  == null ) { String  =  . getProperty ( "java.io.tmpdir" ) ; if (  . isEmpty (  ) ) { if ( new File ( "/temp" ) . exists ( ) ) {  = "/temp" ; } else {  = "/tmp" ; } }  =  ; } } return  ; }<CODESPLIT>Gets the default temp directory for the system .
public static < Accumulator , Value > Accumulator reduce ( List < Value > list , Accumulator init , ReduceClosure < Accumulator , Value > f ) { Accumulator  =  ; for ( Value  :  ) {  =  . eval (  ,  ) ; } return  ; }<CODESPLIT>Applies a binary function between each element of the given list .
protected ProcessOutput executeProcess ( FaxJob faxJob , String command , FaxActionType faxActionType ) { if (  == null ) { this . throwUnsupportedException ( ) ; } String  =  ; if ( this . useWindowsCommandPrefix ) { StringBuilder  = new StringBuilder (  . length ( ) + this . windowsCommandPrefix . length ( ) + 1 ) ;  . append ( this . windowsCommandPrefix ) ;  . append ( " " ) ;  . append (  ) ;  =  . toString ( ) ; } ProcessOutput  =  . executeProcess ( this ,  ) ; this . validateProcessOutput (  ,  ) ; this . updateFaxJob (  ,  ,  ) ; return  ; }<CODESPLIT>Executes the process and returns the output .
public ModelNode getConnector ( String name ) throws Exception { final Address  =  . root ( ) . add (  ,  ,  ,  ) ; return readResource (  , true ) ; }<CODESPLIT>Returns the connector node with all its attributes . Will be null if it doesn t exist .
int match ( CharsetDetector det , int [ ] commonChars ) { @ SuppressWarnings ( "unused" ) int  = 0 ; int  = 0 ; int  = 0 ; int  = 0 ; int  = 0 ; int  = 0 ; iteratedChar  = new iteratedChar ( ) ; detectBlock : { for (  . reset ( ) ; nextChar (  ,  ) ; ) {  ++ ; if (  . error ) {  ++ ; } else { long  =  . charValue & 0xFFFFFFFFL ; if (  <= 0xff ) {  ++ ; } else {  ++ ; if (  != null ) { if (  . binarySearch (  , ( int )  ) >= 0 ) {  ++ ; } } } } if (  >= 2 &&  * 5 >=  ) { break detectBlock ; } } if (  <= 10 &&  == 0 ) { if (  == 0 &&  < 10 ) {  = 0 ; } else {  = 10 ; } break detectBlock ; } if (  < 20 *  ) {  = 0 ; break detectBlock ; } if (  == null ) {  = 30 +  - 20 *  ; if (  > 100 ) {  = 100 ; } } else { double  =  . log ( ( float )  / 4 ) ; double  = 90.0 /  ;  = ( int ) (  . log (  + 1 ) *  + 10 ) ;  =  . min (  , 100 ) ; } } return  ; }<CODESPLIT>Test the match of this charset with the input text data which is obtained via the CharsetDetector object .
public static void extract ( DMatrix src , int srcY0 , int srcY1 , int srcX0 , int srcX1 , DMatrix dst ) { ( ( ReshapeMatrix )  ) . reshape (  -  ,  -  ) ; extract (  ,  ,  ,  ,  ,  , 0 , 0 ) ; }<CODESPLIT>Extract where the destination is reshaped to match the extracted region
public void resizeEip ( ResizeEipRequest request ) { checkNotNull (  . getNewBandwidthInMbps ( ) , "newBandwidthInMbps should not be null" ) ; checkStringNotEmpty (  . getEip ( ) , "eip should not be empty" ) ; if (  . isNullOrEmpty (  . getClientToken ( ) ) ) {  . setClientToken ( generateDefaultClientToken ( ) ) ; } InternalRequest  = this . createRequest (  ,  . PUT ,  . getEip ( ) ) ;  . addParameter ( "resize" , null ) ;  . addParameter (  ,  . getClientToken ( ) ) ; fillPayload (  ,  ) ; invokeHttpClient (  , AbstractBceResponse . class ) ; }<CODESPLIT>Resizing eip The Prepaid eip can not be downgrade . This is an asynchronous interface .
private void useNextAddressAsNewContactSeedBroker ( ) { if ( ++  ==  . length ) {  = 0 ; } URL  =  . getCorrectHostnamePort (  [  ] ) ; this . consumer = new SimpleConsumer (  . getHost ( ) ,  . getPort ( ) ,  ,  ,  ) ; }<CODESPLIT>Re - establish broker connection using the next available seed broker address .
private String unescape ( String value ) { StringBuilder  = new StringBuilder ( ) ; for ( int  = 0 ;  <  . length ( ) ; ++  ) { char  =  . charAt (  ) ; if (  ==  ) { String  =  . substring (  + 1 ,  + 3 ) ; int  =  . parseInt (  , 16 ) ; if (  <  . length &&  [  ] ==  ) {  . append (  [  ] ) ;  += 2 ; } else { throw new ServiceLocationException ( "Unknown escaped character " +  +  + " at position " + (  + 1 ) + " of " +  ,  . PARSE_ERROR ) ; } } else {  . append (  ) ; } } return  . toString ( ) ; }<CODESPLIT>Unescapes the scope string following RFC 2608 6 . 4 . 1
protected HashMap readFile ( HashMap brMap ) throws IOException { HashMap  = new HashMap ( ) ; ArrayList < HashMap >  = new ArrayList < HashMap > ( ) ; HashMap < String , HashMap >  = readObvData (  ) ; ArrayList < HashMap >  ; HashMap  ; HashMap  ; for ( String  :  . keySet ( ) ) {  = ( ArrayList )  . get (  ) . get (  ) ; for ( HashMap  :  ) {  = new HashMap ( ) ;  = new HashMap ( ) ; copyItem (  ,  . get (  ) , "exname" ) ; copyItem (  ,  . get (  ) , "crid" ) ; copyItem (  ,  . get (  ) , "local_name" ) ;  . put (  ,  ) ;  . put (  ,  . get (  ) ) ;  . add (  ) ; } } ArrayList  = new ArrayList ( ) ;  . add ( "trno_t" ) ; removeIndex (  ,  ) ;  . put ( "experiments" ,  ) ; return  ; }<CODESPLIT>DSSAT TFile Data input method for Controller using
public static FixedStringSearchInterpolator createInterpolator ( MojoParameters params , String filter ) { String [ ]  = extractDelimiters (  ) ; if (  == null ) { return  . create ( ) ; } DockerAssemblyConfigurationSource  = new DockerAssemblyConfigurationSource (  , null , null ) ; return  . fullInterpolator (  . getProject ( ) ,  . createProjectInterpolator (  . getProject ( ) ) . withExpressionMarkers (  [ 0 ] ,  [ 1 ] ) ,  ) . withExpressionMarkers (  [ 0 ] ,  [ 1 ] ) ; }<CODESPLIT>Create an interpolator for the given maven parameters and filter configuration .
public static boolean isPartitionCleanupInProgress ( ZooKeeper zk ) throws KeeperException , InterruptedException { List < String >  =  . getChildren (  . leaders_initiators , null ) ; List < ZKUtil . ChildrenCallback >  =  . newArrayList ( ) ; for ( String  :  ) { ZKUtil . ChildrenCallback  = new ZKUtil . ChildrenCallback ( ) ;  . getChildren (  . joinZKPath (  . leaders_initiators ,  ) , false ,  , null ) ;  . add (  ) ; } for ( ZKUtil . ChildrenCallback  :  ) { if (  . get ( ) . isEmpty ( ) ) { return true ; } } return false ; }<CODESPLIT>Checks if the cluster suffered an aborted join or node shutdown and is still in the process of cleaning up .
private byte [ ] unifyLData ( final CEMI ldata , final boolean emptySrc , final List < Integer > types ) { final byte [ ]  ; if (  instanceof CEMILDataEx ) { final CEMILDataEx  = ( ( CEMILDataEx )  ) ; final List < AddInfo >  =  . additionalInfo ( ) ; synchronized (  ) { for ( final Iterator < AddInfo >  =  . iterator ( ) ;  . hasNext ( ) ; ) { final AddInfo  =  . next ( ) ; if ( !  . contains (  . getType ( ) ) ) {  . warn ( "remove L-Data additional info {}" ,  ) ;  . remove ( ) ; } } } }  =  . toByteArray ( ) ;  [ 0 ] = 0 ;  [ 1 +  [ 1 ] + 1 ] = 0 ; if (  ) {  [ 1 +  [ 1 ] + 3 ] = 0 ;  [ 1 +  [ 1 ] + 4 ] = 0 ; } return  ; }<CODESPLIT>additional info . types provides the list of add . info types we want to keep everything else is removed
public static < T extends Number > int [ ] asArray ( final T ... array ) { int [ ]  = new int [  . length ] ; for ( int  = 0 ;  <  . length ;  ++ ) {  [  ] =  [  ] . intValue ( ) ; } return  ; }<CODESPLIT>Convert any number class to array of integer .
synchronized void setActiveChunkHandle ( SegmentHandle handle ) {  . checkArgument (  == null || !  . isReadOnly ( ) , "Active SegmentChunk handle cannot be readonly." ) ; SegmentChunk  = lastChunk ( ) ;  . checkState (  != null , "Cannot set an Active SegmentChunk handle when there are no SegmentChunks." ) ;  . checkArgument (  == null ||  . getSegmentName ( ) . equals (  . getName ( ) ) , "Active SegmentChunk handle must be for the last SegmentChunk." ) ; this . activeChunkHandle =  ; }<CODESPLIT>Sets the Active SegmentChunk handle .
public String getEmptyValue ( ) { if (  . featOkTst && ( ( Timex3Interval_Type )  ) . casFeat_emptyValue == null )  . jcas . throwFeatMissing ( "emptyValue" , "de.unihd.dbs.uima.types.heideltime.Timex3Interval" ) ; return  . ll_cas . ll_getStringValue (  , ( ( Timex3Interval_Type )  ) . casFeatCode_emptyValue ) ; }<CODESPLIT>getter for emptyValue - gets
public static AccountInfo adaptAccountInfo ( BitstampBalance bitstampBalance , String userName ) { List < Balance >  = new ArrayList < > ( ) ; for ( org . knowm . xchange . bitstamp . dto . account . BitstampBalance . Balance  :  . getBalances ( ) ) { Balance  = new Balance (  . getInstance (  . getCurrency ( ) . toUpperCase ( ) ) ,  . getBalance ( ) ,  . getAvailable ( ) ,  . getReserved ( ) ,  ,  ,  . getBalance ( ) . subtract (  . getAvailable ( ) ) . subtract (  . getReserved ( ) ) ,  ) ;  . add (  ) ; } return new AccountInfo (  ,  . getFee ( ) , new Wallet (  ) ) ; }<CODESPLIT>Adapts a BitstampBalance to an AccountInfo
public void afterConnectionClosed ( WebSocketSession session , CloseStatus status ) {  . debug ( "WebSocket closed: {}, Close Status: {}" ,  ,  . toString ( ) ) ; }<CODESPLIT>Invoked after the web socket connection is closed . You can override this method in the child classes .
public static String trimLastPathSection ( String path ) { String [ ]  =  . split ( "/" ) ; StringBuilder  = new StringBuilder ( "/" ) ; for ( int  = 1 ;  <  . length - 1 ;  ++ ) {  . append (  [  ] ) . append ( "/" ) ; } return  . toString ( ) ; }<CODESPLIT>Removes the last part of a file path .
public static Style red ( ) { final Style  = new Style ( ) ;  . color =  . getSolidColor (  . MATERIAL_RED ) ; return  ; }<CODESPLIT>Default material red transparent style for SuperToasts .
public ManagedObjectContext createContext ( ) { Bean < T >  = null ; EjbDescriptor < T >  = getEjbDescriptor ( ) ; if ( !  . isMessageDriven ( ) ) {  = getBean ( ) ; } WeldManager  = getBeanManager ( ) ; WeldCreationalContext < T >  =  . createCreationalContext (  ) ; ManagedObjectContext  = new CDIManagedObjectState (  ) ; return  ; }<CODESPLIT>This version creates a ManagedObjectContext which contains a CreationalContext for an EJB .
public final void deleteOperation ( String name ) { DeleteOperationRequest  =  . newBuilder ( ) . setName (  ) . build ( ) ; deleteOperation (  ) ; }<CODESPLIT>Deletes a long - running operation . This method indicates that the client is no longer interested in the operation result . It does not cancel the operation . If the server doesn t support this method it returns google . rpc . Code . UNIMPLEMENTED .
public boolean isMember ( int x ) {  . check (  !=  . UNKNOWN ) ; return 0 <=  &&  < (  . length <<  ) && (  [  >>>  ] & ( 1 << (  &  ) ) ) != 0 ; }<CODESPLIT>Is x an element of this set?
public HandlerRegistration addSearchFinishHandler ( final SearchFinishEvent . SearchFinishHandler handler ) { return addHandler (  ,  . TYPE ) ; }<CODESPLIT>This handler will be triggered when search is finish
public void setForeignBusSendAllowed ( boolean sendAllowed ) { if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) ) {  . entry (  , "setForeignBusSendAllowed" ,  . valueOf (  ) ) ; }  =  . valueOf (  ) ; if (  != null ) { synchronized (  ) { Iterator  =  . iterator ( ) ; while (  . hasNext ( ) ) { AbstractAliasDestinationHandler  = ( AbstractAliasDestinationHandler )  . next ( ) ;  . setForeignBusSendAllowed (  ) ; } } } if (  . isAnyTracingEnabled ( ) &&  . isEntryEnabled ( ) ) {  . exit (  , "setForeignBusSendAllowed" ) ; } }<CODESPLIT>Set the Foreign Bus Level sendAllowed flag
public void processingInstruction ( String target , String data ) throws SAXException { if (  != null )  . processingInstruction (  ,  ) ; }<CODESPLIT>Adapt a SAX2 processing instruction event .
public static Integer getFileSizeOnFTPServer ( String hostName , Integer port , String userName , String password , String filePath ) { Integer  = null ; String  = executeCommandOnFTPServer (  ,  ,  ,  , "SIZE" ,  ) ; if (  == null || !  . contains ( " " ) ) { throw new RuntimeException (  . format ( "Unable to get size of the %s file. Got [%s] reply from FTP server." ,  ,  ) ) ; } else {  =  . valueOf (  . split ( " " ) [ 1 ] . replaceAll ( "[\r\n]" , "" ) ) ; } return  ; }<CODESPLIT>Get size of the FTP file .
public static base_responses enable ( nitro_service client , String trapname [ ] ) throws Exception { base_responses  = null ; if (  != null &&  . length > 0 ) { snmpalarm    = new snmpalarm [  . length ] ; for ( int  = 0 ;  <  . length ;  ++ ) {  [  ] = new snmpalarm ( ) ;  [  ] . trapname =  [  ] ; }  = perform_operation_bulk_request (  ,  , "enable" ) ; } return  ; }<CODESPLIT>Use this API to enable snmpalarm resources of given names .
public void ordered ( Consumer < T > action ) { TopoSorter < T >  = new TopoSorter < > ( this ) ;  . ordered (  ) ; }<CODESPLIT>Traverse this graph and performs the given action in topological order
public static SeqServerGroup parse ( String asg ) { int  =  . indexOf ( '-' ) ; int  =  . indexOf ( '-' ,  + 1 ) ; int  =  . lastIndexOf ( '-' ) ; if (  < 0 || ! isSequence (  ,  ) ) {  =  . length ( ) ; } return new SeqServerGroup (  ,  ,  ,  ) ; }<CODESPLIT>Create a new instance of a server group object by parsing the group name .
private static int getMapCount ( int srcCount , int numNodes ) { int  = ( int ) (  /  ) ;  =  . min (  ,  *  ) ; return  . max (  , 1 ) ; }<CODESPLIT>Calculate how many maps to run .
protected void channelRead0 ( ChannelHandlerContext ctx , FullBinaryMemcacheResponse msg ) throws Exception { switch (  . getStatus ( ) ) { case  :  . setSuccess ( ) ;  . pipeline ( ) . remove ( this ) ;  . fireChannelActive ( ) ; break ; case  :  . setFailure ( new AuthenticationException ( "Authentication failure on Select Bucket command" ) ) ; break ; case  :  . setFailure ( new AuthenticationException ( "Bucket not found on Select Bucket command" ) ) ; break ; default :  . setFailure ( new AuthenticationException ( "Unhandled select bucket status: " +  . getStatus ( ) ) ) ; } }<CODESPLIT>Handles incoming Select bucket responses .
private final DiceNotationExpression unwrap ( final DiceNotationExpression expression ) { final DiceNotationExpression  ; if (  instanceof ExpressionWrapper ) {  = ( ( ExpressionWrapper )  ) . getWrappedExpression ( ) ; } else {  =  ; } return  ; }<CODESPLIT>Removes the expression wrappers used to temporally prune the nodes .
public static float [ ] checkArrayElementsInRange ( float [ ] value , float lower , float upper , String valueName ) { checkNotNull (  ,  + " must not be null" ) ; for ( int  = 0 ;  <  . length ; ++  ) { float  =  [  ] ; if (  . isNaN (  ) ) { throw new IllegalArgumentException (  + "[" +  + "] must not be NaN" ) ; } else if (  <  ) { throw new IllegalArgumentException (  . format ( "%s[%d] is out of range of [%f, %f] (too low)" ,  ,  ,  ,  ) ) ; } else if (  >  ) { throw new IllegalArgumentException (  . format ( "%s[%d] is out of range of [%f, %f] (too high)" ,  ,  ,  ,  ) ) ; } } return  ; }<CODESPLIT>Ensures that all elements in the argument floating point array are within the inclusive range
public static void copy ( InputStream inputStream , OutputStream outputStream ) throws IOException { copy (  ,  , true ) ; }<CODESPLIT>Writes the content provided by the given source input stream into the given destination output stream .
private static Collection < Tuple > getTuples ( List < VarDef > varDefs , int varStart , int varEnd , int tupleSize ) { Collection < Tuple >  = new ArrayList < Tuple > ( ) ; for ( int  =  ;  <  ;  ++ ) { VarDef  =  . get (  ) ; Iterator < VarValueDef >  =  . getValidValues ( ) ; if ( !  . hasNext ( ) ) { throw new IllegalStateException ( "Can't complete tuples -- no valid values defined for var=" +  ) ; } Collection < Tuple >  =  == 1 ? null : getTuples (  ,  + 1 ,  + 1 ,  - 1 ) ; if (  == null ) { while (  . hasNext ( ) ) {  . add ( new Tuple ( new VarBindingDef (  ,  . next ( ) ) ) ) ; } } else if ( !  . isEmpty ( ) ) { while (  . hasNext ( ) ) { VarBindingDef  = new VarBindingDef (  ,  . next ( ) ) ; for ( Tuple  :  ) { Tuple  = new Tuple (  ) . addAll (  ) ; if (  . isCompatible ( ) ) {  . add (  ) ; } } } } } return  ; }<CODESPLIT>Returns all valid tuples of values for the given input variables .
public V get ( K key ) { final int  = hash (  ) ; final int  = indexOf (  ) ; for ( Entry < K , V >  =  [  ] ;  != null ;  =  . next ) { if (  . hashCode ==  &&  . key . equals (  ) ) { return  . value ; } } return null ; }<CODESPLIT>Looks up the value mapped under the given key . Returns null if no value is mapped under this key .
public boolean validSecondFactor ( String secret , String number ) {  . requireNonNull (  ,  . SECRET . toString ( ) ) ;  . requireNonNull (  ,  . TOTP . toString ( ) ) ; return  . verifiedTotp (  ,  ) ; }<CODESPLIT>Checks if a given number for 2FA is valid for the given secret
protected void updateOutgoingEdgesStateDL ( int currS , int currL , int prevS , int prevL , Emissions emission ) { updateOutgoingEdges (  ,  ,  . DL ,  ,  ,  . DL ,  . t_DL_in ,  ) ; updateOutgoingEdges (  ,  ,  . DL ,  ,  ,  . S ,  . t_S_to_DL ,  ) ; }<CODESPLIT>Enumerates the possible transitions into state DL .
public void setPrefix ( String key , String prefix ) { PdfName  = new PdfName (  ) ; PdfObject  = get (  ) ; if (  == null ) throw new IllegalArgumentException ( "You must set a value before adding a prefix." ) ; PdfDictionary  = new PdfDictionary (  . COLLECTIONSUBITEM ) ;  . put (  . D ,  ) ;  . put (  . P , new PdfString (  ,  . TEXT_UNICODE ) ) ; put (  ,  ) ; }<CODESPLIT>Adds a prefix for the Collection item . You can only use this method after you have set the value of the item .
protected AbstractExpression replaceExpressionsWithPve ( AbstractExpression expr ) { assert (  != null ) ; if (  instanceof TupleValueExpression ) { int  =  . getNextParamIndex ( ) ; ParameterValueExpression  = new ParameterValueExpression (  ,  ) ;  . put (  ,  ) ; return  ; } if (  instanceof AggregateExpression ) { int  =  . getNextParamIndex ( ) ; ParameterValueExpression  = new ParameterValueExpression (  ,  ) ; List < TupleValueExpression >  =  . getTupleValueExpressions (  ) ; assert (  != null ) ; for ( TupleValueExpression  :  ) { int  =  . getOrigStmtId ( ) ; if (  !=  &&  . m_stmtId !=  ) { throw new PlanningErrorException ( "Subqueries do not support aggregation of parent statement columns" ) ; } }  . put (  ,  ) ; return  ; } if (  . getLeft ( ) != null ) {  . setLeft ( replaceExpressionsWithPve (  . getLeft ( ) ) ) ; } if (  . getRight ( ) != null ) {  . setRight ( replaceExpressionsWithPve (  . getRight ( ) ) ) ; } if (  . getArgs ( ) != null ) { List < AbstractExpression >  = new ArrayList < > ( ) ; for ( AbstractExpression  :  . getArgs ( ) ) {  . add ( replaceExpressionsWithPve (  ) ) ; }  . setArgs (  ) ; } return  ; }<CODESPLIT>Helper method to replace all TVEs and aggregated expressions with the corresponding PVEs . The original expressions are placed into the map to be propagated to the EE . The key to the map is the parameter index .
private static boolean addCallback ( String applicationId , DelayedCallback callback ) { boolean  = false ; List < DelayedCallback >  =  . get (  ) ; if ( null ==  ) {  = new ArrayList < DelayedCallback > ( ) ;  . put (  ,  ) ;  = true ; }  . add (  ) ; return  ; }<CODESPLIT>Add a delayed callback for the given application id . Returns whether this is the first request for the application id .
public static byte [ ] gunzipBytes ( byte [ ] compressedBytes ) throws IOException { ByteArrayOutputStream  = new ByteArrayOutputStream ( ( int ) (  . length * 1.5 ) ) ; InflaterOutputStream  = new InflaterOutputStream (  ) ;  . write (  ) ;  . close ( ) ; return  . toByteArray ( ) ; }<CODESPLIT>to avoid linking all that jazz into the client code
public TupleValueExpression getOutputExpression ( int index ) { SchemaColumn  = getSchemaColumn (  ) ; TupleValueExpression  = new TupleValueExpression ( getTableAlias ( ) , getTableAlias ( ) ,  . getColumnAlias ( ) ,  . getColumnAlias ( ) ,  ) ; return  ; }<CODESPLIT>Produce a tuple value expression for a column produced by this subquery
