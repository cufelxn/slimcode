public ExampleData getSelectedExampleData ( ) { < String > = ( ; ( allSelectedItems null || isEmpty ) { return null ; } for ( String selectedItem allSelectedItems ) { List < Integer > rowIndex = . selectedItem ) ; ) . ( ) ; } return null }<CODESPLIT>Get the example which is selected in the tree .
public dimAt float alpha ) ( ! ) return } if ( mDimView == null ) { ; } if ( ! mDimView . isShown ( ) { mDimView . setVisibility ( VISIBLE ) ; . setBackgroundColor ( mDimColor ; mDimView . setAlpha ; }<CODESPLIT>Set the dim - behind layer a specific opacity .
public Path extract { if ( isFound ( ) ) throw new "Extract only called extractSW . start ) ; currEdge = ; ( currEdge . adjNode ) boolean nextEdgeValid = EdgeIterator Edge ( currEdge . ; int nextEdge ; while ) nextEdgeValid = . Edge . ( currEdge . parent . edge ; nextEdge = nextEdgeValid ? currEdge . edge : . NO_EDGE ; processEdge ( currEdge edge , . , ; currEdge . parent } currEdge . adjNode ) reverseOrder ( ) ; extractSW . stop ; return setFound ( true ) ; }<CODESPLIT>Extracts the Path from the shortest - path - tree determined by sptEntry .
public writeInt ( byte [ target , int , int { [ offset ] = byte ( 24 ) [ offset + 1 ] = ( byte ) value >>> 16 ) target [ ] ) value >>> 8 ) ; target [ offset + 3 ] = ( ) ; return Integer . BYTES ; }<CODESPLIT>Writes the given 32 - bit Integer to the given byte array at the given offset .
void visitGetElem Node n . expectIndexMatch ( n , getJSType ( n . getFirstChild ( ) ) , getJSType ( ) ) ) ; ( n ; }<CODESPLIT>Visits a GETELEM node .
private Class < > getTypedClass java . lang . reflect . type ) if ( type { return Class ) ; else if ( type instanceof ParameterizedType ) java . lang . . ( ) getRawType ( ) return ( rawParamterizedType ; } else ( type instanceof TypeVariable ) { . lang . reflect . Type upperBound ( TypeVariable ) type ) . getBounds ( ) [ ] ; return getTypedClass ( ) ; } throw new IllegalArgumentException while generic class for :" + ) ; }<CODESPLIT>Gets the typed class .
URI toUri path ) { fileStore . state ( ( ) ; return pathService . toUri ( uri , path . ) ; }<CODESPLIT>Gets the URI of the given path in this file system .
getActivityInterface ( { if ( activityInterface == null ) new ActivityInterface ( apiKey , sharedSecret , ) ; } ; }<CODESPLIT>Get the ActivityInterface .
private void initBeforeList ) { final List < > = new ArrayList > ( ) ; final Method invokeHolder = getInvokeHolder ( ) < ? > = . getDeclaringClass ( if processorClass && . isAnnotationPresent ( Before . ) { final Class < ? ProcessAdvice [ ] = processorClass . getAnnotation ( Before . ) . value ( ) ; for ( i = 0 i bcs . length i ++ ) < extends > bc i ] final ProcessAdvice = BeanManager . getInstance ( . bc ) ; . add ( beforeRequestProcessAdvice ; } if ( invokeHolder . ( Before . class ) { final Class ? ProcessAdvice [ ] bcs = invokeHolder getAnnotation ) . value ( ) for int = i < bcs . length ; i ++ ) { Class < extends > = bcs [ i final beforeRequestProcessAdvice = BeanManager . ( ) . getReference ( bc ) ; beforeRequestProcessAdvices ( beforeRequestProcessAdvice ) } this beforeRequestProcessAdvices = beforeRequestProcessAdvices ;<CODESPLIT>Initializes before process advices .
void init ) { jsFactory = JsonFactory ( ; . ( JsonParser . Feature . ALLOW_COMMENTS , true ( JsonParser . Feature . ALLOW_SINGLE_QUOTES , true ) jsFactory . configure ( JsonParser . ALLOW_NON_NUMERIC_NUMBERS , true ; }<CODESPLIT>Creates the JsonFactory .
void flushStackLocalLeaks Looper looper ) handler = Handler looper { public void handleMessage ( Message msg ) ) , THREAD_LEAK_CLEANING_MS ) ; } } ; handler . sendMessageDelayed ( handler . ) , THREAD_LEAK_CLEANING_MS ; }<CODESPLIT>Prior to Android 5 HandlerThread always keeps a stack local reference to the last message that was sent to it . This method makes sure that stack local reference never stays there for too long by sending new messages to it every second .
void addReset String label ) { ( buttons null buttonsAtBottom ) ; Element e = new Input ( , label ) ; if ( extendRow ) addField null , e ) ; else add ( e ; }<CODESPLIT>Add a reset button .
int getMaximumVolume Context context ) { return ( ( . getSystemService ( Context . AUDIO_SERVICE ) ) . getStreamMaxVolume ( AudioManager ; }<CODESPLIT>Returns maximum volume the media volume can have
@ SuppressWarnings ( "checkstyle:npathcomplexity" ) public ( ISREInstall sres { final ISREInstall defaultSRE = ( ) ; final defaultId = defaultSRE == ? : . getId ( ) ; int defaultIndex = - 1 ; if ( defaultId != ) { for int = defaultIndex - && i < this . getItemCount ; ++ i ) { if defaultId . ( ( ) sreTable . getItem ( i getData ( ) ) . getId ) ) ) defaultIndex = ; } } } final normedDefaultId = Strings nullToEmpty ( ; boolean = false ; for ( final sre : sres ) { ( this . sreArray remove ( && . getId ( . equals normedDefaultId ) { defaultIsRemoved = true ; } refreshSREListUI ( ) ; if ( defaultIsRemoved { if ( . . getItemCount ( ) setSelection ( null } { ( defaultIndex < ) { defaultIndex 0 } else if >= sreTable . getItemCount ( ) { = this . sreTable getItemCount ( ) 1 ; setSelection new ( . getItem ) . getData ( ) ) } } this . . refresh true ) ; if ( defaultIsRemoved { ( ) ; } ( ; }<CODESPLIT>Removes the given SREs from the table .
public WikiUser ( String wikiId , String ) WikiUser result = ; try { Properties props = ( wikiId ) ; WikiUser ( ) result setUsername props getProperty ( ; result setEmail ( props . getProperty ) ) ; Crypt pcf = Crypt props . ( "cypher" ) , props . getProperty ( ) ) ; result . setPassword ( . decrypt ( . ( "secret" ) ) ; } e { msg = , siteurl ; LOGGER log ( Level . SEVERE msg } ( e ) { LOGGER log ( Level . SEVERE , e getMessage ) ) catch ( GeneralSecurityException e ) { LOGGER log ( Level . SEVERE , e . getMessage ( ; return result ; }<CODESPLIT>get the Wiki user for the given wikiid
public ( ) { int = 0 ; { T delegate next ( ) ; ( alreadyGenerated ( next { alreadyGenerated . add ( next ) ; return ; } retryCount ++ } while numberOfRetries new ( on ( " " ) . join ( "Exhausted" , numberOfRetries , trying generate unique value" ) ) ; }<CODESPLIT>Returns unique &lt ; T&gt ; generated by delegate Generator&lt ; T&gt ;
boolean isAllowedInsideList Node node ) ( node getNodeType ) Node . ELEMENT_NODE || node . getNodeName ( ) ) && ( node . getNodeType ( ) Node . TEXT_NODE || node . getNodeValue ( ) trim ( . ( == ) ; }<CODESPLIT>Checks if a given node is allowed or not as a child of a &lt ; ul&gt ; or &lt ; ol&gt ; element .
public static ResidueNumber [ ] matchSequenceToStructure seq , struct { Map < Integer , > atomIndexPosition = new < Integer , Group > ( ; structSeq = getProteinSequenceForStructure ( struct , atomIndexPosition ) ; SubstitutionMatrix < AminoAcidCompound > matrix = new SimpleSubstitutionMatrix < AminoAcidCompound ( . ) ( ) 1 , ( short 1 matrix = new SimpleSubstitutionMatrix < AminoAcidCompound ( AminoAcidCompoundSet getAminoAcidCompoundSet ( new SimpleSubstitutionMatrix . class . getResourceAsStream ) ) , "blosum100" ) ; < ProteinSequence , > pair Alignments . getPairwiseAlignment ( seq structSeq , PairwiseSequenceAlignerType GLOBAL , ( ) matrix ) ; AlignedSequence < ProteinSequence AminoAcidCompound > alignedSeq = pair getQuery ( ) ; < ProteinSequence > = pair . ( ) assert ( . getLength ( ) == . getLength ( ) ) ; ResidueNumber [ ca = new [ . getLength ( ) int pos = alignedSeq getStart ) getPosition ( ) pos <= alignedSeq getEnd ) . getPosition ; ) { if ( alignedSeq isGap pos ) ) { structIndex = alignedStruct getSequenceIndexAt ( ) 1 assert 0 ) g = atomIndexPosition . get ( ; logger . warn "Chain {} {} in the Structure {} has corresponding acid in the sequence." g getChainId ( ) , . getResidueNumber ( ) toString ( ) , g . getChain ) getStructure ) . ( ) ; continue ; } if ( ! . ( ) ) { int = . pos ) - 1 ; = alignedStruct . getSequenceIndexAt ( ) - g = atomIndexPosition . get structIndex ; ( 0 seqIndex && seqIndex < ca . [ seqIndex ] . getResidueNumber ( } return }<CODESPLIT>Given a sequence and the corresponding Structure get the ResidueNumber for each residue in the sequence .
@ SuppressWarnings ( { "unchecked" } static IMeta ( < ? , ? > , IMetaData < ? ? > metaData2 ) { Map String Object > map1 = ( ( Map < String , Object > ) metaData1 ) Set < Entry String Object set1 map1 entrySet ( ) ; Map , map2 = ( ( Map < , Object ) metaData2 Set < String , Object > = map2 . entrySet ( ) Map < String Object > = new HashMap < String Object > ( ; for < String Object > entry1 : set1 ) String key1 = entry1 . ( ) ; if map2 . key1 ) { Object = map1 get ( ) ; Object value2 = . get ( key1 ) ; if ( instanceof Double ) if Double . valueOf ( ) ) . doubleValue ) Double valueOf ( value2 toString ( ) . ( ) ) . key1 , value2 ) ; } if ( value1 instanceof ) { if Integer . ( . ( intValue ( Integer . valueOf ( value2 . ) ) . intValue ) ) rep . put ( key1 , ) } } else if value1 Long ) { if Long . valueOf ( . toString ( ) ) . longValue ) Long . valueOf ( . toString ) ) . ( ) rep put key1 , value2 ) } if instanceof Boolean ) { if ( ! Boolean . ( toString ( ) && Boolean valueOf ( toString ) ) ) rep . put ( value2 ) ; } } } set1 . removeAll ( rep entrySet ( ) ) ; set1 . entrySet ( ; set1 . ; return }<CODESPLIT>Merges the two Meta objects
List < > subList ( , int ) while allResults . size ( ) < arg1 && moveNextResults ( ) ; } return Collections . unmodifiableList ( allResults . subList , arg1 ) ; }<CODESPLIT>Returns a sub - list in the range specified loading more results as necessary .
private ( String channel , message , Recipient [ ] ) { message setMetadata ( , ; message setMetadata ( "cwf.pub.channel" , ) message . setMetadata ( "cwf.pub.event" , UUID . randomUUID ( ) . toString ( ) . currentTimeMillis ( ) ; message . setMetadata ( "cwf.pub.recipients" recipients ) ; return message }<CODESPLIT>Adds publication - specific metadata to the message .
private T > GraphRequest < T graph ( String , type Param params ) this . ) < T > req = GraphRequest < T > object , params , this . mapper , this . < type this . graphRequests . add ( req ) ; return req }<CODESPLIT>The actual implementation of this after we ve converted to proper Jackson JavaType
public void writeLength long length { if length 251 ) { buf [ position ++ ] = ( byte ) length ; } < 65536 { [ position ++ ( ; buf position ++ ] = ( byte length ; buf [ position ++ = ( byte ) length >>> 8 ; } else ( length < 16777216 ) { buf [ ++ ] = byte 0xfd ; buf position ++ ] ) length ; buf [ position ( byte ( length >>> 8 ) ; buf [ ++ ( byte length >>> 16 ) } else buf [ position ++ = ( byte ) ; buf [ position ] ( ) length ; buf [ ++ ) ( length >>> 8 ; [ ++ ( byte ) ( length >>> 16 ) [ position = ( byte ) ( length 24 ) buf [ position byte ) ( ) [ position ++ = ( ( length 40 ) [ position ] = ( byte ) ( length >>> 48 ) ; buf [ position ++ = ( byte ( length 54 ) ; } }<CODESPLIT>Write length .
public < TSource TResult > < TResult > map ( Collection TSource > , Mapper < > mapper if ( items ) ) { return new ArrayList < > ) ; } List TResult ArrayList items size ( ) ; ( TSource : items ) { TResult mappedItem = mapper . map item ) ; result . add ( ) ; } return result ; }<CODESPLIT>Projects each element of a collection into a new collection .
static void final Number real , final ContentHandler handler ) { serializeElement ( "real" , String . valueOf ( doubleValue ) , handler ; }<CODESPLIT>Serialize a Number as a real element .
public JMenuBar setupStandardMenu ( ActionListener bAddHelpMenu ) { Application application = BaseApplet . getSharedInstance ( . getApplication ( ) ResourceBundle oldResources = application . getResourceBundle ) ; application getResources ( null , true ) ; this . setupActions ( targetAction ; JMenuBar menuBar = JMenuBar ) static long = 1L ; public Dimension ( ( . getMaximumSize ) , super . ( height ) ; } . setOpaque ( false ) ; JMenu menu char ] rgchItemShortcuts new char [ 20 = this . addMenu ThinMenuConstants . ) ; this . addMenuItem , . PRINT , rgchItemShortcuts ) ; . addSeparator ( ) ; . addMenuItem ( menu , ThinMenuConstants . LOGON rgchItemShortcuts ) ; this . addMenuItem menu ThinMenuConstants . LOGOUT , rgchItemShortcuts ) ; this addMenuItem ( menu CHANGE_PASSWORD , rgchItemShortcuts ) menu . addSeparator ( ) ; this addMenuItem menu ThinMenuConstants . CLOSE rgchItemShortcuts ) ; = char [ 20 ] . ( , . EDIT ) ; this . , ThinMenuConstants . CUT , rgchItemShortcuts ; addMenuItem ( COPY , rgchItemShortcuts ) ; . menu , ThinMenuConstants . PASTE , rgchItemShortcuts menu . addSeparator ( ) addMenuItem ( menu , , rgchItemShortcuts ) ; ( oldResources != ) application . setResourceBundle ( oldResources ) ; if ( ) = this . ) ; return menuBar ; }<CODESPLIT>Setup the standard menu items .
static String ( ) { final prefs = Preferences . ( . class ) ; if ( prefs != . get ( "LANE_COUNT_ATTR_NAME" DEFAULT_ATTR_LANE_COUNT ) ; } return ; }<CODESPLIT>Replies the preferred name for the number of lanes of the roads .
public nsrollbackcmd [ ] get ( , nsrollbackcmd_args ) Exception nsrollbackcmd obj = new nsrollbackcmd ( ) option ( ) ; option . set_args ( nitro_util . ( args ) ) ; nsrollbackcmd [ ] response ( ] ) obj . ( option ) return response }<CODESPLIT>Use this API to fetch all the nsrollbackcmd resources that are configured on netscaler . This uses nsrollbackcmd_args which is a way to provide additional arguments while fetching the resources .
private translateElementNo ( int i ) if ( ! || < ) return i } int 0 rule = ( PatternRule ) this . rule ; for int k = 0 ; k < i ; ++ j += rule ) . ( ) ; } return j }<CODESPLIT>Gets the index of the element indexed by i adding any offsets because of the phrases in the rule .
String [ getProxyHostsWhiteList ( ) { ( _proxyHostsWhiteList null _proxyHostsWhiteList size ( ) == 0 ) return new String [ ] hosts = new String [ _proxyHostsWhiteList size ( ) ] ; hosts = ( String ] ) . ( ) return ; }<CODESPLIT>Get proxy host white list .
public addMetatypeAd ( MetatypeAd metatypeAd ) if ( this metatypeAds null this metatypeAds = new LinkedList < ( ( MetatypeAd ad : metatypeAds ) if ( ad getID ( ) . equals ( metatypeAd . getID ) return false ; this metatypeAds add ) ; return true }<CODESPLIT>Adds a metatype AD .
public skip ( n ) IOException { if ( mInputStream . ( ) n ) { skip ( ; } close ( ) ; mPos += n ; try mObject = mClient . ( null null null , mPos null ; mInputStream new BufferedInputStream ( mObject . getDataInputStream ( ) ) ; catch ( e ) { throw new IOException ( ) ; } return n ; }<CODESPLIT>This method leverages the ability to open a stream from GCS from a given offset . When the underlying stream has fewer bytes buffered than the skip request the stream is closed and a new stream is opened starting at the requested offset .
static boolean ( JCTree tree ) Name name calledMethodName tree ; if ( name != null ) { table . names ; return name == names . _super ; { return false } }<CODESPLIT>Is this a call to super?
public static String getShortRequestDump ( String boolean includeHeaders HttpServletRequest ) { StringBuilder dump = StringBuilder ( ) ; append ( "Timestamp : " . ( ISO8601 . getTimestamp ( ) ) . append ( "\n" ) ; dump . append ( "fromMethod : ) append ) append "\n" ) ; dump . "Method ) . append ( request . ( ) . append ) . append ( "Scheme : append ( request . getScheme ) ) . ( '\n' ; dump . append ( : " ) append ( getRequestURI ( ) . append ( '\n' ) dump . append ( "Query-String " ) . append request . ) . append ( ) ; . append "Auth-Type : " ) . ( request . getAuthType ( ) ) . ( '\n' ) dump append ( "Remote-Addr : ( request . getRemoteAddr ) . ( '\n' ) dump . append "Scheme " ) . request ( ) ) . append '\n' ; dump . append "Content-Type : " . append request getContentType ) ( '\n' dump . append ( "Content-Length: " append ( request . ( ) . append ( '\n' ) ; ( includeHeaders ) { dump . append :\n" ) Enumeration String > headers = getHeaderNames ( ) ; while ( headers . ( ) ) header = . nextElement ( ) . append ( "\t" ) append ( ) . append ( " ) . ( request . getHeader ( header ( '\n' ) } return ( ( ) }<CODESPLIT>Build a String containing a short multi - line dump of an HTTP request .
static void ( String stringToCheck , trim , argumentName throws { validateNotNull ( stringToCheck , argumentName ) ; ( ) == 0 || ( trim && stringToCheck trim ( ) . length ( ) == 0 ) { new ( + ) } }<CODESPLIT>Validates that the string is not null and not an empty string .
static JPanel ) { JPanel _panel = new JPanel _panel . setLayout ( new BoxLayout ( _panel , ) ) return _panel ; }<CODESPLIT>Create a panel that lays out components vertically .
boolean shouldAnalyze ) { instanceof FileTypeAnalyzer ) { final FileTypeAnalyzer fileTypeAnalyzer = ( FileTypeAnalyzer ) analyzer ; return fileTypeAnalyzer . getActualFile ( ) ) } return ; }<CODESPLIT>Determines if the analyzer can analyze the given dependency .
void registerServiceClass serviceClass ) { registeredServiceClasses . put ( serviceClass ( ) , serviceClass ) ; Settings . Services ( . ( ) ; }<CODESPLIT>Registers a service enabling the service layer to automatically start autorun servies .
String getSectionText pageTitle , int sectionNumber ) throws Exception = this . getPageContent ( pageTitle , "&rvsection=" + sectionNumber , false result ; }<CODESPLIT>get the text for the given section
public double ( int [ , int ] ) if ( x . length != y . ( String . format ( "Arrays have different length: y[%d]" , x . length , y . length ) ; return 1 Math cor ( x ; }<CODESPLIT>Pearson correlation distance between the two arrays of type int .
static TileGrid Point point , int zoom ) { Projection ProjectionFactory . getProjection ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) ; ( , , projection ; }<CODESPLIT>Get the tile grid for the location specified as WGS84
List < > getVectorLayers ( ArrayList < > = ArrayList < VectorLayer > ( ) ; for layer : layers ) { if ( layer instanceof ) { list . add ( ( VectorLayer ) } } return ; }<CODESPLIT>Return a list containing all vector layers within this model .
private void calcRmsd [ ] x , Point3d [ ] y ) ( ) innerProduct y x ) ; else { = CalcPoint clonePoint3dArray x ) ; xtrans = . centroid xref ; . debug ( "x + xtrans ) ; xtrans ( ; CalcPoint translate ( new ( xtrans ) , xref ) yref = CalcPoint . ( y ytrans = . centroid ( yref ) ; . "y " ) . negate ( ; translate ( new Vector3d ( ytrans ) yref ) ; innerProduct ( yref , ) } calcRmsd ( wsum ) ; }<CODESPLIT>Calculates the RMSD value for superposition of y onto x . This requires the coordinates to be precentered .
public setSectionHeading Title v ) ( Section_Type featOkTst ( Section_Type ) jcasType ) . casFeat_sectionHeading == null throwFeatMissing ( "sectionHeading" , "de.julielab.jules.types.Section" ) ; jcasType . . ll_setRefValue ( addr , ( ( Section_Type ) ) . casFeatCode_sectionHeading , . . ll_getFSRef ( ; }<CODESPLIT>setter for sectionHeading - sets the title of the section
public Response process ( InputStream is IOException , , { SxmpParser parser = new ( version ) ; operation = null ; try { = parser . parse ( is ) ; } catch ( SxmpParsingException e ) { if ( e . getOperation ( != && getOperation ) getType ( ) != null logger ( "Unable to fully parse XML a request, ErrorResponse; error: e ( ) + ", parsed: e . getOperation ( ) ) return new ErrorResponse e . ( ) . getType ( , e . ( ) ( ) e . getErrorMessage ( ) ) } else { throw new ( e . getMessage ) , ; } try { ( ! operation instanceof ) ) { throw new ( SxmpErrorCode . UNSUPPORTED_OPERATION , "A session can process requests" ) } req = ( Request ( req . getAccount ) null { throw new ( SxmpErrorCode . , request must include ) if ( ! processor . ( . getAccount ( ) ) { throw SxmpErrorException ( . , failure" ) if ( SubmitRequest ) { return processor . req . getAccount ( , ( ) operation ) ; } else ( instanceof DeliverRequest ) { processor deliver ( req . ( ) , ( ) operation ) ; } else if operation DeliveryReportRequest ) { return . deliveryReport req . getAccount ( ) , DeliveryReportRequest ) ) } else { throw SxmpErrorException , "Unsupported operation type" ) ; } } catch ) { . warn . getMessage ( ) return new ErrorResponse operation . getType ( ) , e . ( ) . e . getErrorMessage ( catch ( Throwable ) logger . error ( "Major uncaught processing request, generating an ErrorResponse" , t ; return new ErrorResponse ( operation , . GENERIC ( ) , request" ) }<CODESPLIT>Processes an InputStream that contains a request . Does its best to only produce a Response that can be written to an OutputStream . Any exception this method throws should be treated as fatal and no attempt should be made to print out valid XML as a response .
private void submitPayload ( String url . ConnectionSettings , jsonPayloadObject , pushApplicationId , masterSecret , MessageResponseCallback callback List < String > redirectUrls ) if ( redirectUrls . contains ( url ) ) { throw new PushSenderException ( "The site an infinite redirect url: + ; else redirectUrls . add ( url } = null ; try { final credentials = + ':' ; encoded = Base64 . encodeBytes . getBytes ( UTF_8 ) ) ; httpURLConnection = ( ) HttpRequestUtil post ( url , encoded jsonPayloadObject , proxy , connectionSettings ) final int statusCode = httpURLConnection . ( ) logger . ( Level . INFO String . "HTTP code from UnifiedPush %s" , ) ) if ( isRedirect ( statusCode ) String redirectURL = httpURLConnection . getHeaderField "Location" ) . ( Level . INFO . ( "Performing to , ) ; submitPayload ( pushConfiguration . ( , jsonPayloadObject , masterSecret , redirectUrls ) ; } if statusCode >= 400 ) logger . log Level . SEVERE , Unified Server returned " + ) ; throw new PushSenderHttpException ( statusCode } else { if callback != ) { callback . ; } } catch ( PushSenderHttpException pshe { throw pshe ; } catch ( Exception e { logger log ( Level . INFO , while trying to send the request" e ) ; throw PushSenderException ( e getMessage ( ) , e ) finally if ( httpURLConnection ) { httpURLConnection ) ; } }<CODESPLIT>The actual method that does the real send and connection handling
public [ ] ( ) if ( children null || size ) == 0 ) EMPTY_NAMES ; String arr = [ children . size ( ) ] ; for int i = 0 i ; { [ i ] = ( ( RamResourceCore ) children . get ( i ) ) getName ) ; } return arr ; }<CODESPLIT>Gibt den Feldnamen children zurueck .
public static Object Object array , int index ) throws UtilTargetError { debug "getIndex: , , index=" , index ; try if ( instanceof ) return ( ( List ? > array . ( index ) ; val = Array . get ( index ; return . wrap ( , Types . arrayElementType ( array . getClass ( ) ) ; } IndexOutOfBoundsException e1 { int len = array instanceof ? List ? array ( ) Array ( array ) ; throw new UtilTargetError ( " index + " out-of-bounds for " len , e1 ) ; } }<CODESPLIT>Get object from array or list at index .
public base_response add nitro_service client aaakcdaccount resource throws Exception { addresource = aaakcdaccount ( ) ; kcdaccount = kcdaccount ; keytab = resource . keytab ; addresource . realmstr resource . realmstr ; . delegateduser kcdpassword resource . kcdpassword addresource . usercert = . usercert ; addresource . cacert = resource . cacert return . add_resource ( client ) ; }<CODESPLIT>Use this API to add aaakcdaccount .
public synchronized void ( ) { if ( . ( ) && . isEntryEnabled ( ) ) SibTr . entry ( this , this ) boolean = false ; ! ) { { if ( TraceComponent . ) && tc . isDebugEnabled ( ) . debug this , tc , "Waiting to get lock" ) ; wait ( 1000 ) ; catch ( InterruptedException ) interrupted = true } } while 0 { { if isAnyTracingEnabled ( && tc isDebugEnabled ( ) ) debug , tc , lock count to 0 " iLockCount ) ; wait 1000 ) ; } ( InterruptedException e ) { interrupted = true } } if ( ) { . currentThread ) . ( ) if ( TraceComponent isAnyTracingEnabled ( ) && tc . isEntryEnabled ( ) SibTr . exit ( tc "lockExclusive" ) ;<CODESPLIT>This method locks the mutex so no other lockers can get the lock .
setCPOptionValueLocalService ( . liferay . commerce . product . cpOptionValueLocalService ) { this . cpOptionValueLocalService = ; }<CODESPLIT>Sets the cp option value local service .
static String ( TypeDeclaration type ) PackageDeclaration pkg = getPackage ) ; return pkg != null ? '/' + ) . replace '.' , '/' ) : ; }<CODESPLIT>Infers the Struts module path from the given controller class .
final int getLeapMonth cycle , int yearOfCycle ) { int [ ] this getLeapMonths ) = ( cycle 1 ) 60 + - ; int index = 2 ( ( elapsedYears - [ ] ) / 3 int lm = 0 ; ( < leapMonths length ) ) int test = leapMonths [ index ; if ( test < elapsedYears ) += Math max ( 2 * ( ( - / ) ) else if ( > { break ; } else lm = leapMonths [ index + 1 break ; } } return lm ; }<CODESPLIT>number of leap month or zero if no leap year
public getSnippet ( snippetId , downloadContent ) throws { if snippetId == ) { throw new ( "snippetId can't ) ; response = get ( Response . Status . OK null , "snippets" , ) response Snippet class ) ; if ( ) { . setContent ( getSnippetContent ( snippet . getId ) ) ; } return snippet ; }<CODESPLIT>Get a specific Snippet .
public final int ( int codePoint ) { value int ix ; ( codePoint >= 0 ) { if ( codePoint < 0x0d800 > 0x0dbff && <= ) ) { index UTRIE2_SHIFT_2 ] ix = ( ix << + ( codePoint & UTRIE2_DATA_MASK ) value data32 [ ] ; return value ; } if codePoint <= 0xffff ) { ix = index UTRIE2_LSCP_INDEX_2_OFFSET + ( codePoint 0xd800 ) >> ) ] ; ix UTRIE2_INDEX_SHIFT + ( ) ; = data32 ix ] ; return } codePoint < highStart { ix = ( - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + ( codePoint >> ) ; ix = [ ix ] ; += codePoint UTRIE2_SHIFT_2 ) & UTRIE2_INDEX_2_MASK ; = ix ; ix = ( ix UTRIE2_INDEX_SHIFT ( codePoint & ) value = data32 [ ] return value ; } if ( <= 0x10ffff ) { value = [ highValueIndex ] ; value } return errorValue ;<CODESPLIT>Get the value for a code point as stored in the Trie2 .
static Object ( String name , attrName ) throws MBeanServer = getMBeanServer ( ) ; ObjectName objName = new ; return server getAttribute ( objName , attrName ; }<CODESPLIT>Get MBean attribute object
public void setSelectedIndex final int ) { if ( items . ( ) selectedIndex || selectedIndex ) { IndexOutOfBoundsException ( to " + selectedIndex ) ; } final oldSelection = this . ; selectedIndex selectedIndex - 1 ) updateText "" ) } else { updateText ( items . get ( selectedIndex . toString ( ) ) ; } new Runnable ) { public void run ( ) for ( Listener listener : listeners listener . onSelectionChanged ( , oldSelection ; } } ) invalidate ( ) ; }<CODESPLIT>Programmatically selects one item in the combo box which causes the displayed text to change to match the label of the selected index .
getPhotoStats ( photoId , Date date ) throws FlickrException ( METHOD_GET_PHOTO_STATS , "photo_id" , photoId , date ; }<CODESPLIT>Get the number of views comments and favorites on a photo for a given date .
public ServiceCall < > getDocumentStatus ( GetDocumentStatusOptions getDocumentStatusOptions { . notNull ( , "getDocumentStatusOptions cannot be ) String [ ] pathSegments , "collections" , } String ] = { ( ) getDocumentStatusOptions . collectionId ( ) . documentId ( ) } ; builder RequestBuilder . ( RequestBuilder . constructHttpUrl ( getEndPoint ( ) pathSegments , pathParameters ) ) ; builder query ( "version" versionDate ; Map < , String > . ( , "v1" ; for Entry < , String > header : . ) ) { . header ( header getKey ( , header . getValue ) ) } builder ( "Accept" , "application/json" ) ; createServiceCall ( builder . build ( ) , ResponseConverterUtils . getObject . ) ) ;<CODESPLIT>Get document details .
Pager < > getClosesIssues ( , Integer , itemsPerPage throws GitLabApiException { return new Pager < Issue . class , itemsPerPage , null , "projects" , getProjectIdOrPath ( projectIdOrPath ) , mergeRequestIid , "closes_issues" ; }<CODESPLIT>Get a Pager containing all the issues that would be closed by merging the provided merge request .
public static final ( Class < ? > clazz , String msg ... e ) if { String "" ; e null e . length == 1 { StringWriter sw = StringWriter ; PrintWriter pw ( ) ; e 0 . printStackTrace pw ) ; . flush ( ) ; exceptionStr "exception = " + sw . toString ; } . err . println ( "[" + . format ( Date ) + "]" + "-" + + . getSimpleName ( ) + "] " + " + exceptionStr ) ; } }<CODESPLIT>To output the error log message to the error out
static HtmlTree ( HtmlStyle styleClass , scope , body { htmltree = new HtmlTree ( HtmlTag . TH ) ; if ( styleClass != null ) htmltree addStyle ( styleClass ) ; htmltree . addAttr ( . SCOPE nullCheck scope ) return ; }<CODESPLIT>Generates a TH tag with style class and scope attributes and some content .
void obtainDividerMargin final int themeResourceId TypedArray typedArray getContext ) getTheme ( ) . obtainStyledAttributes ( themeResourceId , R . attr . materialDialogDividerMargin } ) ; setDividerMargin ( typedArray . getDimensionPixelSize , 0 ) ; }<CODESPLIT>Obtains the left and right margin of dividers from a specific theme .
setDefaultButton ( button ) { this . getScreenFieldView ( ( button == null ? null : . getScreenFieldView ( ; }<CODESPLIT>Set the default button for this basepanel .
Key select int k ) ( k 0 k size ( root ) ) throw new IllegalArgumentException Key , Value > x = select ( root , k ) ; . getKey ( ; }<CODESPLIT>Return the kth smallest key in the symbol table .
void add RequestHandler request ) { . writeLock ( ) lock ) ; try { newSessionRequests . add ( { lock . writeLock ) . unlock ( ) } }<CODESPLIT>Adds a request handler to this queue .
static < > T withPrintWriter ( stream , ClosureParams value SimpleType . class , options = "java.io.PrintWriter" ) ) throws IOException { return withWriter ( newPrintWriter stream ) , closure ; }<CODESPLIT>Create a new PrintWriter for this OutputStream . The writer is passed to the closure and will be closed before this method returns .
addRegexRoute ( urlPattern , Class < ? extends Actor throws RouteAlreadyMappedException { addRoute ( new Route ( urlPattern , true ) ; }<CODESPLIT>Add a URL pattern to the routing table .
public synchronized void ( KeenProject project , KeenCallback ) if ( ! ) { handleLibraryInactive ( callback ) ; return ; } if null && defaultProject null { handleFailure ( , new ( project specified, no default project found" ) return ; } if ( ! ( ) { . log ( "Not sending events because there is no network connection. " + "Events will retried next time is ) ; handleFailure callback , new not ) ; return useProject = project == ? defaultProject : project ) try projectId = useProject getProjectId ( ) ; < String List < Object > eventHandles = eventStore . ( projectId ) ; Map < , < Map < String , > buildEventMap ( projectId , eventHandles ; response publishAll , events ) ; if ( response != { try ( response ; catch ( Exception e { KeenLogging . log response batch publish: " + e . ( ) ) ; } ( callback ) ; } catch e ) callback , e ) } }<CODESPLIT>Synchronously sends all queued events for the given project . This method will immediately publish the events to the Keen server in the current thread .
public getMaxQueuedConnections ( ) { return ( ) == ? 1 ( getThreadPool ( ) . getQueue instanceof ( ( ArrayBlockingQueue ) getThreadPool ( ) . getQueue ) ) . size ( ) + ( ( ) ) . getQueue ( ) remainingCapacity : - 1 ) }<CODESPLIT>this should only be used as an estimate
final public AuxiliaryTree ( boolean requiresFoot ) throws { jjtn000 = new ( JJTTREEROOT ) ; boolean jjtc000 = true ; jjtree ) ; Tree ; { t = ) closeNodeScope ( , true ) ; jjtc000 ; { if ( true ) new ( t requiresFoot ) ; } } catch ( jjte000 ) { if ( jjtc000 ) { . clearNodeScope ( ) jjtc000 = false } else { ( ; if ( ) { if ( ) throw ( RuntimeException ; if ( jjte000 ) { { ( true throw ( ParseException ) ; } } { ( true ) throw ( Error ) jjte000 } finally { jjtc000 ) { . closeNodeScope ( jjtn000 , true ) ; } throw new Error ( statement function" ) ;<CODESPLIT>the argument says whether there must be a foot node on the aux tree .
INodeDirectory addToParent ( [ ] src , INodeDirectory , INode newNode int childIndex { newParent = null ; writeLock ( try { try { newParent rootDir . addToParent src , , false propagateModTime , childIndex ) ; ) ; } catch ( e { return } if ( newParent == null ) return null ; if ( ! newNode . ( ) ) { INodeFile = ( INodeFile BlockInfo = . ( ) i 0 ; < blocks . length ; ++ { newF . setBlock i , getFSNamesystem ( . blocksMap . addINodeForLoading ( blocks i ] , newF ) ; } } finally { writeUnlock ) ; return newParent ; }<CODESPLIT>Add node to parent node when loading the image .
public void setModel final MindMap , final notifyModelChangeListeners { this . lock ( ) ; try { if ( this . elementUnderEdit != { . safeSwingBlockingCall new ( ) { run endEdit ( ) ; } } ) ; final List < int ] selectedPaths = new ArrayList int [ ] ( ) ; ( final Topic t : this . selectedTopics { selectedPaths . . getPositionPath ( ) ; } . . clear ( ) ; final = this . ; this . model = assertNotNull ( not , model for ( final PanelAwarePlugin : MindMapPluginRegistry getInstance ( ) . ( PanelAwarePlugin . class ) { p . ( , oldModel , this . model ) } revalidate ( ) ; = ; ( [ ] posPath : selectedPaths ) { final = this . findForPositionPath ( ) ; ( topic null ) ; } else ! isHidden topic ) this selectedTopics . add ( ) ; } if ( selectionChanged ) { ; } ( ) ; } finally { this . unlock ( ) ; if ( ) { ( true ) ; } } }<CODESPLIT>Set model for the panel allows to notify listeners optionally .
OperationFuture < > delete ( ) { loadBalancerMetadata findByRef loadBalancer ) ; loadBalancerClient . delete ( loadBalancerMetadata loadBalancerMetadata . getId ( ) ) ; return new OperationFuture < > ( loadBalancer NoWaitingJobFuture ( ) ; }<CODESPLIT>Delete load balancer
public getSnapshot ( GetSnapshotRequest request ) checkNotNull ( request "request not null." ; checkStringNotEmpty ( request . ) should no be empty." ) ; InternalRequest internalRequest = . createRequest ( request , HttpMethodName . GET , , getSnapshotId ( ) ) return ( GetSnapshotResponse . class ) }<CODESPLIT>Getting the detail information of specified snapshot .
SuppressWarnings ( ) void excludeLoggers ( { try BugsnagAppender addExcludedLoggerPattern "org.apache.catalina.core.ContainerBase." + "\\[Tomcat.*\\][.]\\[.*\\][.]\\[/.*\\][.]\\[.*\\]" ) ; BugsnagAppender . addExcludedLoggerPattern . addExcludedLoggerPattern ( "io.undertow.request" ) ; } ( NoClassDefFoundError ignored ) } }<CODESPLIT>If using Logback stop any configured appender from creating Bugsnag reports for Spring log messages as they effectively duplicate error reports for unhandled exceptions .
public subtract ( relationships ) if ( null == base ) throw new ( ) ( int 0 ; base length ; i ++ ) { if null == base [ ] } = [ i ] new ( ) set . addAll base [ i ] ) ; ( null != relationships . data [ i ] ) set . removeAll ( relationships . data i ] ) ; } } }<CODESPLIT>This should only ever be called when the relationships wrap an initial state and no other methods have been called .
private static < > E ( Class E type , String name , Reflections reflections ) { E result = null ; Set extends E > = reflections . type < Class ? extends E > > endpointClasses new HashSet < > ( ) for ( Class < extends E > : foundClasses ) if ( ! Modifier . isAbstract ( clazz getModifiers ( ) ) endpointClasses . add clazz ) ; } < Class < ? extends E = endpointClasses iterator ( ) ; while ( iterator . ( { Class extends E > next iterator . ( ) ; if StringUtils . startsWithIgnoreCase ( . getName ( ) "com.github.davidcarboni.restolino.routes." ) iterator . remove ( ) } . size ( ) != ) if endpointClasses ( ) > 1 ) { log . "Warning: found for {} endpoint: , name ) } try { iterator ( ) next ) . ( ) ; catch ( Exception { . info ( instantiate class {}" , name , endpointClasses . iterator ( ) . next ) ) e . printStackTrace ) ; } } return result ; }<CODESPLIT>Locates a single endpoint class .
public final void ( AOStream stream , Item ) if ( TraceComponent isAnyTracingEnabled ( ) && tc . isEntryEnabled ( ) ) SibTr tc , "writtenStartedFlush" ; key = SIMPUtils ( ( ) stream . getGatheringTargetDestUuid ( ) StreamInfo sinfo = streamTable . get key ; if ( sinfo != null ) && sinfo streamId . equals ( stream . streamId ) { synchronized ( ) sinfo . item ( AOStartedFlushItem ) } { e = nls . ( "INTERNAL_MESSAGING_ERROR_CWSIP0001" new Object [ ] { , , null ) ; FFDCFilter . processException e , , "1:2865:1.89.4.1" , this ; SibTr . exception tc , e ) SibTr error tc , "INTERNAL_MESSAGING_ERROR_CWSIP0001" , new [ "1:2872:1.89.4.1" } ) ; if TraceComponent isAnyTracingEnabled ( ) . ( ) ) SibTr . exit tc , "writtenStartedFlush" , ) throw e ; } if ( TraceComponent . isAnyTracingEnabled ( ) && tc isEntryEnabled ( ) ) ( , "writtenStartedFlush" ;<CODESPLIT>Callback when the Item that records that flush has been started has been committed to persistent storage
public static List > getDetailSubreports ( ReportLayout reportLayout ) { List < subreports = new < ) ; = reportLayout ( ; ( int i = 0 rows = band . ( i < rows ++ ) { List < BandElement list band . ( i ) for ( int j = 0 size = list . size ( ) < size j ++ ) { BandElement be . get ( ) ( be instanceof ReportBandElement ) { . ( ReportBandElement ) be ) . getReport ) } } } return subreports ; }<CODESPLIT>Get detail band subreports for a report layout
getApiApps ( throws HelloSignException { return new ApiAppList ( ( auth ) . get ( BASE_URI + API_APP_LIST_URI ) . asJson ; }<CODESPLIT>Retrieves a paged list of API apps for the authenticated account .
public detachAgent ( pVm ) try { if ( pVm != ) { clazz pVm ) ; = clazz ( ) ; method . setAccessible ( true ; method . invoke pVm catch ) throw new ProcessingException "Error detaching" , , options ) } catch ( NoSuchMethodException e ) throw new ProcessingException ( "Error while detaching" , e , options ) ; } catch ( IllegalAccessException ) throw new ProcessingException ( "Error detaching" , e , options ) } }<CODESPLIT>Detach from the virtual machine
ObjectGraph excludeClasses Class < ? > classes ) for Class ? > c : classes ) { if { throw new NullPointerException ( "Null class not allowed" ; } excludedClasses . add ( ; } return ; }<CODESPLIT>Exclude any object that extends from these classes .
void setSampling double min , double , int total ) this sampleMin = min ; this . sampleMax = = total ; this . scores new double [ numSamples ; }<CODESPLIT>Specifies how focal lengths are sampled on a log scale . Remember 1 . 0 = nominal length
private calcProductAtVar ( int v , prod , int , excl2 ) { ( int = 0 nb < numNbsT1 ( v ; ++ ) { if nb == excl1 || nb == excl2 ) { continue msgs opposingT1 ( v , nb ) ] ; prod elemMultiply ( nbMsg ) ; }<CODESPLIT>Computes the product of all messages being sent to a node optionally excluding messages sent from another node or two .
protected findLastItemState QPath itemPath ) ( int = . ( ) - 1 ; i >= 0 ItemState istate = itemAddStates . get ( i ) if ( istate . getData ( ) . getQPath ) . equals ( ) return istate ; ; }<CODESPLIT>Find last ItemState .
void addDispatcher String dispatcherId , ) { synchronized ) { if ( dispatchers . containsKey ( dispatcherId ) ) dispatchers . ( dispatcherId , dispatcher ) } }<CODESPLIT>Registering custom dispatcher
private void sgdTrain ( ClassificationDataSet D W , b int sign_mul , boolean parallel { IntList order = IntList ( D . size ( ) ListUtils . addRange ( order , 0 , D . size ( ) , 1 ) ; final double = / . ( * epochs ) ; int owned int [ K ] ; int = 0 int [ = [ D . size ( ; Arrays . fill ( assignments - 1 ) Vec dots new DenseVector ( W . ( ) ) long t ; for int epoch = 0 ; epoch epochs ; epoch ++ ) Collections . shuffle ( ) ; int : order ) t ++ double eta 1 / ( lambda_adj * ) ; Vec x_i = D . getDataPoint i ) . ( ; int y_i = ( i ) * - ) sign_mul ; b copyTo ( dots ; . multiply ( 1.0 ) ; if ( y_i - ) { for ( k = 0 k < ; ++ if get ( > - 1 ) { W ( k ) . ( eta x_i ) ; b . increment k - eta ) ; } { int k_true_max = ; for ( int = 1 ; k < dots . ( ; k ++ ) ( dots get ( k ) > dots get ( ) k_true_max = k ; ( k_true_max ) < ) { int z ASSIGN i , , owned , assigned_positive_instances ) W getRowView ( z ) . mutableAdd ( eta x_i ) ; b . increment ( z eta ; [ 0 assigned_positive_instances ; else owned [ assignments [ ] ] ; owned [ ] ++ ; assignments [ i ] = ; } } W . mutableMultiply / ) ; mutableMultiply ( 1 1.0 ) ; }<CODESPLIT>Training procedure that can be applied to each version of the CPM sub - problem .
static appfwfieldtype ] get ( nitro_service ) throws Exception { obj new appfwfieldtype ( ) ; appfwfieldtype [ ] ] ) obj . ( service ) ; return ; }<CODESPLIT>Use this API to fetch all the appfwfieldtype resources that are configured on netscaler .
public Future < > create final Promise < Channel channelReadyPromise ) { final long delay this . currentDelaySeconds . get ( ) channelReadyPromise addListener new GenericFutureListener < Channel > > { ( final Future < Channel > future ) { long future isSuccess ) ? 0 : Math . max ( * 2 , ) , MIN_CONNECT_DELAY_SECONDS ) ; ApnsChannelFactory this . . ( delay ; } } ) ; this . bootstrapTemplate . config ) . ( . schedule ( new ( ) public void ) { Bootstrap = . this bootstrapTemplate clone ( ) . channelFactory ( AugmentingReflectiveChannelFactory < ( ClientChannelClassUtil . ApnsChannelFactory this . bootstrapTemplate . ( group ( ) , , channelReadyPromise ) final ChannelFuture bootstrap . connect ) ; connectFuture . addListener ( GenericFutureListener < ChannelFuture > ( ) { void ChannelFuture future ) if ( ! . isSuccess ( ) ) future . cause ( ) ; } } } ) ; . channel ) . closeFuture ( ) . addListener new GenericFutureListener < { public void operationComplete ( final ChannelFuture ) { channelReadyPromise . tryFailure ( new IllegalStateException closed HTTP/2 preface completed." ) ) ; } } ) } } , , SECONDS ) ; return channelReadyPromise }<CODESPLIT>Creates and connects a new channel . The initial connection attempt may be delayed to accommodate exponential back - off requirements .
public List String > loadOptions ( String ) List < String args = new ArrayList < String ( ) ; File File ( optionFileName ; stringWriter new ( ) InputStream inputStream new FileInputStream ( optionFile ) . copy ( inputStream , stringWriter ; catch ( e ) { System . err . println "Error reading options file: " + e getMessage ( ) ; . exit ( ) ; } e { . err "Error reading file: " e . getMessage ( ) ; exit 1 ; } String string stringWriter . toString ( ) ; StringTokenizer = StringTokenizer ( ; while ( stringTokenizer . hasMoreTokens ( ) { args . add ( stringTokenizer . nextToken ( ; return args ; }<CODESPLIT>Load options from a file
public runJob ( { try this . currentJob = this . . take ) ; ExecutionContext ExecutionContext ( try { executionContextManager . initialize ( context ) ; } catch ExecutionContextException e ) { new initialize this currentJob + " context" e ) } this . currentJob . run ( ) ; } ( InterruptedException ) { } finally { this . . removeContext ( ) ; } }<CODESPLIT>Execute one job .
bind ( name , Object model ) { getLocals put ( name , model ) ; return ; }<CODESPLIT>Binds an object to the response .
byte [ getByteArray ( Integer { byte [ = null ; if ( offset != null ) { result ( offset ; } return ( result ; }<CODESPLIT>This method retrieves a byte array containing the data at the given offset in the block . If no data is found at the given offset this method returns null .
public [ ] ( ) MetaClass metaClass = InvokerHelper . getMetaClass objectUnderInspection ) List metaMethods = ( ) [ ] new Object [ metaMethods . size ( ) ] int i = 0 for metaMethods ) iter . hasNext ) i ++ { MetaMethod metaMethod = ( MetaMethod ) iter . next ) result [ i ] = methodInfo ( ) ; } return result ; }<CODESPLIT>Get info about instance and class Methods that are dynamically added through Groovy .
static long [ parse ( String pollers ) String ] periods = . split ( ",\\s*" ) ; long [ ] result periods . length ; errors = false logger getLogger ( . class ) ; for i = 0 ; i < . ; ++ ) { String period = periods [ ] ; try { result [ i ] Long . parseLong period ; if ( [ i ] { . ( "Invalid must be , period ; errors = true } NumberFormatException e ) . error ( parse '{}' a long: {}" , , e . getMessage ) ) ; errors = true ; } if ( || periods length == 0 ) logger . "Using a default for poller intervals: {}" , join ( DEFAULT_PERIODS ) ; return DEFAULT_PERIODS ; { result ; }<CODESPLIT>Parse the content of the system property that describes the polling intervals and in case of errors use the default of one poller running every minute .
public void setFooter key , value ) { Objects . requireNonNull value ) int i = hasFooter = for ( _footerKeys . size ( ) - 1 ; i 0 ; i -- { . ) if ( oldKey equalsIgnoreCase key ) { if ( hasFooter ) { _footerKeys . remove ( ) ; _footerValues . remove ( i } else hasFooter = true ; _footerValues . set i , value ) ; } if ( ! hasFooter { _footerKeys add key ; . add ( value ) } }<CODESPLIT>Sets a footer replacing an already - existing footer
public addAttribute ( String name , value ) if m_elemContext m_startTagOpen ) { final String patchedName = patchName String localName = getLocalName ( patchedName ) ; final uri = getNamespaceURI ( patchedName , false ) ; ( uri , localName , , value ) ; }<CODESPLIT>Adds the given attribute to the set of collected attributes but only if there is a currently open element .
public createMimeMessage ( session ) MessagingException { if ( isEmpty ( ) && ( textPart ) new IllegalArgumentException email content" } final MimeMessage msg = new MimeMessage ( session ; msg . setSubject subject setFrom ( ) ) ; . ( createMultiPart ) ) ; msg . setRecipients ( Message . RecipientType , InternetAddress . parse ( recipients , ) ) ; return msg ; }<CODESPLIT>Creates a MimeMessage containing given Multipart . Subject sender and content and session will be set .
public static ForwardCurveInterpolation ( String name , LIBORModelMonteCarloSimulationModel , startTime ) throws { int timeIndex = model . getTimeIndex ( startTime ) ; > liborsAtTimeIndex = ArrayList > ( ) int firstLiborIndex getLiborPeriodDiscretization ( . getTimeIndexNearestGreaterOrEqual ( startTime ) firstLiborTime = model . getLiborPeriodDiscretization ( . ( firstLiborIndex ; if ( firstLiborTime > startTime ) { liborsAtTimeIndex . add ( model . getLIBOR ( , startTime , ) ; } double ] times = firstLiborTime startTime ( model ) - ) : model . getNumberOfLibors ( ) firstLiborIndex ) ] ; [ 0 ] = ; int = firstLiborTime == startTime 0 : 1 ; ( int i = firstLiborIndex ; < . getNumberOfLibors ( ) ; ++ add ( model . getLIBOR timeIndex i ) [ i - firstLiborIndex + indexOffset ] = getLiborPeriodDiscretization ( getTime i - startTime } RandomVariable [ libors = liborsAtTimeIndex . toArray RandomVariable liborsAtTimeIndex . size ( ) ] ) return ForwardCurveInterpolation . ( times , libors , model getLiborPeriodDiscretization ( . ( firstLiborIndex ) ;<CODESPLIT>Create a forward curve from forwards given by a LIBORMonteCarloModel .
public ServiceCall < deleteWord ( DeleteWordOptions deleteWordOptions ) { Validator . notNull , cannot null" ; [ ] pathSegments = { "words" } String ] pathParameters = { deleteWordOptions . customizationId ( , deleteWordOptions . ) } ; = RequestBuilder . delete ( constructHttpUrl getEndPoint ( ) , pathSegments , ) ) ; Map < String , String > sdkHeaders = getSdkHeaders , "deleteWord" ) ; ( Entry String > : entrySet builder header ( . getKey ( ) , header . getValue ( ) ) ; } return createServiceCall ( builder . build ( . getVoid ( ) ) ; }<CODESPLIT>Delete a custom word .
private tryMove ( x , y ) { float newx = + x float newy = ; if ( newx ) ) { if ( blocked ( newx , ) ) { if blocked ) false } else { = ; return ; } } else { playerX = newx ; return ; } else { playerX = newx ; playerY newy ; return true ; } }<CODESPLIT>Try to move in the direction specified . If it s blocked try sliding . If that doesn t work just don t bother
void recover ) { try { . messages clear ) this . dataLogger . prepareForRead ( ) ; ( this ) ; } catch ( Exception e ) { throw ( e ) } }<CODESPLIT>recovers the dataRecorder all messages are removed and all the messsages of the logger are recoverd
void clearSources { synchronized ( mAudioSources ) { for ( : mAudioSources ) { source . setListener ( null } . ( ) } }<CODESPLIT>Remove all of the audio sources from the audio manager . This will stop all sound from playing .
@ SuppressWarnings ( public static < V extends NumberVector > NumberVector . V guessFactory SimpleTypeInformation V in ) { . V > = ; if ( in instanceof ) { = NumberVector < V > ( ( VectorTypeInformation < V > ) getFactory ( ; } if factory == null ) { try { Field f = in getRestrictionClass ( getField ) ; factory = ( NumberVector Factory > f get ( } catch Exception e { LoggingUtil . warning ( "Cannot determine factory for type " + in . getRestrictionClass ( ) ; } } return factory ; }<CODESPLIT>Try to guess the appropriate factory .
public void balance ( ) { ! rootDir exists ) ) rootDir . mkdirs ) ; if ( rootSaveDir . exists ( ) ) . ( ) ; if ( paths == null ) paths = Maps . newHashMap ( ; if ( == ) Lists newArrayList ) ; for ( int 0 < numLabels ; i ++ ) paths . ( i ArrayList > ( ) ) ; add ( new File ( rootDir String . valueOf i ) ) ; } while ( . hasNext ( ) { = dataSetIterator next ( ) ; if ( < 0 ) miniBatchSize = . numExamples ( ) for ( = ; i < . numExamples ) ; ++ ) { DataSet currExample next . get ( i ) ; if ! labelRootDirs . ( . outcome ( ) ) ) labelRootDirs . ( . ( ) ) mkdirs ( ) File = new File . currExample . outcome ( ) , . valueOf ( paths get ( currExample outcome ( ) size ) currExample . example ) ; paths . get . outcome ( ) . add example ) ; } } int = ; while ( ! . ( ) ) { < DataSet > miniBatch new ArrayList < > ( ) ; ( . size ( ) miniBatchSize && paths . isEmpty ( ) ) for ( i 0 ; i < ; if ( paths . get ( ) != null . get i ) ( ) ) DataSet new DataSet ( ) d . load ( paths . get ( i ) . ( ) ) ; miniBatch . ) ; } paths . remove ( ) ; } } ( ! rootSaveDir ) ) rootSaveDir . mkdirs ) ; if ( miniBatch ( ) { DataSet merge = DataSet . ( miniBatch ; if ( dataNormalization != null dataNormalization . ( merge ) ( new File ( String . format ) ) } }<CODESPLIT>Generate a balanced dataset minibatch fileset .
static boolean double unixTime ) { double gpsTime = ; gpsTime += countleaps ( gpsTime , true ) return isleap gpsTime ) ; }<CODESPLIT>Test to see if a unixtime second is a leap second
void setSunXMLHeaders final Marshaller aMarshaller , final String sXMLHeaders String sPropertyName = SUN_XML_HEADERS ; _setProperty ( , sPropertyName , ; }<CODESPLIT>Set the Sun specific XML header string .
private void sendKeepAliveBridgeMessage int appId String bridgeId String , final CallStatsHttp2Client httpClient ) { long apiTS = System . currentTimeMillis ( ) ; BridgeKeepAliveMessage ( , ) ; String gson message ) httpClient . sendBridgeAlive ( keepAliveEventUrl , , requestMessageString , new CallStatsHttp2ResponseListener ( { public void onResponse Response response ) int responseStatus = . code ( ) ; BridgeKeepAliveResponse keepAliveResponse ; { String responseString body ( ) string ( ) keepAliveResponse gson . fromJson ( responseString , class ) ; catch ( IOException e ) { e . ( throw new e ) ; } ( JsonSyntaxException ) { logger . ( "Json Syntax Exception + e . getMessage ) e ) ; e . printStackTrace ( ; e ) ; } httpClient setDisrupted false ; responseStatus == CallStatsResponseStatus . RESPONSE_STATUS_SUCCESS ) { keepAliveStatusListener ( ) else if ( == CallStatsResponseStatus INVALID_AUTHENTICATION_TOKEN ) stopKeepAliveSender ( ) ( CallStatsErrors . , ) ; else { httpClient setDisrupted ) ; } } public ( Exception ) { logger . info ( "Response exception " + e toString ( ) ; httpClient . setDisrupted ( ) ; } } ; }<CODESPLIT>Send keep alive bridge message .
public StreamingOutput getResource final String resourceName , final nodeId , final Map String > ) JaxRxException { final StreamingOutput sOutput ( ) { public void ( final OutputStream ) throws { final revision = queryParams . get REVISION ) ; final String = . get . WRAP ) ; String doNodeId = queryParams . get ( QueryParameter . OUTPUT ; final boolean = wrap == null ? false : ( ) final boolean == ) ? : doNodeId . equalsIgnoreCase ( ) final Long rev = == null ? null Long . valueOf ( revision ; ( resourceName , nodeId , rev , nodeid , , wrapResult ) } } return sOutput ; }<CODESPLIT>This method is responsible to deliver the whole XML resource addressed by a unique node id .
public [ ] createManagedEntities ( sc , ManagedObjectReference ] mors if mors == null ) return ManagedEntity ] ; [ ] mes = new ManagedEntity [ mors . ] ; for ( i = < ; ++ ) { mes [ i ] = createExactManagedEntity ( sc , mors i ) ; } return mes ; }<CODESPLIT>Given a ServerConnection and an array of MORs return an array of MEs
public Function < , String createStringTemplateSource ( I_CmsFormatterBean formatter , Supplier CmsXmlContent > ) { return String result ; if != null ) { result = formatter . getAttributes ) . get ( ) result { content = contentSupplier get ) ; ( content != null ) { result = content . ) . getParameter ( key ) ; } return result ; } ; }<CODESPLIT>Helper method to create a string template source for a given formatter and content .
private final ByteBuffer createReadWriteMessage ( final opCode , final logicalBlockAddress final short transferLength { ByteBuffer = ByteBuffer allocate ( ; cdb . ( ) ; cdb . ( LOGICAL_BLOCK_ADDRESS_OFFSET ) ; cdb . putInt ( logicalBlockAddress ) TRANSFER_LENGTH_OFFSET . putShort ( transferLength ) ; cdb rewind ( ) ; return cdb }<CODESPLIT>Creates the Command Descriptor Block for a given Operation Message .
long read ByteBuffer [ ] int offset int ) IOException { long rc = fillAppRead ( ) 0 ) { return rc ; } return ByteBuffers . move ( appRead , offset , length ; }<CODESPLIT>Reads ByteBuffer from peer . Starts handshaking if needed .
static void ( MemorySegment [ , int , value { if ( inFirstSegment ( segments , offset segments [ 0 ] . putInt ( offset , ) ; } else { setIntMultiSegments ( segments , value ) } }<CODESPLIT>set int from segments .
Optional < > getOptionalUser ( String ) { { ( . ofNullable ( getUser ( username ) ) GitLabApiException glae ) { return ( GitLabApi . ( glae ) ) } }<CODESPLIT>Lookup a user by username and return an Optional instance .
protected registerRateLimiterComponent ( { String = GatewayConfigProperties . COMPONENT_PREFIX + IRateLimiterComponent class . ( ) ; , ESRateLimiterComponent . getName ) ; setConfigProperty ( componentPropName + ".client.type" , "jest" ; setConfigProperty ( componentPropName ".client.protocol" setConfigProperty ".client.host" "${apiman.es.host}" ) ; ( + ".client.port" "${apiman.es.port}" ) ; setConfigProperty ( componentPropName + ".client.username" , "${apiman.es.username}" ) ; setConfigProperty ( + ".client.password" , "${apiman.es.password}" ) ; }<CODESPLIT>The rate limiter component .
public Point3d getCoordinatesFromGridPoint gridPoint ) { int dimCounter = 0 ; Point3d new ( , ) ; for int z 0 ; < [ 0 ] [ 0 . length ; z ) ( int y ; y < grid [ . ; y ) { for int x = 0 ; x grid . length ; x ++ ) ( dimCounter gridPoint ) { point . x minx + * ; y + latticeConstant * ; z = minz + * z ; return point ; } ; } } } return point ; }<CODESPLIT>Method calculates coordinates from a given grid array position .
setColor ( Color COLOR ) { if ( null { _color = COLOR ; } else { color . set ( } }<CODESPLIT>Defines the color that will be used to colorize the section in a clock .
void releaseEvent EventId eventId ) { Lockable V eventWrapper sharedBuffer . getEvent ( eventId ) ; if { if ( eventWrapper . release ( ) ) sharedBuffer . removeEvent ( eventId ) ; } else sharedBuffer . ( , ) } } }<CODESPLIT>Decreases the reference counter for the given event so that it can be removed once the reference counter reaches 0 .
public toSql ( showParameters ) String sql ; if ( forPaginator { sql metaModel getDialect formSelect ( null , orderBys limit , offset ) ; } else sql = fullQuery != ? getDialect formSelect metaModel . ) null , , orderBys , , offset ) ; } if showParameters ) { StringBuilder sb = new sql ) . append ( ", with parameters: " ) join ( sb , params ", " ) ; sql = toString ( ) ; } return sql ; }<CODESPLIT>Use to see what SQL will be sent to the database .
private getSourceFromUriResolver ( StylesheetHandler handler ) TransformerException { Source = null ; processor handler . ( ) uriresolver . getURIResolver ( ) ; ( uriresolver != null { String href = getHref ( ) ; String base = ) uriresolver . resolve ( href base ) ; } return s }<CODESPLIT>Get the Source object for the included or imported stylesheet module obtained from the user s URIResolver if there is no user provided URIResolver null is returned .
String getTitle ) { if . featOkTst ( Journal_Type jcasType ) . casFeat_title == null ) jcasType "title" , "de.julielab.jules.types.Journal" ) ; return jcasType . ll_cas ll_getStringValue ( addr , ( ( Journal_Type ) . casFeatCode_title ; }<CODESPLIT>getter for title - gets Full journal title C
static Val ( Object ) if ( o != && o instanceof Val ) { return Cast . as ) ; return ( o ; }<CODESPLIT>Convenience method for creating a Convertible Object
protected ( SparseDoubleVector meaning , < String > , { ( String : ) if ! term . equals IteratorFactory EMPTY_TOKEN ) ) { int dimension = basis . getDimension ( term ; if - ; . set ( dimension , weighting . weight ( distance , windowSize ) ; ++ distance ; } } }<CODESPLIT>Adds a feature for each word in the context that has a valid dimension . Feature are scored based on the context word s distance from the focus word .
ArrayList < > getViews ( ) try { ( . ) { Log . d ( config . } return viewFetcher . getViews ( null , false ; } catch ( Exception e ) { e ) ; return } }<CODESPLIT>Returns an ArrayList of all the View objects located in the focused Activity or Dialog .
private E extends > SparseDoubleVector ( WeightedGraph < E > g int vertex { if ( SparseDoubleVector weightVec . get ) if ( weightVec == null ) { ( this ) { = vertex ( == null ) weightVec computeWeightVector ( , vertex ) ; vertexToWeightVector . put ( vertex , ) ; } } return weightVec ; } else return ( g , vertex ) ; }<CODESPLIT>Returns the normalized weight vector for the specified row to be used in edge comparisons . The weight vector is normalized by the number of edges from the row with positive weights and includes a weight for the row to itself which reflects the similarity of the keystone nod .
static fillRows ( [ ] , TypeDescription schema , VectorizedRowBatch batch int [ selectedFields { Math . ( int . ( ) , rows . length ) List < TypeDescription > = ) int = 0 ; < . length fieldIdx ++ ) int orcIdx = selectedFields [ fieldIdx ; readField ( rows , fieldIdx , fieldTypes . get ( orcIdx , batch . cols [ orcIdx rowsToRead ) ; } return rowsToRead ; }<CODESPLIT>Fills an ORC batch into an array of Row .
< ICalProperty getProperties ( T component ) { return ICalProperty > ( component . getProperties ( . values ( ; }<CODESPLIT>Gets the properties to marshal . Child classes can override this for better control over which properties are marshalled .
public double computeTauAndDivide final int , final numRows , final [ ] , final double max double tau ; for i = j ; i < numRows ; i ) { double d u max d d ; } = . sqrt tau ) ; if ( u [ j ] < 0 ) tau - tau ; return tau ; }<CODESPLIT>Normalizes elements in u by dividing by max and computes the norm2 of the normalized array u . Adjust the sign of the returned value depending on the size of the first element in u . Normalization is done to avoid overflow .
public Epic getEpic String epicKey , Map < , Epic > epicMap try String = . getJiraBaseUrl ( ) + ( featureSettings getJiraBaseUrl ( ) endsWith "/" ) ? "" : "/" ) + . format EPIC_REST_SUFFIX epicKey ) ; String > responseEntity = makeRestCall ) String responseBody = responseEntity . getBody ) ; JSONObject issue = ( JSONObject ) parser . parse ) ( null ) { null ; issue epicMap ) ParseException ) { . error ( "Parser exception parsing , pe ) ; catch ( HygieiaException e { LOGGER . error ( "Error in calling JIRA API" ) ; } return null ; }<CODESPLIT>Get Epic using Jira API
Serializable getLayoutConstraints final WComponent child PanelModel model = ) ; if ( model . layoutConstraints != null ) { . get child ) ; } return ; }<CODESPLIT>Retrieves the layout constraints for the given component if they have been set .
public Map < , Set < String > getReverseMap ) { Set Map . Entry < String , Set < String > map . entrySet ) Map < String < rMap = HashMap < String , Set > > ( entries . size ) ; for Map . Entry < String , Set String > > me entries ) { k = me getKey ) ; Set String > transList getValue ) for ( transList ) Set < > entry = rMap ( ; if ( == null ) { < String toAdd = new LinkedHashSet String > ( 6 ) ; toAdd . ( k . put ( trans , toAdd ) ; } else { entry add ( k ) } return rMap ;<CODESPLIT>Returns a reversed map of the current map .
public ( String refreshToken ) lock . lock ) if refreshToken != ) Preconditions checkArgument jsonFactory != null && != && clientAuthentication != null && tokenServerEncodedUrl != null , "Please use the and call + ) } this . refreshToken = refreshToken ; } finally { lock . unlock ) ; } return this ; }<CODESPLIT>Sets the refresh token .
void makeCurrent EGLSurface eglSurface ) ( mEGLDisplay EGL14 EGL_NO_DISPLAY { Log . d ( TAG , "NOTE: } if ( ! EGL14 . eglMakeCurrent ( mEGLDisplay eglSurface , eglSurface , mEGLContext ) ) { throw "eglMakeCurrent failed" ) } }<CODESPLIT>Makes our EGL context current using the supplied surface for both draw and read .
static < T navigateSafe ( final T defaultValue , , final Object ... paths ) { return navigateOrDefault ( defaultValue , ) ; }<CODESPLIT>Use navigateOrDefault which is a much better name .
void clearCache CommerceWarehouseItem commerceWarehouseItem ) { . removeResult CommerceWarehouseItemModelImpl ENTITY_CACHE_ENABLED CommerceWarehouseItemImpl . class , commerceWarehouseItem . getPrimaryKey ( clearCache ( FINDER_CLASS_NAME_LIST_WITH_PAGINATION ) ; finderCache . clearCache ( ) ; clearUniqueFindersCache ( ( commerceWarehouseItem , true ; }<CODESPLIT>Clears the cache for the commerce warehouse item .
private void process ( String input output ) MPXJException IOException { MPPReader reader = MPPReader ( ) ; = reader . read ( input ; varDataFileName ; String projectDirName ; int mppFileType = NumberHelper . getInt ( m_project . getProjectProperties ) . getMppFileType ) ; mppFileType { 8 : { projectDirName = ; "FixDeferFix 0" ; break ; } 9 : projectDirName = ; "Var2Data" ; break ; } : { projectDirName = " 112" varDataFileName = "Var2Data" break ; case 14 : { projectDirName " 114" ; = "Var2Data" ; } : { throw new IllegalArgumentException ( file type " + mppFileType ; } } FileInputStream = new input ; POIFSFileSystem fs new POIFSFileSystem is ) is . close ( ) DirectoryEntry root = fs . getRoot ( ) m_projectDir = ( ) . getEntry ( projectDirName String , String > = HashMap String , String ( ) ; ( task : m_project ( { mapText ( task . ( , replacements ) ; processReplacements ( ( DirectoryEntry ) . ( ) , replacements ) ; replacements . clear ( for ( Resource resource m_project . ( ) ) { mapText ( . ( ) , replacements ; ( resource . getInitials ) , replacements ) } processReplacements ( ( DirectoryEntry ) m_projectDir getEntry "TBkndRsc" ) , varDataFileName replacements , ) ; replacements . clear ( ; ProjectProperties = . getProjectProperties ( ) mapText ( ) , replacements ) ; ( m_projectDir , , true ; replacements ( ) ; ( . getProjectTitle ( ) replacements ) ; mapText ( properties . getSubject ( ) , replacements ; ( properties . getAuthor ( ) ; mapText . getKeywords ( replacements ) ; ( properties . getComments ( ) , replacements ) ; processReplacements ( root , "\005SummaryInformation" , ; replacements . clear ( ) mapText ( properties . , replacements ) ( . ( ) , replacements ) mapText ( . , replacements ) processReplacements ( root , "\005DocumentSummaryInformation" replacements , false FileOutputStream os = new FileOutputStream ( . writeFilesystem ( os ) . flush ( ) os . ) fs close ;<CODESPLIT>Process an MPP file to make it anonymous .
public setRollbackOnly ( { final isTraceOn = TraceComponent . isAnyTracingEnabled ( ; if isTraceOn && tc ) ) . entry , , this ) ; } LocalTransactionCoordinator lCoord getLocalCoord ( ) ; ( { ( ; } else try txService . ( ) ; } catch ( Exception e ) { . processException ( e , CLASS_NAME + "556" , ) ; throw new IllegalStateException ( "No transaction" ) ; } } if && tc . isEntryEnabled ) ) Tr exit ( tc "setRollbackOnly" ) ; } }<CODESPLIT>Marks the current local or global transaction to be rolled back
static boolean ( final String content { if ( content contains "\"reason\":\"missing\"" ) ) { return true ; } document not found, error is {}" content ) ; return ; }<CODESPLIT>Analyses the content of a 404 response to see if it is legible for retry .
private ListenableFuture < > writeBlocksToTargets ( Collection < . > outputBuffers , [ ] serialized ) { Preconditions . checkArgument ( m_tableTasks . == serialized . ) Preconditions . checkArgument outputBuffers . == serialized length ) ; final List < ? > > writeFutures = ArrayList ListenableFuture < > > ( outputBuffers . size ( ) ; Iterator < DBBPool . BBContainer > = outputBuffers . ( ; int serializedIndex 0 ; for : ) final DBBPool = containerIter next ( ; final ByteBuffer buf = . ) ; buf limit ( serialized [ ++ ] task . m_target . ( ) ) ; . position ( 0 ) ; < . BBContainer > valueForTarget = . ; if ( task . != ) for filter : task . m_filters ) { valueForTarget filter . filter ) } } ListenableFuture > writeFuture = task . ( , m_tableId ) ; if ( writeFuture != null ) writeFutures . add ( writeFuture } return . ( writeFutures ) ;<CODESPLIT>Finalize the output buffers and write them to the corresponding data targets
isTerminal ( atom , Map < IAtom , Integer { return graph [ atomToIndex . get ( atom ) ] . ; }<CODESPLIT>Is the atom terminal having only one connection .
private < AsyncResult Void > createUndeployHandler ( final Message < JsonObject message ) return Handler Void > ) { handle AsyncResult < Void > result ) { ( result . failed ) reply ( . putString ( , ) . ( "message" , . cause ( ) . getMessage ) ) ) ; } else { message . reply ( new ( ) . putString ( "status" ) ) ; } } } ; }<CODESPLIT>Creates a platform undeploy handler .
public PhotoAllContext getAllContexts ( String photoId FlickrException { < > setList = new PhotoSetList PhotoSet > ( ) PoolList < Pool > poolList = PoolList Pool > ( ) ; PhotoAllContext allContext = new PhotoAllContext ( ) ; Map < , Object > = HashMap , > ) ; parameters . put , ; parameters . put ( "photo_id" photoId ) Response response . transport . getPath ( ) , apiKey , sharedSecret ) ; ( response . ( ) { throw new FlickrException ( . getErrorCode ( , response ( ) ; } Collection < Element > = response . getPayloadCollection ( ; for ( Element : photosElement if setElement . getTagName ) . ( "set" ) { PhotoSet pset = PhotoSet ( ) ; pset . setTitle ( . getAttribute ( ) ; pset . setSecret ( "secret" ) ) pset setId setElement . getAttribute "id" ) ) pset setFarm ( setElement ( ) ; pset . setPrimary setElement getAttribute ( "primary" ) ; pset . ( setElement getAttribute "server" ) setViewCount ( parseInt ( setElement . getAttribute ( ) ) ; pset setCommentCount ( . parseInt ( setElement . getAttribute "comment_count" ) ) ; pset setCountPhoto Integer . parseInt ( . getAttribute ( "count_photo" ) ) ; . setCountVideo ( . ( setElement . getAttribute "count_video" ) ) ; setList . add ( ) ; . ( setList ) ; else getTagName ( ) . equals ( "pool" ) ) { new Pool ) ; setTitle ( getAttribute "title" ) ; pool . setId ( setElement . getAttribute ( "id" ) ) ; pool setUrl setElement . getAttribute ( "url" pool . setIconServer setElement . getAttribute ( "iconserver" ) ) ; ( setElement . getAttribute ( ) ) ; pool . setMemberCount ( Integer parseInt ( getAttribute ( "members" ) ) . setPoolCount ( Integer ( setElement . getAttribute ( "pool_count" poolList . add ( ; allContext . ( } } }<CODESPLIT>Returns all visble sets and pools the photo belongs to .
public Map < , Object > getFieldData ( < , Object > ) { Map < String , Object > propReturn = properties != null { = new Hashtable , ) ; ( int i = 1 i ++ ) { String strFieldNumber DBParams FIELD + . toString ( i ) ; String = ( String ) properties . get ( ) ; if strFieldName null ) break Record record = ( ; ( strFieldName '.' ) - 1 { record = this ( substring ( 0 . indexOf ( ) ) ; strFieldName = strFieldName substring ( strFieldName . ( '.' ) + 1 ) ; } field = null ; ( record null ) = record getField ( ; if ( != null ) propReturn . put ( strFieldNumber , . getData ( ) } return propReturn ;<CODESPLIT>GetFieldData Method .
void connect InetAddress address , int ) throws SocketException { . ( ) . onNetwork ( ) ; connect0 ; connectedAddress = address ; connectedPort port ; connected = ; }<CODESPLIT>Connects a datagram socket to a remote destination . This associates the remote address with the local socket so that datagrams may only be sent to this destination and received from this destination .
private getEscaped ( { pos ; if ( pos == length { throw IllegalStateException ( "Unexpected " + ; } chars [ pos ] ) { case '"' : '\\' : case ',' case : case : case '#' case : case ' : case '*' : case '%' : case '_' return chars [ pos ] ; default return getUTF8 ( ) ; } }<CODESPLIT>returns escaped char
static String ( String expression ) if ( . ( . VALIDATION_MATCHER_PREFIX ) && expression . endsWith ( { return expression . substring ( Citrus . VALIDATION_MATCHER_PREFIX length ( ) , expression . length ( ) Citrus . . length ( ) } expression ;<CODESPLIT>Cut off validation matchers prefix and suffix .
public < TypeElement implementingClasses ( typeElement ) { SortedSet < TypeElement result = ( , SortedSet < intfcs = typeElement false ) ; Iterator < TypeElement > = intfcs . iterator ) . ) Iterator < implementingClassesIter implementingClasses ( . next ( ) . iterator ( ) ; ( implementingClassesIter . hasNext ( ) ) c = implementingClassesIter . next ( ) ; if ( result . contains ( ) ) { result . add ( ) ; } } } return ; }<CODESPLIT>Return the set of classes which implement the interface passed .
void add ValidationResult validation ) &= validation . if ( ! validate ) return ; errors . addAll ( ; warnings addAll ( validation . warnings ; }<CODESPLIT>Adds a validation result to this .
public static String ( Object obj ) { buf = new ( ) ; MetaFieldInfo [ ] fields = toMetaFieldInfoArray ( obj , null ) ; for ( int = 0 ; < fields length i ++ { field = fields ] ; buf . append ( . ) ; . append ( "=" ) if ( field . actualValue != null && . . getClass ( ) equals ( String . { append ( ) . value ; buf append ( '"' ) buf . append ( . ) ; if ( i + 1 < fields . length ) . append "," ) ; } buf . ) ; }<CODESPLIT>Creates a string for an object based on the MetaField annotations .
String getArrayClassName Class < ? > ) { if . ( ) ) { return getArrayClassName ( clazz . + "[]" ; return clazz . getName ( ; }<CODESPLIT>Formats the class name with trailing square brackets .
synchronized addBlock ( block ) if ( ! ( ) return } BlockScanInfo info = . ( ; if != null ) { LOG . warn ( "Adding already existing block " block ) info info new BlockScanInfo ( block ) ; info . lastScanTime = getNewBlockScanTime ( ) ; ( ) ; adjustThrottler ( ) ; }<CODESPLIT>Adds block to list of blocks
String getTile int x , int ) { ( x getArrayWidth ( ) ) || ( y > ( x < 0 ) || ( y < ) ) { throw new IllegalArgumentException ( ) ; image x ] [ ; }<CODESPLIT>Gets a tile of the XPM Image .
public BitArray final String name String bitLenExpression final sizeExpression { final Item item = new Item ( , this . byteOrder ) ; item . bitLenExpression assertExpressionChars ( bitLenExpression ) ; item . sizeExpression = ( sizeExpression ) ; . ( item ) ; }<CODESPLIT>Add named bit array where each bit length is calculated through expression .
public static Object ( String strPattern , String , offset , boolean , boolean matchAll ) throws MalformedPatternException { PatternMatcherInput input = ) ; Perl5Matcher = Perl5Matcher ( ) compileOptions 0 : . CASE_INSENSITIVE_MASK ; compileOptions += SINGLELINE_MASK ; if ( offset < ) = 1 Pattern pattern = getPattern ( strPattern , ) ; if ( offset <= strInput . ( ) ) . ( offset - ) ; if strInput length ) ) = new ( ) while ( matcher . input ) ) { = matcher . ( ) beginOffset ( 0 ) 1 ; if ( matchAll ) { return new Double ( match ; } appendEL ( match ) ; } if ( matches . size ( 0 ) { return } return 0 ;<CODESPLIT>return index of the first occurence of the pattern in input text
private checkRegisteredServicesByLdapFilter ( filter ) InvalidSyntaxException { ServiceReference ? > references getBundleContext ( ) . ( ( String , filter if ( isEmptyOrNull ( references ) ) { return ; } if ( . { ) getService ( references [ 0 ] ) ; } throw new RuntimeException ( "Too many registered filter: " + filter ) ; }<CODESPLIT>Checks the OSGi ServiceRegistry if a service matching the given filter is present .
public ( DEvent event ) if ( _tevent null . ( event ; ( != null ) { . ( event ) ; } else { log . info ( "Dropping event for non- managed , ( ) , "class" , getClass ( ) . getName ( ) "event" , event ) ; } }<CODESPLIT>Posts the specified event either to our dobject manager or to the compound event for which we are currently transacting .
Identity createOverlayManagerGroup String name ) { return ExtendedIdentifiers . . ICS_METADATA_NS_URI , IfmapStrings . ICS_METADATA_PREFIX "overlay-manager-group" , name ; }<CODESPLIT>Create a overlay - manager - group identifier that is an extended identity identifier .
public DoubleMatrix cholesky DoubleMatrix A { DoubleMatrix result = A . ( ) int info = ( 'U' . rows . , 0 , A . rows ) if ( info < ) ( info ; } else ( > 0 { throw new LapackPositivityException ( "DPOTRF" , "Minor " + + " was negative. Matrix be positive definite." ) ; } clearLower result ) ; return result ; }<CODESPLIT>Compute Cholesky decomposition of A
public static boolean final String className , final String methodName ) { throwable new Throwable ( StackTraceElement [ = throwable ( ) ; if ( null == stackElements ) LOGGER . log ( . stack" false } final boolean = . equals methodName ) ; for ( int i = 1 ; < stackElements . length ; i ++ if ( [ i ] . getClassName ( ) equals ( className ) ) { matchAllMethod true : stackElements i ] getMethodName ( . methodName ) ; } } return ; }<CODESPLIT>Checks the current method is whether invoked by a caller specified by the given class name and method name .
setFlag ( name , String value ) throws IOException ( "setflag" , name , value ; }<CODESPLIT>set JVM command line flag
Q addFlag Position position , , Expression ? expr { Expression < ? > flag = Expressions getType ( ) , prefix + "{0}" , expr ; return queryMixin . addFlag ( new QueryFlag , flag ) ; }<CODESPLIT>Add the given prefix and expression as a general query flag
static newConnectionInfo ( Channel c ) channel = SocketChannel c InetSocketAddress hostAddress = channel . localAddress ( InetSocketAddress ( channel ) ; String scheme = channel . ( ) . get ( SslHandler . class ) null : "http" ; return ConnectionInfo , remoteAddress scheme ) }<CODESPLIT>Retrieve the connection information from the current connection directly
public PDPDomain getPDPDomain String pdpDomainName throws IOException { SortedSet String > domainRanges = null ; ( serializedCache != null ) { if ( containsKey pdpDomainName ) { = serializedCache . pdpDomainName } boolean = checkDomainRanges ( domainRanges ) ; try { if ( shouldRequestDomainRanges { URL u = new URL server + "getPDPDomain?pdpId=" pdpDomainName ) ; . info ( "Fetching {}" , u ) ; InputStream response = ( u ) ; String xml = JFatCatClient . ( response ) ; domainRanges = getDomainRangesFromXML xml ; if ( domainRanges != null ) pdpDomainName ) ; ( MalformedURLException e ) { logger error ( "Problem generating request URL for " pdpDomainName , e ) throw IllegalArgumentException ( "Invalid PDP name: " + , pdbId = null < > = < ResidueRange > ( ) ; for : domainRanges SubstructureIdentifier = SubstructureIdentifier ( ) ; ( pdbId == pdbId = ( } if ( ! . equals ( strucId . ) ) { throw new RuntimeException ( "Don't take the union of multiple PDB IDs." ; } ranges addAll ( strucId . getResidueRanges ( ) ) ; return new ( pdpDomainName , ranges ) ; }<CODESPLIT>Get a StructureIdentifier representing the specified PDP domain .
Context getContext ) { if ( != null { searchView getContext ( ) ; } else if ( return supportView . getContext ( ) ; } new IllegalStateException ( ERROR_NO_SEARCHVIEW ; }<CODESPLIT>Returns the context the view is running in through which it can access the current theme resources etc .
private isMacroCycle ( ring , rs ) { if ( ring getAtomCount ( < 8 ) for ( : ring ( ) ) { boolean found = false ; ( IAtomContainer other : . { == ) continue ; ( . contains bond ) ) { found = true ; break ; } if ( ! found ) true ; } return false ; }<CODESPLIT>Check if a ring in a ring set is a macro cycle . We define this as a ring with > = 10 atom and has at least one bond that isn t contained in any other rings .
public T > T datastoreToJava ( entity ) { try { ( entity == ) { null T result T ) persistentClass newInstance ) ; populate ( , result ) ; return result ; } catch ( new ) ; } catch ( IllegalAccessException e ) { throw RuntimeException ( e ) ; }<CODESPLIT>Convert a value from Google representation to a Java value
void updateCacheState Map < String , > props ) { ( ) ; if ( cacheEnabled ) { authCacheServiceRef ; } else { . deactivate ( cc ) } }<CODESPLIT>Based on the configuration properties the auth cache should either be active or not .
public static QuerySnapshot ( final query , readTime final DocumentSet documentSet , final List < DocumentChange > documentChanges ) { return new QuerySnapshot ) { List QueryDocumentSnapshot > documents public List getDocuments ( { if ( documents == { synchronized ( documentSet ) { ( == null { documents = . toList ( ; } } } return Collections . unmodifiableList documents ) ; public < DocumentChange > ( ) { unmodifiableList ( documentChanges ) ; } ( ) return documentSet . size ( ) ; } boolean Object o ) if ( this == ) { true ; } if o == null || ( ) != o . getClass ) { return false ; } that o ; return Objects . ( , . && Objects . equals ( this . size , that ( ) && Objects . ( this getDocumentChanges ( ) ( ) && equals ( getDocuments ( , that . ) } public int hashCode ( ) { return Objects . hash ( , this . getDocumentChanges ( ) , getDocuments ) ) ; } } ; }<CODESPLIT>Creates a new QuerySnapshot representing a snapshot of a Query with changed documents .
private boolean readSend InH3 hIn , OutboxAmp outbox HeadersAmp ) throws IOException MethodRefHamp methodHamp = null ; try { methodHamp = readMethod ( } catch ( e { log . ( Level FINER e . ( ) , e ) ( hIn ) ; return true } method = . getMethod ( ) ; ClassLoader loader = methodHamp . getClassLoader ( ) ; Thread thread Thread . currentThread ) thread . setContextClassLoader loader ) ; args readArgs methodHamp , if ( . isLoggable _logLevel ) ) { log log , this + send-r " + method getName ( + debugArgs ( args + " {to:" + + ", " + headers + ) } SendMessage_N sendMessage = new ( method . serviceRef ( ) method method ) ) ; long timeout = 1000L ; try . offer ) catch Throwable ) { log . ( e . toString ; ( log . isLoggable ( Level FINEST ) ) { log ( Level . FINEST , e ( ) ; } } return ; }<CODESPLIT>The send message is a on - way call to a service .
private getRemoteFileName ( file ) if ( file getProperty ( . ( "/" ) ) return file . service ) if ( file . getProperty ( PARAM_REMOTE_PATH ) . ( "/" ) ) String file PARAM_REMOTE_PATH . split ( "/" ) ; return tmp tmp . length - 1 ] ; return . getProperty ( PARAM_REMOTE_PATH ) ; }<CODESPLIT>Checks if the remote file path contains also the remote file name . If it s not specified the name of the local file will be used .
public initializeBufferMetrics ( Task task ) final MetricGroup buffers addGroup "buffers" ; . gauge "inputQueueLength" , ( ) ; buffers . gauge ( "outputQueueLength" , new OutputBuffersGauge task ) ) ; buffers . gauge ( "inPoolUsage" new task ) ) gauge ( , OutputBufferPoolUsageGauge ( task ) ) }<CODESPLIT>Initialize Buffer Metrics for a task .
void doubleClick String fileName ) throws { try new ( . rect ) . doubleClick ( fileName ) ex ) { throw new QTasteException ( ex . getMessage , ex ) } }<CODESPLIT>Simulates a double click on the specified image of the area .
void setDestinationSSECustomerKey SSECustomerKey sseKey ) { ( sseKey null this sseAwsKeyManagementParams != null ) { throw new IllegalArgumentException must not be set at the same time." ) ; . destinationSSECustomerKey = ; }<CODESPLIT>Sets the optional customer - provided server - side encryption key to use to encrypt the destination object being copied .
onFailure ( t ) { Toast . makeText ( . getMessage ( ) , LENGTH_LONG . show ( ; }<CODESPLIT>show any error messages posted to the bus .
private void paintDropLines ( SeaGlassContext g ) { JTable . DropLocation loc = table . ( ) ; if loc == ) return } Color color ( Color ) style . ( , "Table.dropLineColor" ) ; shortColor = ( Color ) style get , ) if ( color == null shortColor ; } Rectangle rect rect = getHDropLineRect ( loc ) if != ) { rect . x ; int w = rect width if ( != null ) { ( , true ; setColor ( color ; . ( rect x rect . y , rect . , rect . height ) if ( ! loc . isInsertColumn ( && != null ) { . ( shortColor ) g . fillRect , rect . w , rect . height ; } } rect = getVDropLineRect ( ) rect != null { int y rect . y ; int h ; ( != ) { extendRect ( rect , ) ; g . setColor ( ; g fillRect ( rect , . y , rect . , . height ) ; } if ( ! isInsertRow ( ) && shortColor != null { setColor ( shortColor ) ; g . fillRect ( rect x y , rect h ) ; } }<CODESPLIT>Paint the drop lines if any .
DatalogProgram createDatalog SWRLRule rule ) . accept this ; ( notSupported ) { log . warn ( + errors ) ; errors . clear ( ) } DatalogProgram dp = datalogFactory . getDatalogProgram ( ) dp appendRule facts ) dp ; }<CODESPLIT>Translate the swrl_rule Return a datalog program containing the supported datalog facts
String inflateAuthnRequest final byte [ ] ) { inflated CompressionUtils inflate ( decodedBytes ) ; if ( ! ) ) { return inflated ; } return . decodeByteArrayToString ( decodedBytes ; }<CODESPLIT>Inflate authn request string .
static FrameworkProjectConfig ( final String final File , Properties , final IFilesystemFramework filesystemFramework ) { if ( ) ) { generateProjectPropertiesFile ( name , propertyFile , , properties , true ) ; } return create propertyFile , filesystemFramework ; }<CODESPLIT>Create and generate file with the given properties if not null
static synchronized void ( ) { final LogContext = . LOG_CONTEXT ; Configurator configurator = embeddedLogContext . getLogger ( "" ) . ATTACHMENT_KEY ) ; ( instanceof PropertyConfigurator ) LogContextConfiguration ( PropertyConfigurator configurator ) . getLogContextConfiguration ( clearLogContext ( logContextConfiguration ) ; } if configurator instanceof ) { clearLogContext ( ( LogContextConfiguration ) ) ; } else { final List < > loggerNames = . ( embeddedLogContext . ( ) ) String : ) { = embeddedLogContext getLoggerIfExists ( ) ; if ( null final Handler [ = logger . ( ) if ( handlers != ) { for ( handler : handlers ) { handler . close ) ; } logger . setFilter null ) . setUseParentFilters ( ) ; logger . setUseParentHandlers ( true ) ; . setLevel ( Level ) } } }<CODESPLIT>Attempts to clear the global log context used for embedded servers .
execute ( timeout , TimeUnit timeUnit ) { return ( delegate . execute ( ) timeout , timeUnit ; }<CODESPLIT>Executes the API request in a synchronous fashion using the given timeout .
public InputStream getInputStream HttpServletRequest request , MutableObject < [ > sourceMapResult ) IOException { byte [ ] bytes = this . bytes ; sourceMap = this sourceMap String filename = . filename InputStream = null if ( bytes != null result = new ByteArrayInputStream ( bytes ; ( sourceMapResult null && sourceMapSize > 0 ) { sourceMapResult . setValue ( sourceMap ) ; } } if ( filename null { ICacheManager cmgr ( ( IAggregator getAttribute IAggregator AGGREGATOR_REQATTRNAME ) ( ) File file new File ( cmgr . ( filename ) ; ( sourceMapSize == 0 { result new FileInputStream ( file ; } else { data ; ObjectInputStream is = new ( FileInputStream ( file ) ) try CacheData ) is . readObject ) } ( ) { throw new IOException ( e . ) , ; finally { IOUtils . is ; } bytes = data . ; sourceMap = data . if null ) { sourceMapResult . sourceMap ) ; result = new ByteArrayInputStream ( bytes else { new ( ) ; } result ; }<CODESPLIT>Return an input stream to the layer . Has side effect of setting the appropriate Content - Type Content - Length and Content - Encoding headers in the response .
public cacheIncludeAndIgnore ( table ) if ( getIgnoreByMatches ( ) == ) { ( new ArrayList ( ) for ( : ( ) ) { getIgnoreByMatches ( ) addAll ( table . ( } getIncludeByMatches ) == null { ( new < WebElement > ) ) ; for ( By : getIncludeOnlyRowsMatching ( ) ) { getIncludeByMatches ) . addAll ( table . findElements by ) ) ; } } }<CODESPLIT>Does the table comparison
public E > List < InlineDiffChunk E > > ( < > , List E > { null ) ; try { this . inlineDiffDisplayer . ( this . diffManager . diff ( previous , next , } e ) { setError ( e ) ; return null ; }<CODESPLIT>Builds an in - line diff between two versions of a list of elements .
public static CompletableFuture MessageSet > getMessagesAroundUntil ( TextChannel , Predicate < Message , around { < > future = new CompletableFuture ( ) channel getApi ( ) . getThreadPool ( ) . ( ) . submit ( ) -> { List < Message > new < > ( ) ; Optional Message > untilMessage = getMessagesAroundAsStream ( channel , around ) . messages ) ( condition ) findFirst ( complete new untilMessage -> ) . ( Collections . emptyList ( ) ) ) ; } catch ( Throwable t ) { future . completeExceptionally ( t } ) ; return future ; }<CODESPLIT>Gets messages in the given channel around a given message in any channel until one that meets the given condition is found . If no message matches the condition an empty set is returned . The given message will be part of the result in addition to the messages around if it was sent in the given channel and is matched against the condition and will abort retrieval . Half of the messages will be older than the given message and half of the messages will be newer . If there aren t enough older or newer messages the halves will not be same - sized . It s also not guaranteed to be perfectly balanced .
public boolean findSipApplicationAnnotation ( InputStream stream { try { byte [ rawClassBytes ; rawClassBytes new byte stream ( ) stream . read rawClassBytes ; boolean one = ( rawClassBytes , SIP_APPLICATION_BYTES ) ; boolean two = contains ; && two ) return true ; } catch ( Exception ) { } return false }<CODESPLIT>Determine if this stream contains SipApplication annotations
protected Map < Object > buildJobDataMap ( final JmxCommand jmxCommand , final ] ) throws MBeanException < String > jobDataMap HashMap < String , Object > ( ) ; { int ind = ; : ( ) { option process jobDataMap , . valueOf ( params [ ind ++ ] ) ) } for ( Argument arg : this . getArguments ) ) { arg . setValueUsingParser ( . valueOf ( params [ ind ] ) ; } catch ( e ) throw ( e ) ; } return ; }<CODESPLIT>Initialize the JobDataMap with the Program arguments
private V ( buf ) Token t getNextToken ( ) if ( . tokenType != TokenType ) { IllegalStateException ( " + t ) ; } buf . append t . getValue ( ) ( ( . tokenType == . ) { ; } else if ( t . tokenType == TokenType . TRAILING_BACKSLASH ) Vopt ( buf ) ; } }<CODESPLIT>Vopt = EOL V
addHeader ( String sName , final String sValue ) sValue != null ) _addHeader sName , sValue ; }<CODESPLIT>Add the passed header as is .
< N Number > Number max ( List < ) { return cal ( numberList DoubleStream :: max ; }<CODESPLIT>Max number .
public getChaincodeActionResponseStatus ( ) throws InvalidArgumentException if ( statusReturnCode - ) return ; } { final = ) ; statusReturnCode = proposalResponsePayloadDeserializer getExtension ( ) . ( ) ; return statusReturnCode ; } catch ( InvalidArgumentException e ; Exception e ) { throw new InvalidArgumentException ( e ) ; }<CODESPLIT>getChaincodeActionResponseStatus returns the what chaincode executions set as the return status .
generate ( < Pair < Env < AttrContext > > queue ) { generate queue , null ; }<CODESPLIT>Generates the source or class file for a list of classes . The decision to generate a source file or a class file is based upon the compiler s options . Generation stops if an error occurs while writing files .
public create ( final String , final String , , String version final < , > parameters ) { { new EnhancedMimeType ( primary , sub , encoding , version , parameters ; } MimeTypeParseException throw RuntimeException ( "Failed to create versioned mime type: " + primary + "/" sub , ex ) ; } }<CODESPLIT>Creates an instance with all data and exceptions wrapped to runtime exceptions .
static long Object value , long defaultValue ) { toNullableLong ( value ) ; return result != null ? ( long defaultValue ; }<CODESPLIT>Converts value into integer or returns default when conversion is not possible .
public setIsolation ( iso ) JspTagException { if ( TRANSACTION_READ_COMMITTED . ( iso ) { isolation TRANSACTION_READ_COMMITTED ; if ( equals iso ) ) { isolation = Connection TRANSACTION_READ_UNCOMMITTED ; } else ( iso isolation Connection . TRANSACTION_REPEATABLE_READ } if ( . equals ( iso ) ) { isolation = Connection TRANSACTION_SERIALIZABLE ; } { throw new JspTagException ( Resources . ( "TRANSACTION_INVALID_ISOLATION" ) ) ; } }<CODESPLIT>Setter method for the transaction isolation level .
void traverse Node root ) { initTraversal root ; = root ; pushScope ( root ) ; ) ; popScope ( ) ; } catch ( Error | Exception unexpectedException ) ( unexpectedException ) } }<CODESPLIT>Traverses a parse tree recursively .
CollectionRequest < > findByWorkspace ( String ) { String path String format ( "/workspaces/%s/tags" , workspace ) ; return ( this , Tag class , path , "GET" ; }<CODESPLIT>Returns the compact tag records for all tags in the workspace .
Rule CriteriaOnlyFindQuery ) { return Sequence ! peek ) isCliQuery ) , JsonParameter ( JsonObject ( ) ) setOperation ( Operation . FIND ) , peek ( ) . setCriteria ( ) ) ; }<CODESPLIT>A find query only given as criterion . Leave it to MongoDB s own parser to handle it .
private unlinkLast ( Node < E l ) { E element = l . ; final < E = prev ; l item null ; l . = null ; last = prev ; if ( prev == null . next = null ; size ; modCount ++ ; return element }<CODESPLIT>Unlinks non - null last node l .
static void ( Hashtable < Object > , userDn char [ ] pwd ) { env . , "simple" ) ; env . put ( Context SECURITY_PRINCIPAL , userDn ) ; env . put ( . , String ( ) ; }<CODESPLIT>Sets the environment properties needed for a simple username + password authenticated jndi connection .
createTeam ( name , String tag ) { return ( SERVICE , "createTeam" , name , tag ; }<CODESPLIT>Create a new ranked team with the specified name and tag
private void checkFilePattern String s throws ProblemException { Pattern p = ; if File . separatorChar { p . compile ) ; } else if ( File . separatorChar '/' ) { p Pattern ) { new ProblemException ( platform the unsupported + File . separatorChar + " as file separator character. add support for it!" ) ; } = p matcher ( s ) ; if ( m . matches ( ) ) new ProblemException ( "The \"" + + is not a file name." ) ; }<CODESPLIT>Verify that a source file name is valid .
void close ) throws { ( Entry < TransactionType ShardingTransactionManager > entry : transactionManagerMap . entrySet ( ) ) . getValue ) ( ) } }<CODESPLIT>Close sharding transaction managers .
protected String getBar long percentage { StringBuilder sb = new StringBuilder ) ; . ( sb . "% [" for int i = 0 ; i < ; i ++ ) if || - ) { append "=" ) } else if i == percentage - 1 ) sb . append ( ">" ) ; } else { sb . append ( " " ) ; sb . append ( "] " ; return sb . toString ) ; }<CODESPLIT>Generates the progress bar for the given percentage
private resolve ( T element , T > ) Set T > dependencies = blockedBy . get ( dependencies != null ) { for ( T dependency dependencies ) { resolve ( dependency , result ) } . remove ( element result ( element ) ; }<CODESPLIT>Resolves an element .
B camundaOut String source , String ) { param modelInstance newInstance ( CamundaOut . class ) ; param ; param . setCamundaTarget ( target ) ; addExtensionElement param ) ; return ; }<CODESPLIT>Sets a camunda out parameter to pass a variable from a sub process instance to the super process instance
createArgumentsReference ( { Node = . name ( "arguments" ; if ( isAddingTypes ( ) ) { result . argumentsTypeSupplier ( ) ) } return ; }<CODESPLIT>Creates a reference to arguments with the type specified in externs or unknown if the externs for it weren t included .
Date toDate String dateString ) { date = ; df new SimpleDateFormat ( "yyyy-MM-dd" ) ; try { ( dateString ) ; } catch ( ParseException ex { System . out . println ( ex . ) ; } ; }<CODESPLIT>Takes a String and converts it to a Date
int cusolverRfSetNumericProperties cusolverRfHandle handle , double zero , double return checkResult ( cusolverRfSetNumericPropertiesNative ( handle , , boost ) ; }<CODESPLIT>CUSOLVERRF set and get numeric properties
Object quoteIfString Object obj ) { return obj instanceof ( ( String ) obj ) : ; }<CODESPLIT>Turn the given Object into a String with single quotes if it is a String ; keeping the Object as - is else .
public Object > deleteUidAsync ( String type , String name final uid_type = UniqueId . ( ) ( uid_type case METRIC : return metrics . deleteAsync ( name ; case TAGK : tag_names . ) : tag_values . deleteAsync ( name ) ; default : throw new IllegalArgumentException ( UID " + uid_type ) ; } }<CODESPLIT>Attempts to delete the given UID name mapping from the storage table as well as the local cache .
boolean scrollDownList int index ) ( config commandLogging { . d ( config . commandLoggingTag , "scrollDownList(" ; } return scroller . scrollList ( waiter . ( index , ListView . class ) , DOWN , false ; }<CODESPLIT>Scrolls down a ListView matching the specified index .
protected makeAnnotationTypeElementDoc ( MethodSymbol meth , treePath ) { result ( ) . get meth ) ( null ) { if ( treePath != null ) result setTreePath ( treePath ) ; } else { result new this , meth ; methodMap put meth , result ) ; }<CODESPLIT>Create the AnnotationTypeElementDoc for a MethodSymbol . Should be called only on symbols representing annotation type elements .
Object call method , Object ... arguments ) throws , IOException { return internal_call ( method , null , 0 , ) ; }<CODESPLIT>Call a method on the remote Pyro object this proxy is for .
static String ( int value , total ) { float total == 0 ? 0 : 1F * value ; return format ( average ; }<CODESPLIT>Returns value converted to percentage format .
static < extends Geometry > T > ( < > expr , float deltax , float deltay expr . getType ( ) , SpatialOps . TRANSLATE expr , ConstantImpl . create ( deltax ) , ( deltay ) ; }<CODESPLIT>Translates the geometry to a new location using the numeric parameters as offsets .
private static byte requestWebContent ( String url ) throws TVRageException { try httpGet new ( httpGet . "accept" , ; DigestedResponse response = DigestedResponseReader . requestContent ( , httpGet , CHARSET ; response . getStatusCode 500 { throw new ( . HTTP_503_ERROR url ) ; else if ( response . getStatusCode ) >= 300 ) { throw new ApiExceptionType . , url ) ; } return response getContent ( ) getBytes ) ; } catch ( ex ) throw new TVRageException ( ApiExceptionType , , url , ex ) ; } }<CODESPLIT>Get content from URL in byte array
static boolean ( String value ) for ( char value toCharArray ( ) ) { if ( ! Character ) ) { false ; } } return ; }<CODESPLIT>Returns a boolean indicating whether the given string value is numeric .
RequestMapping ( = GET , "/foo" ) Map String String > getFoo ( ) { final Map fooObj = new HashMap < > ( ) ; fooObj . put ( "foo" ) ; return ; }<CODESPLIT>Controller to just support pinging .
protected fireArrayStartEvent ( JsonConfig jsonConfig { if ( . ) for ( listeners jsonConfig getJsonEventListeners ) . iterator ( ; . hasNext ( ) ; ) { JsonEventListener listener = ( JsonEventListener listeners . ; . ( ) ; } catch ( RuntimeException e ) { log . warn e ) ; } } } }<CODESPLIT>Fires a start of array event .
static < extends Exception > ( SneakyRunnable E runnable { return ( ) -> { @ SuppressWarnings RuntimeException > castedRunnable = ( SneakyRunnable < RuntimeException > ) runnable ; castedRunnable ( ) ; ; }<CODESPLIT>Sneaky throws a Runnable lambda .
public Domain update final BandwidthClient , final String id , final < String Object > params , ParseException , Exception ( client != null && id != null ) final String domainsUri = . DOMAINS_URI_PATH ; RestResponse response = . ( domainsUri params ) ; final JSONObject jsonObject = toJSONObject ( client get ( , null ) ) ; return new ( client , jsonObject ) ; }<CODESPLIT>Convenience method to return a Domain .
public static Stream > getResourceTypes ( final Event event ) { if instanceof . . . . observation . Event ) { final . . jcr . api . observation . Event = ( org . jcr . observation . Event ) event Stream Builder < NodeType > types = . builder ( ) ; for ( final NodeType type : getMixinNodeTypes ) . add ( ) ; types ( . ) . ( ) map ( NodeType :: getName ) ; } catch ( final RepositoryException e ) { throw new RepositoryRuntimeException ( e } return empty ( ) ; }<CODESPLIT>Get the RDF Types of the resource corresponding to this JCR Event
void processDefaultHeader ParserContext context ) { ( String : . ( ) ) { if ( hasHeaderSeparator ( ; } processHeaderLine ( line , context getDocumentModel ( ) ) } }<CODESPLIT>Process the header of the file .
Connection getConnection String url , String , String password ) SQLException boolean alive = isConnectionAlive ( ) ; if createConnection ( url , username , ) ; } return ; }<CODESPLIT>Retrieves the connection object . If the connection doesnt exist or is dead it will attempt to create a new connection .
static final renderPad ( final , final pad final newLine ) { renderNewLine ( builder , newLine i = 0 ; i < pad ; i ) { builder . append ( ' ; } return ; }<CODESPLIT>Render some leading spaces onto a line of html .
public < OvhLine eligibility_lines_active_POST ( city , String contactName , OvhStreet , String ) IOException = "/xdsl/eligibility/lines/active" sb = qPath ; HashMap < String , Object > = new HashMap < , ; , , city ) addBody o , , contactName ) addBody ( o , "street" , ) ; addBody ( o , "streetNumber" , ) ; String resp = exec ( qPath , "POST" . toString ( ) , o ) return convertTo ( , t5 ) ; }<CODESPLIT>Get the active lines at given address
private String evaluateExpressionStack ( final Deque String > operators final < > ) { while ( ! isEmpty { values . push ( getBooleanResultAsString ( operators . ( ) , values . pop ( ) , . ) ) ) ; return ( pop ( ) ) }<CODESPLIT>This method takes stacks of operators and values and evaluates possible expressions This is done by popping one operator and two values applying the operator to the values and pushing the result back onto the value stack
public int write [ ] buffer , int offset , int length isEnd throws { result long requestExpireTime = _requestExpireTime ; requestExpireTime > && < CurrentTime . currentTime ( ) ) { ( ) ; ClientDisconnectException ( L ( "{0}: request-timeout write exp={0}s" ( , CurrentTime . currentTime ( ) requestExpireTime ) ) ; } synchronized ( _writeLock ) { long CurrentTime ( long expires = + now do = ( buffer ) } while result == JniStream . TIMEOUT_EXN && CurrentTime . getCurrentTimeActual ( ) < expires ) ; } if ( isEnd ) ) ; } return result ; }<CODESPLIT>Writes to the socket .
public setAmbientLight ( float r , g , float ) float [ = { , g , ; normalize ( ambient ) ; gl . glEnable ( . GL_LIGHTING ) ; gl . glEnable ( GL2 GL_LIGHT0 gl . glLightfv GL_LIGHT0 , . , ambient , 0 ) }<CODESPLIT>Sets the RGB value of the ambientLight
setMultiChoiceCount ( { if ( fields null ) ( i 0 ; i < fields . length ; multiChoiceCount . multiply ( fields [ i ] . setMultiChoiceCount ) ; return ; }<CODESPLIT>Set the multiChoiceCount for this tuple
void delete forceDelete ) throws APIException { HttpResponse response delete ( getUrl ( ) + "?force=" + forceDelete . throwIfNotOk response ) ; }<CODESPLIT>Creates this directory vi the Algorithmia Data API
protected addNameToApplicationMap ( name ) String appName getApplicationName ( ) if ( == null ) return < String = applicationMap ( appName ) ; if ( list == null { ConcurrentLinkedQueue < String newList String ; = applicationMap . ( appName , newList ; if ( list == null ) list = newList } . add ( name ) ; }<CODESPLIT>Adds the metric name to an application map . This map is not a complete list of metrics owned by an application produced metrics are managed in the MetricsExtension
public static Envelope ( Connection connection , TableLocation , String geometryField ) throws if ( == || geometryField . isEmpty ( List < String > geometryFields getGeometryFields ( connection location ) geometryFields . ( ) ) { throw "The table " + location " not contain field, then the extent + "cannot be computed" ) ; } geometryField = geometryFields get 0 ; ResultSet rs = . createStatement ( ( ST_Extent(" TableLocation . ) + ext FROM + location ) ; if rs next ( ) ) return ( ( Geometry rs . getObject 1 ) . ( ) ; } throw new SQLException ( "Unable get the table it may empty" ) ; }<CODESPLIT>Merge the bounding box of all geometries inside the provided table .
private void doListGet final Message < JsonObject > ) final String name message . body ( ) . getString ( "name" ) ; == null ) message reply ( new ( ) putString "status" , ) . putString ( "message" name specified." ) ) ; return } Integer index message . body ( ) . getInteger ( "index" ) ; if ( index == null { message . ( JsonObject ( ) putString ( "status" . ( , "No ) ; ; } . execute ( new Action Object ) { public perform ( ) { data . ( formatKey ( name ) . get ( ) ; } } , new < < Object > > ( { AsyncResult < Object > result { ( . ) ) { message . reply ( new ) . "status" "error" ) putString "message" , result . cause ( . getMessage ) ) } message . reply new JsonObject ( ) . , "ok" ) . putValue ( "result" , ( ) ; } } } ; }<CODESPLIT>Handles a list get .
public static PlotCanvas ( String id , double ] data ) Histogram = Histogram ( data ) ; histogram . setID ( id double [ ] lowerBound = Math . min data ) 0 ; double ] = { Math ( data ) , 0 } double ] [ freq = histogram . getHistogram ) ; for ( int i = 0 freq . length ; ++ ) { if i 1 ] upperBound ] { [ 1 = freq i [ ] } PlotCanvas canvas = new ( lowerBound , upperBound ; canvas . getAxis ( 0 . ( false ; canvas . histogram ) ; canvas ; }<CODESPLIT>Create a plot canvas with the histogram plot .
public static Pair List < > , List < Tuple > > splitData ( final List Tuple > trainingData , proportion ) if proportion 0 || proportion 1 ) { throw new ( 0.0 - ) ; } if ( proportion 0.5 proportion 1 proportion ; } List < > smallList ( ) ; < Tuple > largeList = new < > ) int smallListSize ) Math . floor ( proportion * trainingData . size ) ) int ct = 0 Set Integer > = < > ( ; ( < smallListSize trainingData . size ( ) > indices . ( ) ) { int index int ( Math . random ) ( trainingData . size ) 1 ) ) while ( indices ( index ) index = ( int ) Math . random ( ) * ( . - 1 ) ; } indices add ( index ) ; ct . ( indices . ( ) . map ( trainingData get ) . collect ( Collectors ( ) ) IntStream range ( , trainingData size ( ) ) filter ( x -> ! . contains x ) ) . ( largeList add ( trainingData . get ( i ) ) ; return ImmutablePair smallList , largeList ) }<CODESPLIT>Shuffle the data and split by proportion
public static void getScreenShotABGR ( BufferedImage out ) { WritableRaster wr = out . getRaster ) ; DataBufferByte db ( DataBufferByte wr getDataBuffer ) ; byte ] cpuArray = db . ( ; . clear ) ; bgraBuf . get ( ) . ( ; int width = wr getWidth wr . getHeight ) ; for ( int y 0 < / 2 ) { for ( int x = 0 x width ; ++ ) { int = y * + * 4 ; outPtr ( height - - ) * width + x ) 4 ; byte b1 = cpuArray + 0 ] ; byte g1 cpuArray inPtr + 1 ] byte = cpuArray [ + 2 ] a1 = cpuArray + 3 ] ; byte = cpuArray [ outPtr + 0 ] byte [ outPtr + ] ; byte = cpuArray [ outPtr + 2 = [ outPtr + ] ; cpuArray [ outPtr + ] = a1 ; cpuArray [ 1 ] b1 cpuArray outPtr + ] = ; cpuArray [ outPtr 3 ] = r1 ; cpuArray [ 0 ] = a2 ; cpuArray inPtr ] = b2 ; cpuArray [ inPtr + 2 ] g2 ; cpuArray [ inPtr = r2 ; } }<CODESPLIT>Good format for java swing .
public Pair < int [ ] [ ] int ] > documentToDataAndLabels ( List IN > document ) int docSize = document . size ) int [ ] [ ] [ ] data = new int [ docSize ] [ ] [ ] int ] new [ ] ; if ( flags ) . reverse ( document ) ; for ( j = j ; j ++ ) { < String > , CRFLabel d = makeDatum document , , featureFactory ) ; List List < String > features . asFeatures ) ; for ( int k 0 , fSize = features size ( ) ; < fSize ++ { Collection < > cliqueFeatures features . ( k ) ; data j ] [ k ] = new int cliqueFeatures . size ) ; int m = String feature : cliqueFeatures { index featureIndex . indexOf feature ) ; ( >= 0 ) [ [ k ] [ m = ; m ++ ; else { } if ( < [ ] . length int [ ] f = new m ] ; System arraycopy ( [ j ] [ k ] 0 , f , 0 , m ) data [ j k ] = f } IN wi = document . ( ) ; labels [ = . indexOf ( wi . get . class ) ) ; if ( . useReverse ) { reverse ( ) ; } return new Pair [ ] [ int [ ] , labels }<CODESPLIT>Convert a document List into arrays storing the data features and labels .
public static synchronized Class < ? > > locateAll ( final String { ( == throw new "serviceName cannot ) } List < Class < ? > classes = new ArrayList Class > ( ( != null ) List Callable < < ? > > l = factories . get serviceName ) ; if ( l != { for Callable < Class < ? > > : l ) try { . add ( c call ( ) ; } catch ( Exception ) } } } return classes ; }<CODESPLIT>Finds all providers for the given service .
String ( ByteBuf buffer ) throws { int length buffer bytesBefore BsonConstants STRING_TERMINATION ) if ( 0 new IOException ( "string termination not found" ) ; String = buffer . toString ( buffer . readerIndex ( , StandardCharsets . UTF_8 . skipBytes length 1 ) ; return result }<CODESPLIT>default visibility for unit test
public addCase ( theCase ) if ( theCase == null ) new NullPointerException "Variant cannot ; JSType ( JSType ; ( cases == null ) cases = JSType [ 1 ] else oldCases cases new JSType . + 1 ; System . ( oldCases , 0 , cases 0 , oldCases . length ) ; } newCase . parent = this ; newCase . siblingPosition cases length - 1 ; cases newCase . siblingPosition ] = newCase ; }<CODESPLIT>Add a case to the variant . Note that every variant must have at least one case .
public summarizeState ( { StringBuilder = new StringBuilder ) ; . append "clipVol=" ) . append _clipVol ) ; append ( ) ; int ii = 0 ; for ( soundType : _disabledTypes ) if 0 . ( ", " ) ; buf . ( soundType ) ; } return buf . ( ) . toString ( ) ; }<CODESPLIT>Returns a string summarizing our volume settings and disabled sound types .
private < String String > ( Pattern keyPattern ) { Map String , > = > ( for ( Object it = props . keySet ( ) iterator ( ) ; . ) = String ) next ) ; matcher = keyPattern matcher ( key ) ; if matcher . matches ( ) ) { = matcher . group ( 2 ) ; String propertyValue props . getProperty ( ) ; map . put ( id propertyValue ) ; } } return ; }<CODESPLIT>Returns the map where the key is the 2 group of the pattern and the value is the property value
long rawUncompress long inputAddr , long inputSize , long IOException { return impl . rawUncompress ( , inputSize , ; }<CODESPLIT>Zero - copy decompress using memory addresses .
void write byte [ ] b int off int ) this . checkIncreaseArray ( len ) ; System off , this . buffer , this . pos , len ) . pos += ; }<CODESPLIT>Writes a byte array content into the stream
final Operation ( ProjectGlobalHealthCheckName healthCheck , healthCheckResource , < > ) { PatchHealthCheckHttpRequest request = PatchHealthCheckHttpRequest . newBuilder healthCheck == null ? null : healthCheck . toString ) ) . setHealthCheckResource ( healthCheckResource ) . addAllFieldMask fieldMask ) build ( ) return ( ) ;<CODESPLIT>Updates a HealthCheck resource in the specified project using the data included in the request . This method supports PATCH semantics and uses the JSON merge patch format and processing rules .
void initializeNoxItemMargin TypedArray attributes ) { noxItemMarginDefaultValue = ( . ( R . dimen . default_nox_item_margin ) ; getDimension ( R . styleable . nox_item_margin , noxItemMarginDefaultValue ) ; setNoxItemMargin ( noxItemMargin ; }<CODESPLIT>Configures the nox item default margin used in NoxConfig Shape and NoxItemCatalog to draw nox item instances during the onDraw execution .
OperationResult failed long index , long eventIndex , Throwable return new OperationResult ( index , eventIndex error , null ; }<CODESPLIT>Returns a failed operation result .
public InsnList ifIntegersEqual InsnList lhs InsnList rhs , InsnList action ) Validate . ( lhs ) notNull ( ; Validate ( ) ; InsnList ret = new InsnList ) ; LabelNode notEqualLabelNode new ret lhs ; ret . ( ) ; . add ( new JumpInsnNode ( Opcodes . IF_ICMPNE , ) ) ; ret . ( action ) ; ret . add notEqualLabelNode ) ; return ret ; }<CODESPLIT>Compares two integers and performs some action if the integers are equal .
public FormatOptions of int flags int width , int precision ) if ( checkFlagConsistency flags UNSET ) throw new "invalid 0x" + Integer . toHexString ( flags ) ; } if ( width && != UNSET throw IllegalArgumentException ( width: " + ) ; } if ( ( < 0 || precision > MAX_ALLOWED_PRECISION ) && precision != UNSET ) { throw new IllegalArgumentException ( "invalid precision: + precision ) ; } return new flags , width precision ) ; }<CODESPLIT>Creates a options instance with the given values .
void tripleClick Coordinates where p = getPoint ( where , "triple click" ) ; exec . mouseAction ( p . y , 3 , . LEFT ; }<CODESPLIT>Triple click is an Opera specific way of selecting a sentence .
void initializeNoxItemPlaceholder TypedArray attributes ) placeholder = . ( . styleable . nox_item_placeholder ) ; if ( placeholder = getContext ( ) . getResources ( ) getDrawable ( R . drawable . ic_nox ) ; setPlaceholder ( placeholder ; }<CODESPLIT>Configures the placeholder used if there is no another placeholder configured in the NoxItem instances during the onDraw execution .
public pruneInvalidOptional ( DependencyExplorerOutput output , invalidKeys ) { . prunedGraph new . GraphPruner output . ) for ( Key < ? > key : invalidKeys . ( ) ) { prunedGraph . remove ( key ; removeBinding ( key output . ( . update ( ) ) }<CODESPLIT>Prune all of the invalid optional keys from the graph . After this method all of the keys remaining in the graph are resolvable .
PersistentResourceXMLDescription getSimpleMapperParser ) { if ( . equals ( Version VERSION_1_0 ) { return simpleMapperParser_1_0 ; } else if Version . VERSION_1_1 ) ) { simpleMapperParser_1_1 ; } return ; }<CODESPLIT>1 . 0 version of parser is different at simple mapperParser
public String getAbsoluteTemplateURI String , boolean includeExtension { FastStringWriter buf = new ( ) ; tmp templateName . substring ( 1 length ( ) ; ( tmp . ( SLASH > 1 ) buf . append ( SLASH int i = tmp . lastIndexOf SLASH ; buf ( tmp . substring 0 , i ) ; buf append ) buf append tmp . substring i + 1 length ) ) ; buf . ( SLASH_UNDR ; buf . append ( . 1 , templateName length ( ) ; } if ( includeExtension ) { . append ( EXTENSION ) ; } String uri = buf . toString ( ) ; buf . ) return uri ; }<CODESPLIT>Used to resolve template names that are not relative to a controller .
protected void scanResourcePaths startPath ) IOException , SAXException { Set < > dirList context . getResourcePaths ; if != null for ( String path : dirList ) { if path . startsWith ( ) if startsWith "/WEB-INF/lib/" ) ) } if ( . endsWith ( "/" ) ) { scanResourcePaths ( path ; } else if ( path . "/WEB-INF/tags/" ) { if ( path . endsWith ( ) ) { parseTld ( path } } else if path . ( ) { ( path ) ; } } }<CODESPLIT>Scan web application resources for TLDs recursively .
boolean duringDrag SVGPoint startPoint , SVGPoint , Event evt , inside { if ( listener != null ) { startPoint , dragPoint , evt , ) ; } return ; }<CODESPLIT>Method called during drags .
private PGPKeyRingGenerator createKeyRingGenerator ( String userId password , keySize { LOGGER . trace ( String, int)" ) ; . trace ( "User ID: {}, {}, Size: {}" , userId , password == null ? "not set" : "********" , keySize ; PGPKeyRingGenerator generator null try . ( RSA key pair generator" ) generator1 RSAKeyPairGenerator ( ) ; generator1 . ( new ( BigInteger ( , getSecureRandom ( ) , 12 ) ) ; LOGGER . ( "Generating Signing Pair" ) BcPGPKeyPair signingKeyPair = new BcPGPKeyPair PGPPublicKey . RSA_SIGN generator1 . ) , Date ( ) ) ; LOGGER debug ( "Generating Encyption Key ) ; BcPGPKeyPair encryptionKeyPair new BcPGPKeyPair . , generator1 . ( ) new Date ) ) ; LOGGER . ( "Generating Signature Key Properties" ) ; PGPSignatureSubpacketGenerator = new PGPSignatureSubpacketGenerator ) signatureSubpacketGenerator . setKeyFlags ( SIGN_DATA | KeyFlags ) signatureSubpacketGenerator setPreferredSymmetricAlgorithms ( false getPreferredEncryptionAlgorithms ( ) ; . setPreferredHashAlgorithms ( getPreferredHashingAlgorithms ) ; signatureSubpacketGenerator . setPreferredCompressionAlgorithms false getPreferredCompressionAlgorithms ( ) ) LOGGER . debug "Generating Encyption Properties" ; encryptionSubpacketGenerator ( ) . setKeyFlags ( false , KeyFlags | KeyFlags . ENCRYPT_STORAGE ; LOGGER info ( "Creating PGP Key Ring ) generator = new PGPKeyRingGenerator ( PGPPublicKey RSA_SIGN , signingKeyPair , , new BcPGPDigestCalculatorProvider ( . get ( . SHA1 ) signatureSubpacketGenerator generate ( ) , , new ( PGPPublicKey . , HashAlgorithmTags . SHA256 ) , new ( getEncryptionAlgorithm ( ) . password ( ) ) ) ; . addSubKey ( encryptionKeyPair . ) null ) ; } catch PGPException e ) { LOGGER . e . getMessage ) ; generator } return }<CODESPLIT>creates and initializes a PGP Key Ring Generator
public Date getDateFromString ( final String final String ) try SimpleDateFormat df = buildDateFormat ( pattern ) ; dateString ) ; } catch ( ParseException e ) throw new DateException ( String . format ( "Could parse %s with pattern %s." pattern ) ) ; }<CODESPLIT>Get data from data string using the given pattern and the default date format symbols for the default locale .
public remove ( key ) synchronized ( ) { if ! _cacheL1 containsKey ( key ) _cacheL2 . key ) return null ; } Object retval ; Map newMap synchronized ( _cacheL1 ) newMap ( ) retval = newMap remove ( key ) } _cacheL1 = newMap ; _cacheL2 . clear ( ) _missCount 0 ; return retval ; } }<CODESPLIT>This operation is very expensive . A full copy of the Map is created
private String getItemType ( Cmdb cmdb String itemType null String subType = cmdb . ( ) ; String = cmdb . getConfigurationItemType ( ) String = hpsmSettings . getAppSubType ( ) ; String hpsmSettingsType = hpsmSettings . getAppType ( ) boolean typeCheck = ; subTypeCheck ; ( "" . equals ( hpsmSettingsType { true ; } if ( ! . equals hpsmSettingsSubType ) subTypeCheck ; } if ( ! subTypeCheck ) { if ( subType null && subType equals ( . getAppSubType ( ) ) { itemType = ; } ( subType null && subType . equals ( . getCompSubType ( ) ) { itemType = COMPONENT_TYPE } else subType null && subType equals ( . getEnvSubType ) ) ) { itemType ENVIRONMENT_TYPE ; } } else if ( typeCheck ! subTypeCheck ) if type != null && hpsmSettings . getAppType ( ) { = APP_TYPE ; else if ( != && type . hpsmSettings ( ) ) ) { = ; } else if type != null type . ( . ( { itemType ; } } else { if != null && subType equals ( . getAppSubType ( ) ) && != null && type . equals ( hpsmSettings getAppType ( ) ) { itemType APP_TYPE } if ( subType != null subType equals ( hpsmSettings . ( ) && type != null && . equals ( hpsmSettings . ( ) ) itemType COMPONENT_TYPE ; if ( subType && subType . equals ( getEnvSubType ( ) type != null && type . getEnvType ( ) { itemType = } return }<CODESPLIT>Returns the type of the configuration item .
public void readXML final List < String > , Map < String String > _attributes , final String _text ) throws SAXException ( _tags . ( == 1 ) String . get 0 ) ; if ( equals ( value ) ) { . = _text } else if ( "file-application" . equals value ) ) { this . fileApplication = ; } else ( . equals ( ) ) { . ( ( ) } else ( "definition" equals ( _tags . 0 ) { final = this . . get this . definitions . ( ) - 1 ; curDef . readXML ( _tags . subList , _tags size ( ) ) _attributes , ; } else throw new SAXException ( "Unknown XML Tag: " + + " for: " . ) ; }<CODESPLIT>Read event for given tags path with attributes and text .
public String getSQLUpdate boolean bUseCurrentValues ) { String = this . makeTableNames ( ) KeyArea keyArea = this . getBaseRecord . getKeyArea ( 0 ) boolean bUseCurrentKeyValues = ? true isNull ( . TEMP_KEY_AREA , true ) = this . getBaseRecord ( . ( ) sFilter = keyArea . addSelectParams ( "=" , DBConstants . TEMP_KEY_AREA , false , bIsQueryRecord bUseCurrentKeyValues , null , true true ) ; . > ) = " ; strSetValues = . getBaseRecord ( ) . ( . SQL_UPDATE_TYPE , bUseCurrentValues ; if ( strSetValues length ( ) == 0 ) null ; strRecordset = "UPDATE + strRecordset + SET " + + sFilter return strRecordset ; }<CODESPLIT>Get the SQL Update string . UPDATE table SET field1 = value1 field2 = value2 WHERE key = value
public static synchronized ( Object ... objects ) { for ( Object objects { ( < ? { verifyClass Class ? > ) mock ) ; } { EasyMockMethodInvocationControl invocationControl = EasyMockMethodInvocationControl . ( if invocationControl != null { . verify ) ; } { if ( isNiceReplayAndVerifyMode ( ) ! isEasyMocked ( mock ) ) { { try org . easymock . EasyMock . verify mock ) ; catch ( e ) { throw RuntimeException ( mock " is not a mock , ) ; } } } } }<CODESPLIT>Switches the mocks or classes to verify mode . Note that you must use this method when using PowerMock!
public mapTileRequestFailed ( MapTileRequestState pState { if ( mTileNotFoundImage != null { putTileIntoCache pState . getMapTile mTileNotFoundImage , NOT_FOUND ) ( Handler handler : mTileRequestCompleteHandlers ) { if handler != null ) handler ) } { for ( Handler : mTileRequestCompleteHandlers { if ( != null ) { handler . ( MAPTILE_FAIL_ID ) ; } } } Configuration . getInstance ( ) . isDebugTileProviders ( ) ) Log . d ( IMapView LOGTAG , "MapTileProviderBase.mapTileRequestFailed(): " + MapTileIndex ( . getMapTile ( ) ) ; } }<CODESPLIT>Called by implementation class methods indicating that they have failed to retrieve the requested map tile . a MAPTILE_FAIL_ID message is sent .
static validateFactoryAndClass ( fd , factoryId , int classId , String ) { ( factoryId != ( ) throw new "Invalid Expected: " + fd . getFactoryId ( + ", Current: " factoryId " ; if ( classId fd getClassId ( ) { throw IllegalArgumentException ( "Invalid classId! Expected: " fd . getClassId ( ) + Current: " + classId + " in " + fullPath ) ; } }<CODESPLIT>Validates if the given factoryId and classId match the ones from the fieldDefinition
public String ( InputComponent < ? > , addColon { String label = input . getLabel ( == null ) { label = input . getName ) ; } if ( addColon && ! label endsWith ( COLON ) { += COLON ; ; }<CODESPLIT>Returns the label for this component
final View ( final View final int ) View = convertView ; if ( ! ( view view = new PlaceholderView ( getContext ( ) ) ; } view . setMinimumHeight ) ; return ; }<CODESPLIT>Inflates an invisible placeholder view with a specific height .
void stopService ) throws Exception { . info c "stopService" "Stopping LdapServer" ) ; this . server . . info ( c , "stopService" , "Stopping DirectoryService" ; service . shutdown ( ) ; Log . c "stopService" , "Ldap ; }<CODESPLIT>Stop the LdapServer and the Directory service . Use for JUnit teardown . If the service is not stopped then future instances with the same name cannot clean up the file directory .
public setCacheMinutes ( iMinutes ) if ( iMinutes == - 1 iMinutes = ; = ( iMinutes ) { timerCache null ) { timerCache . cancel ( ; timerCache = null this ; { ( timerCache ) timerCache . ( ) ; this . startCache ( ) ; = new DBTimerTask ( ) ; timerCache = new java . util . Timer ( ; timerCache . ( timerTask , * 60 * 1000 ) ; } }<CODESPLIT>This will set this database to start caching records until they haven t been used for iMinutes minutes .
protected void propagateOnEnter GVRPickedObject hit ) { GVRSceneObject = . getHitObject ( ; GVREventManager eventManager = getGVRContext ( ) . getEventManager ( ) mEventOptions . contains EventOptions SEND_TOUCH_EVENTS ) ) if ( ( EventOptions SEND_TO_LISTENERS ) ) { eventManager ( this , ITouchEvents . class "onEnter" hitObject , ) ; } if ( mEventOptions . contains ( EventOptions . SEND_TO_HIT_OBJECT ) ) { eventManager sendEvent ( hitObject ITouchEvents class , "onEnter" hitObject , hit if mEventOptions contains ( ) && mScene != ) ) { eventManager . ( ITouchEvents . class "onEnter" , hitObject , ) ; } if ( mEventOptions contains ( EventOptions . ) ) { if ( mEventOptions contains EventOptions . SEND_TO_LISTENERS ) ) eventManager , IPickEvents . class , , , ) if ( mEventOptions . contains ( EventOptions . ) { sendEvent , . , "onEnter" , hitObject hit ) ; } . ( EventOptions . SEND_TO_SCENE ) && mScene != null ) ) . sendEvent ( mScene , IPickEvents class , hit ) ; } } }<CODESPLIT>Propagate onEnter events to listeners
java . . concurrent . GetSendQuotaResult > getSendQuotaAsync . amazonaws . handlers . AsyncHandler < GetSendQuotaRequest , GetSendQuotaResult > getSendQuotaAsync ( GetSendQuotaRequest ( ) , asyncHandler ; }<CODESPLIT>Simplified method form for invoking the GetSendQuota operation with an AsyncHandler .
short shortValue ) throws OtpErlangRangeException long l longValue ) final short i = ( short ) l l ) { throw new OtpErlangRangeException ( "Value too large for short: " + ; } return ; }<CODESPLIT>Get this number as a short .
private MjdbcSQLException translateSQLStatePrefix String reason , String SQLState int , SQLException cause { MjdbcSQLException result = null ; String sqlState = getSqlState ( String sqlStatePrefix = ; ( sqlState != sqlState ) >= ) { sqlStatePrefix = sqlState ( 0 , 2 ) ; ( . SQL_STATE_PREFIX_BAD_SQL_GRAMMAR contains ( sqlStatePrefix ) == true ) result = new BadSqlGrammarException ( reason , SQLState vendorCode ) ; else ( SpringExceptionHandlerConstants . . contains ( true { = new , SQLState vendorCode ) } else if ( SQL_STATE_PREFIX_DATA_ACCESS_RESOURCE_FAILURE ( sqlStatePrefix ) ) { result new DataAccessResourceFailureException reason , SQLState , ) ; } else ( SpringExceptionHandlerConstants . SQL_STATE_PREFIX_TRANSIENT_DATA_ACCESS_RESOURCE_EXCEPTION . contains ( sqlStatePrefix == true ) { result = new reason SQLState , ) ; else . . contains ( sqlStatePrefix ) == true ) { result = new ConcurrencyFailureException reason , , ) } return result ;<CODESPLIT>Checks SQL state and tries to convert it into Spring SQL Exception . This implementation is vendor free .
public matches ( name ) if ( == null ) return pattern equals ( "" ) if ( null ) all . equals ( name ) ; } if middle != null ) return middle if start != null ! . startsWith start ) ) { return false ; } return end == null || . endsWith ( end ) ; }<CODESPLIT>Checks if Simon name matches this pattern .
static nslimitselector ( nitro_service service , selectorname ) Exception nslimitselector = new nslimitselector ( ) ; obj . nslimitselector response = ( nslimitselector ) obj . get_resource service ) ; return ; }<CODESPLIT>Use this API to fetch nslimitselector resource of given name .
public static int ( [ ] eqn double [ ] res ) double a = [ ] ; double b = ] ; double = [ 0 ] int rc 0 if ( == 0f ) { if == 0f ) { return - ; res [ ] = - c b ; } { double d b - * * ; if ( < 0f ) ; d Math . ) ; [ rc ] = ( - b d ( a * ) ; ( != 0f ) { res [ rc ] = ( - b - d ) / ( a * 2f ) ; } } return res rc ) ; }<CODESPLIT>Solves quadratic equation
Set < > getAllTerms ( ) final Set Term ret new HashSet < Term > ( ) ; : statementGroups ) { for ( final Statement stmt sg . getAllStatements ( ) ) { ret . ( stmt getAllTerms ( ) ; } ret ;<CODESPLIT>Returns the set of all terms contained within the document .
public void cancelCopy ( CopyOperationImpl op SQLException { ( hasLock ( op ) ) throw new PSQLException ( . tr ( "Tried to cancel inactive operation" ) , PSQLState . OBJECT_NOT_IN_STATE ) ; } SQLException error = null ; int = 0 ; { ( CopyIn { ( this ) { LOGGER ( FINEST , "FE => CopyFail" ) final byte ] msg . "Copy cancel requested" ) ; sendChar ( 'f' ) ; pgStream sendInteger4 ( 5 msg . ) ; pgStream . send msg ) ; . sendChar ) ; . flush ( ) ; do try { processCopyResults ( op true ) ; } ( SQLException { ++ ; if error != ) { e = se ; SQLException ; while ( ( next = e . ( ) ) null { e = next setNextException ( error ) } = ; } } ( hasLock ( ) ; } } ( CopyOut ) { sendQueryCancel ( ; } catch ( IOException ) { throw PSQLException ( . ( connection copy operation" PSQLState . CONNECTION_FAILURE , ioe ) finally { synchronized ( ) { ( hasLock ( op ) ) unlock ( op ) ; } } } ( op instanceof { if ( errors 1 { throw new PSQLException ( . ( "Missing expected error copy request" ) , PSQLState . COMMUNICATION_ERROR } else if ( errors 1 ) new PSQLException ( GT ( "Got error responses to single copy cancel valueOf ( errors , PSQLState . ) ; }<CODESPLIT>Finishes a copy operation and unlocks connection discarding any exchanged data .
. google api . ads . adwords . axis o . AttributeType [ ] getRequestedAttributeTypes ) { return ; }<CODESPLIT>Gets the requestedAttributeTypes value for this TargetingIdeaSelector .
public setRange Annotation v ) ( OntRelationMention_Type featOkTst ( OntRelationMention_Type ) jcasType ) . casFeat_range == null throwFeatMissing ( "range" , "de.julielab.jules.types.OntRelationMention" ) ; jcasType . . ll_setRefValue ( addr , ( ( OntRelationMention_Type ) ) . casFeatCode_range , . . ll_getFSRef ( ; }<CODESPLIT>setter for range - sets
List < . ibm . security . . . > getRelatedRolePlayer ( ) { if ( relatedRolePlayer = new ArrayList < com . ibm . wsspi security . wim . model . RolePlayer > ( return this . ; }<CODESPLIT>Gets the value of the relatedRolePlayer property .
JCExpression getUnderlyingBinding unifier ) { return ( unifier == null : unifier . getBinding ( new UFreeIdent . Key ( identifier ) ; }<CODESPLIT>Gets the binding of the underlying identifier in the unifier .
void clearCache ) { . ( CommercePriceEntryImpl . class ; finderCache . clearCache ( FINDER_CLASS_NAME_ENTITY ) ; finderCache . FINDER_CLASS_NAME_LIST_WITH_PAGINATION ) finderCache ( FINDER_CLASS_NAME_LIST_WITHOUT_PAGINATION ; }<CODESPLIT>Clears the cache for all commerce price entries .
int computeCapacity int initial ) ( initial MINIMUM_CAPACITY { MINIMUM_CAPACITY ; } if ( initial > MAXIMUM_CAPACITY } int capacity = 1 ; while ( capacity < initial ) { capacity ; } return ; }<CODESPLIT>Compute capacity given initial capacity .
V get K k , long , TimeUnit unit ) , TimeoutException { await ( k , timeout , ; return get ( k ; }<CODESPLIT>Retrieve the value associated with the given key blocking as long as necessary up to the specified maximum .
public static void ( final Path distributedClassPath , Path , final Job ) throws IOException { String classpathProperty = System . getProperty if ( classpathProperty null { classpathProperty = getProperty ; } [ ] jarFiles = classpathProperty ( File . pathSeparator ) ; Configuration = job getConfiguration ( ) ; final FileSystem fs distributedClassPath . getFileSystem ( conf ) ; if fs instanceof LocalFileSystem { ; } for String jarFilePath : final jarFile new File ; if jarFile . ( ) . endsWith ) try { RetryUtils ( ( ) { if isSnapshot ( jarFile ) { addSnapshotJarToClassPath ( jarFile intermediateClassPath , fs , job ) ; } { addJarToClassPath ( jarFile distributedClassPath , , fs job ) } return , shouldRetryPredicate ( , NUM_RETRIES ) ; } catch ( Exception e { throw new RuntimeException ) } } }<CODESPLIT>Uploads jar files to hdfs and configures the classpath . Snapshot jar files are uploaded to intermediateClasspath and not shared across multiple jobs . Non - Snapshot jar files are uploaded to a distributedClasspath and shared across multiple jobs .
public void eval String javascript ) throws WidgetException WebElement element = findElement ) WebDriver = ( . getWrappedDriver ( ) ; { ( ( ) ) . executeScript ( javascript , element ) } catch ( Exception ) { long System . currentTimeMillis ( ) ; success = false ; while ( success && System . currentTimeMillis ( ) < time ) { ( ) . executeScript ( , element true } Exception { . sleep 500 ) ; } catch InterruptedException e1 ) { } e e2 ; } } if ( ! success ) { ( e ) ; } } }<CODESPLIT>Executes JavaScript code on the current element in the current frame or window .
long addWrapField long instant , int ) { return set , FieldUtils . getWrappedValue ( get ( instant ) , 0 - 1 ) ; }<CODESPLIT>Add the specified amount to the specified time instant wrapping around within the remainder range if necessary . The amount added may be negative .
protected SendRequest makeUnsignedChannelContract Coin valueToMe { Transaction tx = new Transaction wallet . ( ) ) ! getTotalValue . subtract ) . equals ( Coin . ZERO ) ) tx . addOutput ( ( valueToMe . ( wallet . ( , getClientKey ) ) ) ; } tx . addInput ( contract getOutput ( 0 ) ) ; return . forTx ( tx ) ; }<CODESPLIT>Create a payment transaction with valueToMe going back to us
String getUserNameFromToken String authToken ) { if ( null { return null ; } return authToken . split ( TOKEN_SEPARATOR ) ; }<CODESPLIT>Extracts the user name from token .
protected Class < > resolveProxyClass ( String [ interfaceNames throws ClassNotFoundException { proxyClassLoader = classLoader ; Class < ? > [ ] [ interfaceNames . ] Class < ? = ( int = 0 ; i < length ; i ++ ) { < > intf loadClass ( interfaceNames [ i ] ) if ( ! Modifier . isPublic ( intf getModifiers ( ) ) ClassLoader classLoader = ( intf ) nonPublicInterface null { if proxyClassLoader ) throw new ( nonPublicInterface + " + " both declared different class loaders" ; } else { nonPublicInterface = ; proxyClassLoader = classLoader } } interfaces [ i ] = intf try { . getProxyClass ( proxyClassLoader , interfaces ) ; } catch ( IllegalArgumentException ex { throw new ClassNotFoundException , ) ; }<CODESPLIT>Delegates class loading to the specified class loader .
static double ] rowSums ( double ] [ data { [ ] x = new double [ data ( int i = 0 ; i < x length ; i ++ ) { x [ i = sum data [ i ) } x ;<CODESPLIT>Returns the row sums for a matrix .
protected void rehash int newCapacity ) { int = . length ; oldTable [ ] = table ; int oldValues [ ] oldState [ ] state long newTable [ new ] ; newValues [ ] = new newCapacity ] ; byte newState [ = byte [ ] ; this . lowWaterMark = chooseLowWaterMark newCapacity , this . minLoadFactor ) ; this highWaterMark = chooseHighWaterMark newCapacity this . maxLoadFactor ; this . ; . = newValues state = ; this freeEntries = newCapacity - distinct ( int i ; i -- 0 ; { if ( oldState i ] == FULL { long element = oldTable i ] int index = indexOfInsertion element ) [ index ] element ; newValues [ index ] = oldValues [ ] ; newState [ = ; } }<CODESPLIT>Rehashes the contents of the receiver into a new table with a smaller or larger capacity . This method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark .
public add ( HpackHeaderField header ) int headerSize = header . ( ) ; ( headerSize capacity clear ( return ; } ( - size < headerSize { remove ( ) ; } hpackHeaderFields [ head ++ += ( ) ; if ( head == hpackHeaderFields . length { head = 0 ; }<CODESPLIT>Add the header field to the dynamic table . Entries are evicted from the dynamic table until the size of the table and the new header field is less than or equal to the table s capacity . If the size of the new entry is larger than the table s capacity the dynamic table will be cleared .
private void fired initial ) { for ( final LauncherListener listener : { . ( ; for ( final launchableConfig ) { Media = Medias . create ( launchableConfig . getMedia ) ) ; featurable = factory create ( media ) ; try Launchable = featurable getFeature ( Launchable class ; if ( launchableConfig . getDelay ( ) > { add DelayedLaunch ( launchableConfig initial , , ) } { launch initial , , launchable ; } } catch ( final LionEngineException exception ) { featurable . getFeature ( Identifiable . class ) . ; throw exception ; } } }<CODESPLIT>Called when fire is performed .
static void ( InvocationManager , omgr ) { _invmgr invmgr ; _omgr = omgr ; invmgr . registerProvider ( ( ) TimeBaseMarshaller , GLOBAL_GROUP ; }<CODESPLIT>Registers the time provider with the appropriate managers . Called by the presents server at startup .
createLogFile ( location , long start , long end new UfsJournalFile ( location , start end , false ; }<CODESPLIT>Creates a journal log file .
Object writeReplace ) throws java . ObjectStreamException try return CertificateRep ( type , getEncoded ( ) ) e ) { throw new java . io . ( "java.security.cert.Certificate: " + type + ": " + ( ) ) } }<CODESPLIT>Replace the Certificate to be serialized .
static Throwable final Object [ ] arguments ) { length == 0 ? null : extractThrowable ( arguments length - ] ) ; }<CODESPLIT>Returns a throwable if the last argument is one .
public List < < IBond IBond > makeBondMapsOfAtomMaps ( IAtomContainer , IAtomContainer , List < Map , IAtom mappings ) < Map < IBond , IBond > > bondMaps new ArrayList < Map IBond ( ( < IAtom , > mapping : mappings { bondMaps . add ( makeBondMapOfAtomMap ( ac1 , ac2 mapping ) ; } return bondMaps ; }<CODESPLIT>Returns bond maps between source and target molecules based on the atoms
LongConstant addLong long value ) entry = ( ) if ( entry != null ) return entry ( this , _entries . size ( ) , ) ; addConstant ( entry ) ; addConstant ) ; return ; }<CODESPLIT>Adds a long constant .
getOrOpen ( name , File file ) { return ( , file , true ; }<CODESPLIT>Get the cached GeoPackage or open and cache the GeoPackage file
static int ( String clz_name int idx clz_name lastIndexOf 'V' ) ; if ( idx == - ; try { return Integer . valueOf ( clz_name substring ( idx + 1 ) ) ; } ( ex { return ; } }<CODESPLIT>Extract the version number from the schema class name . Returns - 1 if there s no version number at the end of the classname .
private drawShape ( Canvas canvas , paint , Path , shapeAppearanceModel RectF ) { if ( shapeAppearanceModel ( { float cornerSize = shapeAppearanceModel . getTopRightCorner ( ) . ( ) ; canvas . drawRoundRect ( bounds , , paint ) ; } canvas drawPath , paint ) ; }<CODESPLIT>Draw the path or try to draw a round rect if possible .
public AnalyzerJob getAnalyzerJob final String descriptorName , final analyzerName final String analyzerInputName { List < AnalyzerJob > candidates = new ArrayList < > ; candidates = . ( candidates , { = o getDescriptor ( ) . getDisplayName ; return descriptorName . equals ( ) } ) if ( analyzerName != null ) { = CollectionUtils2 . refineCandidates ( candidates , o { final String = . getName ( ; return analyzerName actualAnalyzerName ; ) ; analyzerInputName != ) { = CollectionUtils2 . refineCandidates ( , { final InputColumn ? > inputColumn = ( o ; if ( inputColumn null ) { return ; } return analyzerInputName equals inputColumn getName ( ) ) ; ) candidates . isEmpty ( ) { . error ( AnalyzerJob candidates to choose from" ) return null ; } else if candidates ( 1 { logger . warn ( "Multiple ({}) AnalyzerJob to choose from, picking first" ; } return candidates iterator ) next ( ;<CODESPLIT>Gets the best candidate analyzer job based on search criteria offered in parameters .
removeExecutedTradeCallback ( BitfinexExecutedTradeSymbol tradeSymbol , final BiConsumer < BitfinexExecutedTradeSymbol callback ) throws BitfinexClientException { return tradesCallbacks . ( tradeSymbol , ; }<CODESPLIT>Remove a executed trade callback
HealthDto doPrimaryHealthCheck ) { List < > primaryHealthDependencies healthDependencies values ) . stream ( ) . filter ( collect ( Collectors . toList ( ) ) return checkHealth ( primaryHealthDependencies ; }<CODESPLIT>Performs the Primary Health Check .
static appfwxmlerrorpage ( nitro_service service ) Exception { appfwxmlerrorpage obj new ( ) ; appfwxmlerrorpage [ ] response = obj . get_resources ( service ) return response [ 0 ; }<CODESPLIT>Use this API to fetch all the appfwxmlerrorpage resources that are configured on netscaler .
private setupClient ( final AbstractHttpClient client { this . . ( HttpResponseInterceptor ) { void process HttpResponse final HttpContext context ) throws , IOException { Header = response . getFirstHeader ( "Location" ) ; if ( header . , header . getValue ( ) ) ; } } ) }<CODESPLIT>This method is used to capture Location headers after HttpClient redirect handling .
private quickSelect ( < P points , int splitAxis , int ) { numPoints = points ) ; tmp . numPoints { tmp = new double [ numPoints ; indexes = new [ for = ; i < ; ++ ) tmp [ i = distance . valueAt ( points get ( i ) , splitAxis ) } QuickSelect . selectIndex ( tmp , , numPoints , indexes ) ; }<CODESPLIT>Uses quick - select to find the median value
public writeHtml ( pOut , pHtml ) throws IOException { StringTokenizer = new ( , ) ; parser . ) { String token = parser . nextToken ) ; if ( . ) print "&lt;" ) else ( token equals ( ">" ) { pOut . print ( ) ; } else if ( token . equals ( "&" ) ) { pOut . print "&amp;" ; } else { pOut print ( token ) ; } } }<CODESPLIT>writeHtml ensures that the text being outputted appears as it was entered . This prevents users from hacking the system by entering html or jsp code into an entry form where that value will be displayed later in the site .
getNodeName ( node ) { String result = node ) ; return result == null ? node getNodeName ( ) ; }<CODESPLIT>Returns the node name . First tries local name . If this is null returns instead the full node name .
void setExpiryDate @ IntRange ( from 1 , = ) month , @ IntRange ( from = 0 int year ) { mExpiryDateEditText . setText ( DateUtils . createDateStringFromIntegerInput , year ) ; }<CODESPLIT>Set the expiration date . Method invokes completion listener and changes focus to the CVC field if a valid date is entered .
protected writeApplyDdl ( DdlWrite write ) scriptInfo . setApplyDdl "-- dependencies\n" + write applyDropDependencies ( . getBuffer ) + "-- apply changes\n" write apply ( ) . ( ) + write . applyForeignKeys ( ) . getBuffer applyHistoryView getBuffer ( ) + write . applyHistoryTrigger ) . getBuffer ( ) ) }<CODESPLIT>Write the Apply DDL buffers to the writer .
static final classEquals ( Class clz1 Class clz2 { ( == null || clz2 == null ) { ; } return clz1 == clz2 || clz1 . ( ) . equals ( getName ( ) ; }<CODESPLIT>Compares if two classes are equal or their class names are equal .
void addSharedFunction ISource source ) { fileName = source instanceof ( ( FileSource ) source ) . getFileName ( null ; source , fileName ; }<CODESPLIT>Add shared function by ISource
setCommercePriceListService ( . liferay . commerce . price . . CommercePriceListService commercePriceListService ) { . commercePriceListService = ; }<CODESPLIT>Sets the commerce price list remote service .
HtmlTree MAIN ) { HtmlTree htmltree = new HtmlTree MAIN ) ; htmltree . setRole ( Role MAIN ) ; ; }<CODESPLIT>Generates a MAIN tag with role attribute .
static cachepolicylabel_stats ( nitro_service service , labelname ) Exception cachepolicylabel_stats = new cachepolicylabel_stats ( ) ; obj . cachepolicylabel_stats response = ( cachepolicylabel_stats ) obj . stat_resource service ) ; return ; }<CODESPLIT>Use this API to fetch statistics of cachepolicylabel_stats resource of given name .
protected saveBroker ( mapfile , broker ) throws { if broker isModified ( ) ) return } BufferedWriter bout BufferedWriter ( new FileWriter ( mapfile ) ) ; . writeTo ( bout ; bout ) ( ioe ) { throw new RuntimeException ( "Unable to store component ID map [mapfile=" mapfile "]" , ioe ) ; } }<CODESPLIT>Stores a persistent representation of the supplied hashmap ID broker in the specified file .
void update final Collection < values ) DataAccessException jdbcTemplate execute ( new ConnectionCallback < Object > ( ( Connection connection ) throws SQLException , DataAccessException { . update ( connection , values ) ; ; } } ; }<CODESPLIT>update the objects .
public MutableInt fromExternal ( final IntSupplier , final IntConsumer ) return MutableInt ) { public int getAsInt { . getAsInt ( ) ; } public Integer get ( { return getAsInt ( ) ; } public MutableInt ( value ) { c ( ) this ; } } }<CODESPLIT>Construct a MutableInt that gets and sets an external value using the provided Supplier and Consumer
void configure Config config ) . debug "Reloading ) this . configWriteLock . lock ( ) ; = config ; processAppPackages ( config ) ; } finally { this . unlock ( ) } }<CODESPLIT>Replace the configuration of this instance directly .
void addPropertiesStart String type ) { ( PropertyKey Host name ) , IpUtils . getHostName ( ) ) Type . name ( ) , type ) ; ( PropertyKey . Status . name ( ) , . name ( ; }<CODESPLIT>Add properties to properties map on transaction start
List < . Sequence getSequence ) { if ( == null ) { sequence = new ArrayList < SequenceListType > ( ; this . ; }<CODESPLIT>Gets the value of the sequence property .
MapBuilder addNumber String fieldName , boolean , Supplier Number supplier { if ( include ) { Number value ) ; if ( value != null ) { . put ( getFieldName ( fieldName ) , } } return ; }<CODESPLIT>Adds the number value to the provided map under the provided field name if it should be included . The supplier is only invoked if the field is to be included .
public void disconnectCardOneConsumer ) if ( TraceComponent isAnyTracingEnabled ( ) && tc ( ) SibTr entry ( tc , "disconnectCardOneConsumer" [ ] clonedConsumerPoints = null synchronized ( consumerPoints { clonedConsumerPoints consumerPoints toArray ( ; } SILimitExceededException e = ( nls . getFormattedMessage ( "CONSUMERCARDINALITY_LIMIT_REACHED_CWSIP0472" new [ ] ( ) , getLocalisationUuid ) . toString ( ) } , ) FFDCFilter processException e "com.ibm.ws.sib.processor.impl.RemoteConsumerDispatcher.disconnectCardOneConsumer" , "1:945:1.97.2.21" this ) ; ( , ) ; i = ; i clonedConsumerPoints . length ; i ) ck = ( ) [ i ; ck . notifyConsumerPointAboutException ( e ; } if ( TraceComponent . isAnyTracingEnabled ( ) && tc . isEntryEnabled ( ) ) SibTr . tc "disconnectCardOneConsumer" ) ; }<CODESPLIT>The disconnectCardOneConsumer method is invoked by the Anycast Input Handler to notify it that the current cardinality - one consumer must be disconnected . This can happen when this RME becomes unreachable and the DME allows a consumer in a separate RME to connect . As soon as this RME becomes reachable again the DME sends ControlCardinalityInfo to trigger this consumer s disconnection .
boolean isAdministrator AuthContext ctx ) { ctx . ( != && ctx . getUsername ( ) . equals . getPassword ( ) != null && ctx . getPassword ( equals ( adminPass ; }<CODESPLIT>Check if the given credentials allow administrative access
protected void init ) { ( settings autostart ) ) { runner = settings . getRunner ( ) ; logger . config ( " runner . ( . getSimpleName ( ; settings . ( OperaDefaults . SERVER_DEFAULT_PORT_IDENTIFIER ) ; createScopeServices ( ) ; ( != null ) { . startOpera ( ; } services init ( ) ; debugger = services . ( ) ; ( this ) windowManager = services getWindowManager ) ; exec = services . ) ; core services . getCore ( ) ; cookieManager . ) ; new OperaMouse ( this ; keyboard new OperaKeyboard ( this ; services . getConsoleLogger ) . onConsoleMessage ( ConsoleMessageConverter logs ) ) ; settings . setProduct utils ( ) ) ; ! ( . ) . contains ( "Mini" ) ) { new OperaScopePreferences . getPrefs ( ) ; ( ) set ( Unrequested Popups" , ; utils ) . ) is ( MOBILE ) { preferences ) . set ( "User Prefs" Form Element" true ) ; } } proxy = new OperaProxy ( this ) ; proxy parse ( . getProxy ( ) ) ; }<CODESPLIT>Initialize required Scope services .
public static String String string ) { byte [ ] hash ; hash MessageDigest getInstance "MD5" . digest ( . getBytes "UTF-8" ) ; catch ( NoSuchAlgorithmException e ) throw new ( MD5 be supported?" , e } catch ( UnsupportedEncodingException e throw RuntimeException ( UTF-8 should be , e ) ; } StringBuilder = new StringBuilder ( . length ) ; ( byte b : hash ) int ( & ; i < 0x10 hex ( '0' ) ; hex . append Integer . toHexString ( i ) ) } hex . toString ( ) ; }<CODESPLIT>Calculate the MD5 of a given String
static File ( File dir for ( i 0 dir != null && i < 20 ; rawDir = findResRawDir ( dir ) ; if ( != null ) { return rawDir ; } dir dir getParentFile ) ; null ; }<CODESPLIT>Look for the resource - directory in the current directory or the directories above . Then look for the raw - directory underneath the resource - directory .
Object resolveVariable String pName ) throws { ELContext ctx = getELContext ( ) ; return ctx . getELResolver ( getValue ( null , pName ; }<CODESPLIT>LIDB4147 - 9 Begin - modified for JSP 2 . 1
protected DependantValue createPrimaryKeyValue InFlightMetadataCollector mappings , PersistentProperty property Collection collection , Map < , > ) { KeyValue keyValue ; DependantValue key ; = collection . getReferencedPropertyName ( ; if ( propertyRef == null { = collection getOwner ) . getIdentifier ; } else { keyValue KeyValue collection . ( ) . ( ) . getValue ( ) ; } if isDebugEnabled ( ) ) . debug ( "[GrailsDomainBinder] value [" + . ) getName + ) new DependantValue ( metadataBuildingContext , collection getCollectionTable ( ) , ) ; key . ( null ) ; key . setNullable ( true ; key . false ) ; key ; }<CODESPLIT>Creates the DependentValue object that forms a primary key reference for the collection .
AVariableExp getVarExp name , PDefinition vardef , PType type ) var = getVarExp ( name , vardef ) ; setType type ; return ; }<CODESPLIT>Generate Var Exp with everything!
static boolean ( String ) if ( Strings . ( arg ) || arg . trim ( ) . ) ) return } return ; }<CODESPLIT>Determines whether the parameter string is null empty or whitespace .
queryBlockByNumber ( blockNumber ) throws InvalidArgumentException , ProposalException { getShuffledPeers ( EnumSet . of ( PeerRole . ) ) , ; }<CODESPLIT>query this channel for a Block by the blockNumber . The request is retried on all peers till successful
( "unchecked" public static Getter getGetter ( Class type ) { return getGettersAsMap ( type ) get ( name ; }<CODESPLIT>Search getter for given class and property name .
static String ( byte [ ] , String ) try return new String ( decodeLZ ( data ) catch ( UnsupportedEncodingException e ) { throw RuntimeException ( e ) } }<CODESPLIT>Decode lz to string string .
AirlineFlightUpdateTemplateBuilder addAirlineFlightUpdateTemplate String introMessage , String locale , String updateType ) { return new AirlineFlightUpdateTemplateBuilder ( introMessage , locale , pnrNumber ; }<CODESPLIT>Adds an Airline Flight Update Template to the response .
private void addModulesArgument ( final String final List String arguments , final Module [ modules , final String , final String role ) throws { buf = new StringBuilder ( ) ; if ( null != aditionalpath ) { arguments add ( argument ; . aditionalpath ; if ( modules != null . 0 ) { if ( ! . contains argument ) arguments ( argument ) ; } int i = 0 ; i modules . length ++ i { Module module = modules i ] ; artifact = @ SuppressWarnings "unchecked" ) Set < Artifact > = project . getArtifacts ( ; for ( Artifact : allArtifacts if art . getGroupId ) . ( module getGroupId ( ) ) && . getArtifactId ( ) . equals ( module getArtifactId ( ) && . defaultString ( module ) . equals . ( . getClassifier ( ) ) && . ( module . ) ) . equals ( StringUtils defaultString art . getType ( ) ) ) artifact = ; ; } == null throw new MojoExecutionException ( "The artifact module . toString ( + " in aspectj plugin as " + + ", is not found the project dependencies" ; } ( . ( ) 0 ) { buf . append ( . ) ; } buf append ( getFile ( ) . getPath ( ) ) } if ( buf . ( > { String = buf toString ( ) arguments . add ( pathString ) . debug ( + argument + pathString ) }<CODESPLIT>Finds all artifacts in the weavemodule property and adds them to the ajc options .
static String ( final HttpServletRequest request { String client . ( "aerogear-sender" ) ; if ( hasValue ( client client ; } request . getHeader ( "user-agent" ; }<CODESPLIT>Reads the aerogear - sender header to check if an AeroGear Sender client was used . If the header value is NULL the value of the standard user - agent header is returned
public < ServiceMessage requestMany ( request , Class < ? > , Address ) { return ( ( { requireNonNull , address parameter is required and must not null" ) ; requireNonNull transport and null" ; return transport create address ) requestStream ( request ) . map ( message -> ServiceMessageCodec decodeData ( message responseType ) ) . map ( this throwIfError ) ; } ) ; }<CODESPLIT>Given an address issues request to remote service which returns stream of service messages back .
public void incrementalRestore incrementalBackupFile ) throws FileNotFoundException , IOException , ClassNotFoundException , ObjectInputStream = ; { = new ObjectInputStream PrivilegedFileHelper ( incrementalBackupFile ) while ( true ) { changesLog = ( ) . setSystemId ( . JCR_CORE_RESTORE_WORKSPACE_INITIALIZER_SYSTEM_ID ) ; ChangesLogIterator cli . ( ) while ( cli hasNextLog ( ) ) { if ( cli . nextLog ( . getEventType == LOCK ) { cli . removeLog ) } ( ) ; ( EOFException ) { ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "An exception occurred: " + ( ) ) ; } } }<CODESPLIT>Perform incremental restore operation .
public < Integer > start ( { final Key < Integer object = new < Integer ( consumers . object , new < > ( ) { count ; public void consume ( final ByteBuffer buffer ) remaining } public Integer finish ( ) { return count ; } ) ; return object }<CODESPLIT>Initializes a byte counter on this channel .
static boolean ( String locator ) logger . ( ) boolean flag = false ; try { flag locator ) != null ; } catch ( NoSuchElementException ) { } logger . exiting ) ; return ; }<CODESPLIT>Checks if the provided element is present on the page based on the locator provided
public static void ( String args [ ] throws { final StringBuffer = new StringBuffer ( "The lazy fox" ) ; Thread ( ) { void ( ) { buffer . delete 0 , 4 ) ; append ( " in the middle" ; . err println ( "Middle" ) ; try { . sleep ( 4000 ) ; } catch Exception e ) } . append ( of fall" ) err println "Fall" ) } ; t2 = Thread ( ) { run { try { sleep ( 1000 ; } ( Exception e ) } buffer . append " jump over the fence" ) ; System err . println ( ) ; } ; . start ) ; start ( ) t1 . join ( ) ; t2 . join ) ; System . println buffer ) ;<CODESPLIT>We have more input since wait started
protected double interpolate double boundA , double boundB { double alphaNew ; Double isNaN gp ) alphaNew = SearchInterpolate . quadratic , gprev stprev fp , stp ) ; } else { = SearchInterpolate . cubic2 fprev , gprev , fp , gp , ; ( Double . isNaN ( alphaNew ) alphaNew = SearchInterpolate . quadratic ( fprev , gprev , fp ) double l , ; if ) l ; } { l boundB ; u = boundA } if ( alphaNew < l ) alphaNew = l ; else if ( alphaNew > = u ; return alphaNew ; }<CODESPLIT>Use either quadratic of cubic interpolation to guess the minimum .
private List < > check ( DataType dataType { . finer ( semantic constraints on datatype " + dataType . name ) ; SemanticError > errors new < SemanticError > ) ; String > = new HashSet < String ) ; for ( Constructor constructor dataType constructors ) logger . finest ( "Checking semantic constraints constructor " + constructor . name + " datatype " + . ) ; if dataType . constructors ) 1 dataType . ( constructor name ) { logger . info ( with as its data " + dataType . + "." ; errors . add _ConstructorDataTypeConflict ( dataType . ) ) ; } ( . ( constructor . name ) { "Two constructors with same name + . + data type " + dataType . name + "." ) errors . ( ( . name constructor . ) } else { . add ( constructor . name ) ; } errors addAll ( check ( , ) } return errors ;<CODESPLIT>Checks a data type for duplicate constructor names or constructors having the same name as the data type
SuppressWarnings ( "unchecked" , "rawtypes" } protected void ( additionalList GrailsPlugin plugin ) { if ( ! addedNames getName ( ) ) ) { addedNames . add plugin . getName ( ) ) ; additionalList . ( plugin ; ( , ) } }<CODESPLIT>Adds a plugin to the additional if this hasn t happened already
private executeRequest ( request ) IOException , GroovesharkException { HttpResponse response httpClient . ( request ) debugLogging ) ( request ) } String responsePayload = CharStreams . toString new InputStreamReader ( response getEntity ( . ) ) ; { jsonMapper . ( new StringReader responsePayload ) ) ; } catch JsonProcessingException e ) { throw new GroovesharkException . ServerErrorException ( "Failed parse response - received data was not " + responsePayload ) ; } }<CODESPLIT>Boilerplate to send the request and parse the response payload as JSON .
public < String T > ( JsonParser jsonParser ) throws IOException HashMap < , > HashMap < T > ; ( jsonParser . nextToken ( ) != . END_OBJECT ) { key ( . ( ) ; ( . getCurrentToken ) == JsonToken VALUE_NULL ) { map . put key , null ) ; } else { map . ( key , parse ( jsonParser ) ; } } return map ; }<CODESPLIT>Parse a map of objects from a JsonParser .
subtract ( d ) { date . setTime ( ( ) - d . parse ( ) ; return ; }<CODESPLIT>subtract date on supported date
double radicalInverse long i ) digit = / double base ; double radical = digit ; double ( i > 0 ) { inverse += digit ( double ) ( i % base ) ; *= radical i base } inverse ; }<CODESPLIT>Compute the radical inverse of i .
public getTempDir ( ) { ( FileUtil . class ) if ( TEMP_DIR null ) String System . ( "java.io.tmpdir" ) ; ( . isEmpty ( tmpDir ) ) { if ( new File ( "/temp" ) . } else { tmpDir "/tmp" ; } } TEMP_DIR = ; } } return TEMP_DIR }<CODESPLIT>Gets the default temp directory for the system .
static < , Value > ( List Value list Accumulator init , ReduceClosure < Accumulator , Value accumulator = init ; for ( Value value : ) { accumulator = f . eval ( accumulator ; } return ; }<CODESPLIT>Applies a binary function between each element of the given list .
protected ProcessOutput executeProcess faxJob , String command , FaxActionType faxActionType ) { command == null { ( ) String updatedCommand ; ( . useWindowsCommandPrefix ) { StringBuilder = new StringBuilder ( . ) + this length ) + 1 ; . append this . windowsCommandPrefix ; buffer . append ( " ) ; buffer . append ( updatedCommand updatedCommand = . toString ( ) ; } ProcessOutput = ProcessExecutorHelper . ( updatedCommand ) ; this . validateProcessOutput processOutput faxActionType ) ; this . updateFaxJob ( processOutput faxActionType ) ; return processOutput ; }<CODESPLIT>Executes the process and returns the output .
ModelNode getConnector String name ) { final Address Address . root ( ) . add ( SUBSYSTEM , SUBSYSTEM_WEB ) ; readResource ( address , true ; }<CODESPLIT>Returns the connector node with all its attributes . Will be null if it doesn t exist .
int match ( CharsetDetector det ] commonChars ) { @ SuppressWarnings ( "unused" ) int = 0 ; int = 0 ; int commonCharCount = ; int badCharCount 0 ; int totalCharCount = 0 ; confidence = 0 ; iter = new iteratedChar ) detectBlock for iter . reset ( ) ; nextChar iter { ++ ; ( error ) { ++ else long cv charValue & 0xFFFFFFFFL ; if ( cv <= ) singleByteCharCount ++ } else { doubleByteCharCount ( commonChars != null ( Arrays binarySearch ( commonChars ( cv >= 0 ) { commonCharCount ++ } } } } if >= 2 && badCharCount * 5 >= ) { break detectBlock ; } if doubleByteCharCount <= 10 && badCharCount == 0 ) if ( doubleByteCharCount && totalCharCount < 10 ) confidence = 0 ; } else { = ; break detectBlock ; if ( doubleByteCharCount 20 badCharCount ) { confidence detectBlock } ( == null ) { confidence doubleByteCharCount - 20 * badCharCount ; if confidence ) = 100 } } else { double maxVal = log ( ( float ) / ) ; double scaleFactor 90.0 / maxVal ; ( int ) ( log ( commonCharCount 1 ) * scaleFactor + 10 ) ; confidence = . ( confidence , } } return confidence }<CODESPLIT>Test the match of this charset with the input text data which is obtained via the CharsetDetector object .
static void ( DMatrix src , srcY0 , srcY1 int , int srcX1 , DMatrix dst ) { ) . reshape ( srcY1 - srcY0 , srcX1 srcX0 ) ; extract ( src , srcY0 , , srcX0 srcX1 dst 0 0 ; }<CODESPLIT>Extract where the destination is reshaped to match the extracted region
public resizeEip ( request ) checkNotNull ( request . getNewBandwidthInMbps ( , "newBandwidthInMbps not null" ( request ( ) should be empty" ) ; if ( Strings isNullOrEmpty ( request . ( request generateDefaultClientToken ) ) InternalRequest = this createRequest ( request HttpMethodName . PUT , request . ( ) ) ; internalRequest . addParameter , null ) ; internalRequest . addParameter ( CLIENT_TOKEN_IDENTIFY , . getClientToken ( ) ) fillPayload ( internalRequest , request ) ( internalRequest , AbstractBceResponse . class ) ; }<CODESPLIT>Resizing eip The Prepaid eip can not be downgrade . This is an asynchronous interface .
void useNextAddressAsNewContactSeedBroker ) { if currentContactSeedBrokerIndex == . ) currentContactSeedBrokerIndex = 0 ; } URL newContactUrl = [ currentContactSeedBrokerIndex ] ) ; this . consumer = SimpleConsumer ( newContactUrl . getHost ( ) , newContactUrl getPort ( , , , ) ; }<CODESPLIT>Re - establish broker connection using the next available seed broker address .
private String unescape String ) { StringBuilder = new StringBuilder ( ) for ( int i = ; i < value . ; ++ i { c = value charAt ( ) if ( == ESCAPE_PREFIX ) { String value . substring ( i + , + 3 int code = Integer parseInt ( codeString , 16 ) ; ( reservedChars length reservedChars code ] == ) { result reservedChars code ) ; ; } { throw ServiceLocationException ( "Unknown escaped character + codeString + " position " + + 1 ) + " of + , SLPError . PARSE_ERROR ) ; } } else { result . ( c ) ; } } . ( ) ; }<CODESPLIT>Unescapes the scope string following RFC 2608 6 . 4 . 1
protected HashMap readFile HashMap brMap ) throws IOException HashMap = new HashMap ) ; ArrayList < HashMap > expArr = new ArrayList < ) ; HashMap String HashMap > files ( ArrayList < > obvData ; HashMap obv expData ; for ( String exname files keySet ( ) { obvData = ( ArrayList ) . get ( exname ) . get ( ) ; for HashMap : obvData ) expData = new ; = HashMap ( ( expData files . ( exname ) , ; expData , files ( exname ) "crid" ) copyItem ( expData , . get ( exname , "local_name" ) ; . ( , obv ) ; obv put , . get ( obvDataKey ) ; . add expData ; } } idNames = new ArrayList ) idNames . add ( ) ; removeIndex ( expArr , idNames ) ret . put ( , ) return ret ;<CODESPLIT>DSSAT TFile Data input method for Controller using
public FixedStringSearchInterpolator createInterpolator MojoParameters params String filter ) { String [ delimiters = ( filter ) delimiters == { return create ) ; } DockerAssemblyConfigurationSource configSource = new ( params , null null . . ( ) , . ( params getProject ( ) . withExpressionMarkers ( delimiters [ 0 , delimiters [ 1 ] ) , configSource . withExpressionMarkers ( delimiters [ 0 ] delimiters [ 1 ] ) ; }<CODESPLIT>Create an interpolator for the given maven parameters and filter configuration .
public boolean isPartitionCleanupInProgress ZooKeeper zk throws KeeperException , InterruptedException { List String > = zk . . leaders_initiators ) ; ZKUtil . ChildrenCallback > childrenCallbacks = Lists . newArrayList ) ; for ( child ZKUtil = ZKUtil . ChildrenCallback ) zk . ( ZKUtil . joinZKPath ( VoltZK . leaders_initiators , child , false , callback , null ) . add callback ) ; } for ( ZKUtil ChildrenCallback callback : childrenCallbacks ) { callback . get ( . isEmpty ) { return true } } return false ;<CODESPLIT>Checks if the cluster suffered an aborted join or node shutdown and is still in the process of cleaning up .
private byte [ unifyLData ( final CEMI ldata final emptySrc , final < Integer > types ) { final byte [ ] ldata instanceof CEMILDataEx { CEMILDataEx ext = CEMILDataEx ; final < AddInfo > additionalInfo = additionalInfo ( ) ; synchronized ( ) for ( Iterator < AddInfo > i = additionalInfo iterator ( ) ; i . hasNext ( ; ) { AddInfo = i . ( ) ; types contains info . ) ) logger . ( "remove L-Data additional , ; i . ) ; } } } = ldata . toByteArray ) ; data [ ] = 0 ; data [ 1 + [ 1 ] + 1 ] = ; if emptySrc ) data [ 1 ] + 3 ] = 0 ; data [ 1 + data 1 ] + 4 ; return data ;<CODESPLIT>additional info . types provides the list of add . info types we want to keep everything else is removed
public < T extends Number > ] asArray final ... ) { int [ ] b = [ ] ; for ( int i = 0 ; < b . length ; i ++ ) { [ = array [ i . ) ; return b }<CODESPLIT>Convert any number class to array of integer .
synchronized setActiveChunkHandle ( handle ) Preconditions . checkArgument ( handle == || ! . isReadOnly ( SegmentChunk handle readonly." ) last lastChunk ( ) ; Preconditions . checkState last != null , set when SegmentChunks." ; Preconditions . ( == null handle . getSegmentName ) . equals ( last . ( ) ) , "Active SegmentChunk must be for the last SegmentChunk." ) this . activeChunkHandle = handle ; }<CODESPLIT>Sets the Active SegmentChunk handle .
String getEmptyValue ) { if . featOkTst ( Timex3Interval_Type jcasType ) . casFeat_emptyValue == null ) jcasType "emptyValue" , "de.unihd.dbs.uima.types.heideltime.Timex3Interval" ) ; return jcasType . ll_cas ll_getStringValue ( addr , ( ( Timex3Interval_Type ) . casFeatCode_emptyValue ; }<CODESPLIT>getter for emptyValue - gets
public static AccountInfo ( BitstampBalance bitstampBalance , String ) { List < balances new < ( ) ; for ( org . . xchange . . . account . BitstampBalance . Balance b : . getBalances ) { Balance xchangeBalance Balance ( Currency . getInstance . ( ) . toUpperCase ( ) , b . getBalance ( ) , b . getAvailable ( b ( ZERO , ZERO b . subtract b ( ( . getReserved ) ) , ZERO ) balances . add ( xchangeBalance ) ; return new AccountInfo ( userName , bitstampBalance . getFee ( Wallet ( balances ) ) ; }<CODESPLIT>Adapts a BitstampBalance to an AccountInfo
afterConnectionClosed ( session , CloseStatus status ) { logger "WebSocket closed: {}, Close Status: {}" , session , status . toString ; }<CODESPLIT>Invoked after the web socket connection is closed . You can override this method in the child classes .
public String trimLastPathSection ( String path { String [ sections = path . split "/" ) StringBuilder newPath StringBuilder ) ; for int = 1 ; i sections . length - 1 ; i ++ ) { newPath [ . append ( "/" ) ; return newPath . toString ( ) }<CODESPLIT>Removes the last part of a file path .
static Style ) { final Style style = new ; style . color = PaletteUtils . getSolidColor ( PaletteUtils . MATERIAL_RED style ; }<CODESPLIT>Default material red transparent style for SuperToasts .
public createContext ( ) { Bean T > bean null EjbDescriptor < T ejbDescriptor = ( ) if ( . isMessageDriven ( ) bean = getBean ( ; } WeldManager beanManager = getBeanManager ( ) ; WeldCreationalContext beanManager bean ) ; ManagedObjectContext managedObjectContext = new ( creationalContext ) ; return managedObjectContext }<CODESPLIT>This version creates a ManagedObjectContext which contains a CreationalContext for an EJB .
final void String name ) { DeleteOperationRequest request = ( ) . setName ( name ) . build ( ) ; ) ; }<CODESPLIT>Deletes a long - running operation . This method indicates that the client is no longer interested in the operation result . It does not cancel the operation . If the server doesn t support this method it returns google . rpc . Code . UNIMPLEMENTED .
boolean isMember int x ) { . check currentState BitsState UNKNOWN ) ; return 0 <= x && length << wordshift ) && ( bits [ x wordshift ] & ( 1 << ( x ) ) != ; }<CODESPLIT>Is x an element of this set?
addSearchFinishHandler ( SearchFinishEvent . SearchFinishHandler handler ) { return ( , SearchFinishEvent . TYPE ; }<CODESPLIT>This handler will be triggered when search is finish
public setForeignBusSendAllowed ( sendAllowed ) if ( TraceComponent . isAnyTracingEnabled ( && tc isEntryEnabled ( ) . entry , "setForeignBusSendAllowed" . valueOf ( sendAllowed ) ) ; } _sendAllowedOnTargetForeignBus Boolean . valueOf ( ) != synchronized aliasesThatTargetThisDest ) { i aliasesThatTargetThisDest . ( ) ; while ( i . hasNext ( ) { AbstractAliasDestinationHandler abstractAliasDestinationHandler = ( AbstractAliasDestinationHandler ) next ( ; abstractAliasDestinationHandler . setForeignBusSendAllowed ( sendAllowed ) } } } if ( TraceComponent ( ) && tc isEntryEnabled ( ) SibTr . exit tc , "setForeignBusSendAllowed" ; }<CODESPLIT>Set the Foreign Bus Level sendAllowed flag
processingInstruction ( target , String data ) throws SAXException documentHandler != null ) documentHandler . processingInstruction target , data ; }<CODESPLIT>Adapt a SAX2 processing instruction event .
public Integer getFileSizeOnFTPServer String hostName Integer port , String userName , password , filePath { null ; = executeCommandOnFTPServer , , userName , password , "SIZE" , ) ; if ( == . " ) { throw RuntimeException String . ( "Unable to size of the %s file. Got reply from FTP server." , filePath , ) ; } else { result = Integer . valueOf replyString . split ( " ) [ 1 ] . replaceAll , "" ) ) ; } return ; }<CODESPLIT>Get size of the FTP file .
public base_responses enable nitro_service client String trapname [ ] ) throws { base_responses = null ; != null . length ) snmpalarm enableresources [ ] = new snmpalarm trapname . length ] for 0 trapname length ; i ) enableresources [ ] = new ( ) ; enableresources [ i . trapname = trapname [ i ] ; } = perform_operation_bulk_request ( client , enableresources , ) ; } return result ; }<CODESPLIT>Use this API to enable snmpalarm resources of given names .
void ordered < T > action ) { TopoSorter sorter = new TopoSorter < > ( this ) ; sorter . ) ; }<CODESPLIT>Traverse this graph and performs the given action in topological order
public parse ( String asg { int d1 asg . '-' ; int d2 = . ( d1 + ; int dN = asg . lastIndexOf ( '-' ; if ( dN 0 || asg ) dN = asg . length ( ) ; } return new SeqServerGroup ( , , d2 , dN ) ; }<CODESPLIT>Create a new instance of a server group object by parsing the group name .
static int ( int srcCount , numNodes ) int = int ) ( srcCount / OP_PER_MAP ) ; ( numMaps , numNodes * MAX_MAPS_PER_NODE ) ; return Math . numMaps , 1 ; }<CODESPLIT>Calculate how many maps to run .
protected channelRead0 ( ctx , msg ) throws Exception { switch msg . ( ) : originalPromise ( ) . ( ) . remove ( this ) ctx . fireChannelActive ( ; : ( AuthenticationException ( "Authentication on Bucket command" ) ; break case NOTFOUND_ERROR : originalPromise . setFailure new AuthenticationException ( "Bucket not found on command" ) ) ; break ; default : originalPromise . ( new ( "Unhandled select bucket status: " + . ( ) ) ) ; } }<CODESPLIT>Handles incoming Select bucket responses .
final DiceNotationExpression ( final DiceNotationExpression expression { final result if expression instanceof ExpressionWrapper ) { result = ( . getWrappedExpression ( ) ; } else { result expression ; } return ; }<CODESPLIT>Removes the expression wrappers used to temporally prune the nodes .
public static float ] ( float [ value , float lower , upper , String valueName ) checkNotNull ( value , valueName not be null" ; ( int i 0 ; < . length ++ i ) { float value [ i ] ; if Float isNaN ( ) { throw new ( valueName + "[" + i + must NaN" ; else ( v < ) { throw String format "%s[%d] is of [%f, (too low)" valueName , i , lower upper ; } else ( v > { throw new IllegalArgumentException ( String format "%s[%d] is out of range of [%f, %f] (too high)" , valueName i , lower , upper ) } return value ; }<CODESPLIT>Ensures that all elements in the argument floating point array are within the inclusive range
void copy InputStream inputStream , OutputStream outputStream ) throws ( inputStream , outputStream , true ; }<CODESPLIT>Writes the content provided by the given source input stream into the given destination output stream .
private static Collection Tuple > getTuples ( List VarDef varDefs , int , int varEnd , int tupleSize ) { Collection < Tuple new ArrayList < > ) ; for int i varStart i < ; i ++ ) { = varDefs . get ( i ; < VarValueDef values = nextVar . getValidValues ( ) ; if ( ! values . hasNext ( ) { throw new ( complete tuples -- valid values defined nextVar ; Collection < = tupleSize 1 ? : getTuples ( varDefs , + varEnd + 1 tupleSize - 1 ) if ( == null ) { ( values . hasNext ) ) { tuples . add new ( new VarBindingDef ( nextVar values ) ) ) ; } else ( subTuples ( ) ) { while ( values . ) ) nextBinding new VarBindingDef ( nextVar values next ( ) ) ; for subTuple subTuples ) nextTuple Tuple nextBinding ) . addAll ( ; if ( nextTuple . isCompatible ( ) ) { ( nextTuple ; } } } return ; }<CODESPLIT>Returns all valid tuples of values for the given input variables .
public ( K key ) final int hash hash ( ; int slot = indexOf hash ; Entry < V > entry = table [ slot ] ; != null ; entry entry . if hashCode hash && entry . key . equals ( key ) ) { return . ; } } return null ; }<CODESPLIT>Looks up the value mapped under the given key . Returns null if no value is mapped under this key .
boolean validSecondFactor String secret , String ) { . ( , Required . SECRET . toString ( ) ( number , Required . TOTP . toString ( ) ; return TotpUtils . secret , number ; }<CODESPLIT>Checks if a given number for 2FA is valid for the given secret
protected updateOutgoingEdgesStateDL ( int currS , currL , int , prevL Emissions ) { ( currS , DL , prevS , prevL States . DL , . t_DL_in , emission ) ; updateOutgoingEdges ( currS , currL , , States . S , Transitions . t_S_to_DL , emission ) }<CODESPLIT>Enumerates the possible transitions into state DL .
public setPrefix ( key , prefix ) { PdfName fieldname = PdfName ( ) ; PdfObject ( fieldname if ( null throw new IllegalArgumentException ( "You must set value before adding a ) new . ) ; dict put PdfName . , o ) ; dict . put ( PdfName . , new PdfString ( , PdfObject . TEXT_UNICODE ) ) ; ( fieldname , dict ) ; }<CODESPLIT>Adds a prefix for the Collection item . You can only use this method after you have set the value of the item .
protected AbstractExpression replaceExpressionsWithPve AbstractExpression expr { assert expr null ) ; if ( expr instanceof TupleValueExpression ) { int paramIdx = ParameterizationInfo . ) ParameterValueExpression pve new ( paramIdx , ; ( paramIdx expr ) ; return pve ; } if ( expr instanceof ) int paramIdx = ParameterizationInfo getNextParamIndex ( ) ParameterValueExpression pve = ParameterValueExpression ( paramIdx , expr ) ; List < TupleValueExpression > tves getTupleValueExpressions ( expr ) ; assert ( != ) ; for ( TupleValueExpression tve ) int = tve . getOrigStmtId ( ) ; m_stmtId && m_parentStmt != origId ) { throw new PlanningErrorException "Subqueries do not support of parent statement columns" ; } } m_parameterTveMap put paramIdx , expr ) ; return pve } ( ) != { . ( expr . getLeft ( ) ) ) ( expr ( ) != ) { . setRight replaceExpressionsWithPve ( expr ) ) ) if . ( ) != ) { < AbstractExpression = ArrayList < > ( for ( AbstractExpression : getArgs ( ) { newArgs . add ( replaceExpressionsWithPve ( argument ) ) ; } expr setArgs ( ) ; } return expr ; }<CODESPLIT>Helper method to replace all TVEs and aggregated expressions with the corresponding PVEs . The original expressions are placed into the map to be propagated to the EE . The key to the map is the parameter index .
private boolean addCallback ( String applicationId DelayedCallback callback ) boolean isFirst = ; < DelayedCallback list = get ) ; if ( null list ) { list new ArrayList < DelayedCallback > ( ) ; BACKLOG . put ) true ; } list . ( callback ) ; return isFirst }<CODESPLIT>Add a delayed callback for the given application id . Returns whether this is the first request for the application id .
static byte ] gunzipBytes ( byte ] compressedBytes throws { bos = new ByteArrayOutputStream ( ( int ) 1.5 ) ) ; InflaterOutputStream dos = new InflaterOutputStream bos ) ; dos . write ( compressedBytes ) dos . ( ) ; bos toByteArray ) ;<CODESPLIT>to avoid linking all that jazz into the client code
TupleValueExpression getOutputExpression int index ) { schemaCol = ( ) TupleValueExpression tve = new TupleValueExpression ( getTableAlias ( , schemaCol . getColumnAlias ( ) , schemaCol . getColumnAlias ( ) ) ; return ; }<CODESPLIT>Produce a tuple value expression for a column produced by this subquery
